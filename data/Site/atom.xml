<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><title type="text">Liang's Blog</title><subtitle type="text">StardustDL's blog based on AcBlog.</subtitle><id>uuid:7300bb13-a737-4f3d-98ea-5b8ec1f892fd;id=1</id><updated>2020-07-22T09:14:15Z</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/" /><entry><id>Tools/ssh</id><title type="text">SSH - Secure Shell</title><summary type="text">基本信息
介绍：较安全实现远程连接，控制，传输的一种工具。
基础知识
SSH之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的：
远程主机收到用户的登录请求，把自己的公钥发给用户。
用户使</summary><published>2018-09-17T18:40:02+08:00</published><updated>2018-09-17T18:40:02+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2Fssh" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;介绍：较安全实现远程连接，控制，传输的一种工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;基础知识&lt;/h1&gt;
&lt;p&gt;SSH之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;远程主机收到用户的登录请求，把自己的公钥发给用户。&lt;/li&gt;
&lt;li&gt;用户使用这个公钥，将登录密码加密后，发送回来。&lt;/li&gt;
&lt;li&gt;远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心1（CA）公证的，也就是说，都是自己签发的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ssh 默认端口是 22&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-2"&gt;客户端&lt;/h1&gt;
&lt;h2 id="section-3"&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;apt install openssh-client
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-4"&gt;登录&lt;/h2&gt;
&lt;p&gt;以用户名 user ，登录远程主机 host&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;ssh user@host
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;p&lt;/code&gt; 参数指定端口&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;ssh -p 2222 user@host
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一次登陆 ssh 会指出host主机的公钥指纹，可由此判断此主机是否是真实目标（防止中间人攻击）。确认后会要求输入密码。当远程主机的公钥被接受以后，它就会被保存在文件 &lt;code&gt;$HOME/.ssh/known_hosts&lt;/code&gt;之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。&lt;/p&gt;
&lt;h3 id="section-5"&gt;公钥登录&lt;/h3&gt;
&lt;p&gt;所谓&amp;quot;公钥登录&amp;quot;，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用 &lt;code&gt;ssh-keygen&lt;/code&gt; 生成一个。
然后使用 &lt;code&gt;ssh-copy-id user@host&lt;/code&gt; 命令，将公钥传送到远程主机host上（也可直接修改远程主机公钥存储文件）。
远程主机将用户的公钥，保存在登录后的用户主目录的 &lt;code&gt;$HOME/.ssh/authorized_keys&lt;/code&gt; 文件中。公钥就是一段字符串，只要把它追加在 &lt;code&gt;authorized_keys&lt;/code&gt; 文件的末尾就行了。
如果远程主机禁用了公钥登录，修改远程主机上的 &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; 后重启服务：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RSAAuthentication yes
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-6"&gt;单句执行&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;ssh user@host 'mkdir -p .ssh &amp;amp;&amp;amp; cat &amp;gt;&amp;gt; .ssh/authorized_keys' &amp;lt; ~/.ssh/id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。
这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道。&lt;/p&gt;
&lt;h1 id="section-7"&gt;密钥生成&lt;/h1&gt;
&lt;p&gt;使用 &lt;code&gt;ssh-keygen&lt;/code&gt; 生成密钥对。可以指定一段信息，密钥对存储位置，对私钥设置口令。默认情况下，在 &lt;code&gt;$HOME/.ssh/&lt;/code&gt; 目录下，会新生成两个文件：&lt;code&gt;id_rsa.pub&lt;/code&gt; 和 &lt;code&gt;id_rsa&lt;/code&gt;。前者是你的公钥，后者是你的私钥。&lt;/p&gt;
&lt;h1 id="section-8"&gt;远程复制&lt;/h1&gt;
&lt;p&gt;scp 是secure copy的简写，用于在Linux下进行远程拷贝文件的命令。其使用和 cp 命令类似，只是表达远程主机上的位置时需包含远程主机信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本地复制远程文件：（把远程的文件复制到本地）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;scp root@www.test.com:/val/test/test.tar.gz /val/test/test.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;远程复制本地文件：（把本地的文件复制到远程主机上）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;scp /val/test.tar.gz root@www.test.com:/val/test.tar.gz
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="scp"&gt;scp 命令参数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-1&lt;/code&gt; 强制scp命令使用协议ssh1&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-2&lt;/code&gt; 强制scp命令使用协议ssh2&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-4&lt;/code&gt; 强制scp命令只使用IPv4寻址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-6&lt;/code&gt; 强制scp命令只使用IPv6寻址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-B&lt;/code&gt; 使用批处理模式（传输过程中不询问传输口令或短语）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-C&lt;/code&gt; 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-p&lt;/code&gt; 留原文件的修改时间，访问时间和访问权限。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-q&lt;/code&gt; 不显示传输进度条。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-r&lt;/code&gt; 递归复制整个目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt; 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt; cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-F&lt;/code&gt; ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt; identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l&lt;/code&gt; limit 限定用户所能使用的带宽，以Kbit/s为单位。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt; ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-P&lt;/code&gt; port 注意是大写的P, port是指定数据传输用到的端口号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-S&lt;/code&gt; program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-9"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Linux 文档&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/u013452337/article/details/80847113"&gt;什么是SSH 以及常见的ssh 功能&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/gdb</id><title type="text">GDB - The GNU Project Debugger</title><summary type="text">基本信息
官网
介绍：一种支持多种语言的调试器。
基础知识
使用 gdb 调试 C 程序时，建议在程序编译时加入调试符号信息 -g 选项。
gdb a.out
可以使用 --tui 选项进入终端用户界</summary><published>2018-09-27T18:58:19+08:00</published><updated>2018-09-27T18:58:19+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2Fgdb" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.gnu.org/software/gdb/"&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍：一种支持多种语言的调试器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;基础知识&lt;/h1&gt;
&lt;p&gt;使用 gdb 调试 C 程序时，建议在程序编译时加入调试符号信息 &lt;code&gt;-g&lt;/code&gt; 选项。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;gdb a.out
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用 &lt;code&gt;--tui&lt;/code&gt; 选项进入终端用户界面图形化调试。&lt;code&gt;Ctrl + X&lt;/code&gt; + &lt;code&gt;A&lt;/code&gt; 切换 TUI 和传统模式。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;help h&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;帮助&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;quit q&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;退出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id="section-2"&gt;查看程序&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt; 或 &lt;code&gt;l&lt;/code&gt;：查看源代码。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;list -5 # show line 5
list func # show func
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;disassemble&lt;/code&gt; 查看汇编码。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;/m # 源码和汇编一起排列
/r # 显示16进制代码

disassemble /m main
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-3"&gt;布局&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;layout&lt;/code&gt; 命令用于分割窗口，可以一边查看代码，一边测试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;layout src&lt;/code&gt; 显示源代码窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layout asm&lt;/code&gt; 显示汇编窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layout regs&lt;/code&gt; 显示源代码/汇编和寄存器窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layout split&lt;/code&gt; 显示源代码和汇编窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layout next&lt;/code&gt; 显示下一个layout&lt;/li&gt;
&lt;li&gt;&lt;code&gt;layout prev&lt;/code&gt; 显示上一个layout&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + L&lt;/code&gt; 刷新窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + x&lt;/code&gt; 再按1 单窗口模式，显示一个窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + x&lt;/code&gt; 再按2 双窗口模式，显示两个窗口&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl + x&lt;/code&gt; 再按a 回到传统模式，即退出layout，回到执行layout之前的调试窗口。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-4"&gt;运行程序&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;run r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;重新开始运行文件，可以带参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;start&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单步执行，运行程序，停在第一执行语句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;next n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单步调试（逐过程，函数直接执行）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;step s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单步调试（逐语句：跳入自定义函数内部执行）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;nexti ni&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单步调试（逐指令，即汇编语句，函数直接执行）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;stepi si&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单步调试（逐指令，即汇编语句跳入自定义函数内部执行）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;continue c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;继续运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;finish&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;结束当前函数，返回到函数调用点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id="section-5"&gt;处理运行时信息&lt;/h1&gt;
&lt;h2 id="section-6"&gt;查看变量&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;print&lt;/code&gt; 或 &lt;code&gt;p&lt;/code&gt; 用于查看变量（表达式），也可以查看寄存器的值（&lt;code&gt;$eax $ebx&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;info&lt;/code&gt; 或 &lt;code&gt;i&lt;/code&gt; 查看函数内部局部变量的数值。&lt;/p&gt;
&lt;h2 id="section-7"&gt;设置变量&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;set&lt;/code&gt; 设置变量的值。&lt;/p&gt;
&lt;h2 id="section-8"&gt;查看内存&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;x&lt;/code&gt; 命令用于查看内存。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;x/20xw &amp;lt;addr&amp;gt; # 显示20个单元，16进制，4字节每单元
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;x/i&lt;/code&gt; 查看指令。&lt;code&gt;$pc&lt;/code&gt; 指向当前程序运行地址&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;x/15i main
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-9"&gt;查看函数调用栈&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;backtrace&lt;/code&gt; 或 &lt;code&gt;bt&lt;/code&gt; 查看函数的调用的栈帧和层级关系。&lt;/p&gt;
&lt;h2 id="section-10"&gt;切换函数栈帧&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;frame&lt;/code&gt; 或 &lt;code&gt;f&lt;/code&gt; 切换函数的栈帧。&lt;/p&gt;
&lt;h2 id="section-11"&gt;追踪变量&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;display&lt;/code&gt; 追踪查看具体变量值。
&lt;code&gt;undisplay&lt;/code&gt; 取消追踪观察变量。&lt;/p&gt;
&lt;h2 id="section-12"&gt;监视变量&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;watch&lt;/code&gt; 被设置观察点的变量（表达式）发生修改时，打印显示。
&lt;code&gt;info watch&lt;/code&gt; 显示观察点&lt;/p&gt;
&lt;h1 id="section-13"&gt;断点&lt;/h1&gt;
&lt;h2 id="section-14"&gt;设置断点&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 设置断点。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;break 10 # at line 10
break *&amp;lt;addr&amp;gt; # at the instruction at addr
break func # at function
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;enable breakpoints&lt;/code&gt; 启用断点。
&lt;code&gt;disable breakpoints&lt;/code&gt; 禁用断点。&lt;/p&gt;
&lt;h2 id="section-15"&gt;查看断点&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;info breakpoints&lt;/code&gt; 查看当前设置的所有断点&lt;/p&gt;
&lt;h2 id="section-16"&gt;删除断点&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;delete breakpoints &amp;lt;num&amp;gt;&lt;/code&gt; 删除第num个断点,简写 &lt;code&gt;d&lt;/code&gt;&lt;/p&gt;
&lt;h1 id="section-17"&gt;参考资料&lt;/h1&gt;
&lt;p&gt;暂无&lt;/p&gt;
</content></entry><entry><id>Tools/tmux</id><title type="text">Tmux</title><summary type="text">基本信息
官网
介绍：用于在一个终端窗口中运行多个终端会话的工具。
安装
apt install tmux
基础知识
快捷键前缀（Prefix）
为了使自身的快捷键和其他软件的快捷键互不干扰，Tmux</summary><published>2018-09-17T19:40:02+08:00</published><updated>2018-09-17T19:40:02+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2Ftmux" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/tmux/tmux"&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍：用于在一个终端窗口中运行多个终端会话的工具。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;安装&lt;/h1&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;apt install tmux
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-2"&gt;基础知识&lt;/h1&gt;
&lt;h2 id="prefix"&gt;快捷键前缀（Prefix）&lt;/h2&gt;
&lt;p&gt;为了使自身的快捷键和其他软件的快捷键互不干扰，Tmux 提供了一个快捷键前缀。当想要使用快捷键时，需要先按下快捷键前缀，然后再按下快捷键。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认前缀：&lt;code&gt;Ctrl+B&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;配置文件&lt;/h2&gt;
&lt;p&gt;Tmux 配置文件位于 &lt;code&gt;~/.tmux.conf&lt;/code&gt;，每当开启一个新的会话时，Tmux 都会先读取这个文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;修改快捷键前缀&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;unbind C-b
set -g prefix C-a
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;使用 vi 操作模式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# Use vim keybindings in copy mode
setw -g mode-keys vi
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-4"&gt;基本操作&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键（需使用 Prefix）&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;新建竖直窗格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;新建水平窗格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;方向键&lt;/td&gt;
&lt;td&gt;在窗格间切换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;创建窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;窗口对应数字&lt;/td&gt;
&lt;td&gt;切换窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-5"&gt;滚屏&lt;/h2&gt;
&lt;p&gt;Prefix + &lt;code&gt;[&lt;/code&gt; 进入滚屏模式，&lt;code&gt;q&lt;/code&gt; 退出。&lt;/p&gt;
&lt;h2 id="section-6"&gt;复制&lt;/h2&gt;
&lt;p&gt;在 Tmux 中可以使用与 Vim 极为相似的方式在文本间移动光标。
使用 Prefix 进入复制模式，把光标移动到想复制的文本上后再按下空格键就可以开始选择文本了。选择完要复制的文本后再按下回车键。就复制到 tmux 剪贴板中了。&lt;/p&gt;
&lt;p&gt;在默认情况下，当从 Tmux 中复制文本时，复制下来的文本只能粘贴到同一个 Tmux 会话中。若要使复制下来的文本可以粘贴到任何位置，就需要让 Tmux 将文本复制到系统的剪贴板。为此，我们需要这样做：
安装 retach-to-user-namespace。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;brew install reattach-to-user-namespace
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新配置文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# invoke reattach-to-user-namespace every time a new window/pane opens
set-option -g default-command &amp;quot;reattach-to-user-namespace -l bash&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-7"&gt;会话&lt;/h1&gt;
&lt;p&gt;一个 Tmux 会话中可以包含多个窗口。可以为一个特定的项目创建一个专用的 Tmux 会话。&lt;/p&gt;
&lt;h2 id="section-8"&gt;创建会话&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;tmux new -s &amp;lt;name-of-my-session&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 tmux 内创建会话：使用 Prefix，进入命令模式，然后输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;new -s &amp;lt;name-of-my-session&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果进入了新的会话，但是原来的会话并没有消失。除非显式地关闭会话，否则 Tmux 的会话在重启计算机之前都不会消失。只要还没有重启计算机，你都可以自由地从一个项目的会话跳转到另一个。&lt;/p&gt;
&lt;h2 id="section-9"&gt;切换会话&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;s&lt;/code&gt; 快捷键查看所有会话及其 ID，按下指定 ID 即可进入对应会话。如果你已经创建了一个或多个会话，但是还没有运行 Tmux，那么可以输入如下命令以接入已开启的会话。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;tmux attach
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-10"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://tangosource.com/blog/a-tmux-crash-course-tips-and-tweaks/"&gt;A Tmux crash course: tips and tweaks.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/progLang-yaml</id><title type="text">YAML Ain't Markup Language</title><summary type="text">基本信息
官网
介绍：YAML 是一种数据序列化语言，旨在对人类友好，并与现代编程语言配合使用，以执行常见的日常任务。
优点
YAML的可读性好。
YAML和脚本语言的交互性好。
YAML使用实现语言</summary><published>2018-11-12T10:20:00+08:00</published><updated>2018-11-12T10:20:00+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2FprogLang-yaml" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://yaml.org/"&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍：YAML 是一种数据序列化语言，旨在对人类友好，并与现代编程语言配合使用，以执行常见的日常任务。&lt;/li&gt;
&lt;li&gt;优点
&lt;ul&gt;
&lt;li&gt;YAML的可读性好。&lt;/li&gt;
&lt;li&gt;YAML和脚本语言的交互性好。&lt;/li&gt;
&lt;li&gt;YAML使用实现语言的数据类型。&lt;/li&gt;
&lt;li&gt;YAML有一个一致的信息模型。&lt;/li&gt;
&lt;li&gt;YAML易于实现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;语法&lt;/h1&gt;
&lt;h2 id="section-2"&gt;基础语法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;大小写敏感&lt;/li&gt;
&lt;li&gt;使用缩进表示层级关系&lt;/li&gt;
&lt;li&gt;缩进时不允许使用 Tab 键，只允许使用空格。&lt;/li&gt;
&lt;li&gt;缩进的空格数目不重要，只要相同层级的元素左侧对齐即可&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 表示注释，从这个字符一直到行尾，都会被解析器忽略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;基础结构&lt;/h2&gt;
&lt;h3 id="section-4"&gt;对象&lt;/h3&gt;
&lt;p&gt;对象，键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）。使用冒号结构表示。也可将所有键值对写成一个行内对象。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;animal: pets

hash: { name: Steve, foo: bar } 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-5"&gt;数组&lt;/h3&gt;
&lt;p&gt;数组，一组按次序排列的值，又称为序列（sequence） / 列表（list）。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;- Cat
- Dog
- Goldfish

animal: [Cat, Dog]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-6"&gt;纯量&lt;/h3&gt;
&lt;p&gt;纯量是最基本的、不可再分的值。支持的类型有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;布尔值：&lt;code&gt;true false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;整数，浮点数：字面量 &lt;code&gt;12.30&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Null：&lt;code&gt;~&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;时间：ISO8601 格式 &lt;code&gt;2001-12-14t21:59:43.10-05:00&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;日期：复合 iso8601 格式的年、月、日表示 &lt;code&gt;1976-07-31&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用两个感叹号，可强制转换类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;e: !!str 123
f: !!str true
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="section-7"&gt;字符串&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;默认不使用引号表示&lt;/li&gt;
&lt;li&gt;如果字符串之中包含空格或特殊字符，需要放在引号之中&lt;/li&gt;
&lt;li&gt;单引号和双引号都可以使用，双引号不会对特殊字符转义&lt;/li&gt;
&lt;li&gt;单引号之中如果还有单引号，必须连续使用两个单引号转义&lt;/li&gt;
&lt;li&gt;字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格&lt;/li&gt;
&lt;li&gt;多行字符串可以使用 &lt;code&gt;|&lt;/code&gt; 保留换行符，也可以使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 折叠换行
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; 表示保留文字块末尾的换行，&lt;code&gt;-&lt;/code&gt; 表示删除字符串末尾的换行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;str: 这是一行字符串
s1: '内容\n字符串'
s2: &amp;quot;内容\n字符串&amp;quot;
str: 'labor''s day'

str: 这是一段
  多行
  字符串

this: |
  Foo
  Bar
that: &amp;gt;
  Foo
  Bar

  
s1: |
  Foo

s2: |+
  Foo


s3: |-
  Foo
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-8"&gt;引用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 建立锚点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 合并到当前数据&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 引用锚点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;defaults: &amp;amp;defaults
  adapter:  postgres
  host:     localhost

development:
  database: myapp_development
  &amp;lt;&amp;lt;: *defaults

test:
  database: myapp_test
  &amp;lt;&amp;lt;: *defaults

# 等价于

defaults:
  adapter:  postgres
  host:     localhost

development:
  database: myapp_development
  adapter:  postgres
  host:     localhost

test:
  database: myapp_test
  adapter:  postgres
  host:     localhost
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-9"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://yaml.org/spec/1.2/spec.html"&gt;YAML Version 1.2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html"&gt;YAML 语言教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/progLang-verilog</id><title type="text">Verilog HDL</title><summary type="text">基本信息
介绍：Verilog HDL是一种硬件描述语言，用于从算法级、门级到开关级的多种抽象设计层次的 数字系统建模。被建模的数字系统对象的复杂性可以介于简单的门和完整的电子数字系统之 间。数字系统</summary><published>2018-09-12T17:50:16+08:00</published><updated>2018-09-12T17:50:16+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2FprogLang-verilog" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;介绍：Verilog HDL是一种硬件描述语言，用于从算法级、门级到开关级的多种抽象设计层次的 数字系统建模。被建模的数字系统对象的复杂性可以介于简单的门和完整的电子数字系统之 间。数字系统能够按层次描述，并可在相同描述中显式地进行时序建模。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;基础知识&lt;/h1&gt;
&lt;h2 id="section-2"&gt;注释&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;// one-line comment
/*
multi-line comment
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-3"&gt;标识符&lt;/h2&gt;
&lt;p&gt;Verilog HDL中的标识符可以是任意一组字母、数字、&lt;code&gt;$&lt;/code&gt; 符号和 &lt;code&gt;_&lt;/code&gt; （下划线）符号的 组合，但标识符的第一个字符必须是字母或者下划线。另外，标识符是区分大小写的。
转义标识符可以在一条标识符中包含任何可打印字符。转义标识符以 &lt;code&gt;\&lt;/code&gt; （反斜线）符号开头，以空白结尾（空白可以是一个空格、一个制表字符或换行符）。反斜线和结束空格并不是转义标识符的一部分。转义标识符与关键词并不完全相同。标识符 \initial 与标识符 initial（这是个关键词）不同。&lt;/p&gt;
&lt;h2 id="section-4"&gt;值&lt;/h2&gt;
&lt;h3 id="section-5"&gt;基本值&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;0 ：逻辑 0&lt;/li&gt;
&lt;li&gt;1 ：逻辑 1&lt;/li&gt;
&lt;li&gt;x ：位置&lt;/li&gt;
&lt;li&gt;z ：高阻&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="section-6"&gt;常量&lt;/h3&gt;
&lt;h4 id="section-7"&gt;整型&lt;/h4&gt;
&lt;h5 id="section-8"&gt;简单十进制表示&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;12,-15&lt;/code&gt;&lt;/p&gt;
&lt;h5 id="section-9"&gt;基数表示法&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;[size] 'base value&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;size 定义以位计的常量的位长&lt;/li&gt;
&lt;li&gt;base ：进制（&lt;code&gt;o/O,b/B,d/D,h/H&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;x（或z）在十六进制值中代表4位x（或z），在八进制中代表3位x（或z），在二进制中代表1位x（或z）。
基数格式计数形式的数通常为无符号数。这种形式的整型数的长度定义是可选的。如果没有定义一个整数型的长度，数的长度为相应值中定义的位数。
如果定义的长度比为常量指定的长度长，通常在左边填0补位。但是如果数最左边一位为 x或z，就相应地用x或z在左边补位。
如果长度定义得更小，那么最左边的位相应地被截断。
？字符在数中可以代替值z在值z被解释为不分大小写的情况下提高可读性。&lt;/p&gt;
&lt;h4 id="section-10"&gt;实数&lt;/h4&gt;
&lt;h5 id="section-11"&gt;十进制计数法&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;2.0
0.1
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id="section-12"&gt;科学计数法&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;23_5.1e2
5E-4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实数通过四舍五入被转换为最相近的整数。&lt;/p&gt;
&lt;h4 id="section-13"&gt;字符串&lt;/h4&gt;
&lt;p&gt;字符串是双引号内的字符序列。字符串不能分成多行书写。&lt;/p&gt;
&lt;p&gt;用8位ASCII值表示的字符可看作是无符号整数。因此字符串是 8位ASCII值的序列。反斜线 (\ ) 用于对确定的特殊字符转义。&lt;/p&gt;
&lt;h4 id="section-14"&gt;参数&lt;/h4&gt;
&lt;p&gt;参数是一个常量。参数经常用于定义时延和变量的宽度。使用参数说明的参数只被赋值一次。参数值也可以在编译时被改变。改变参数值可以使用参数定义语句或通过在模块初始化 语句中定义参数值&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;parameter param1=const_expr1, param2=const_expr2, ... , paramN=const_exprN; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-15"&gt;数据类型&lt;/h2&gt;
&lt;h3 id="section-16"&gt;线网类型&lt;/h3&gt;
&lt;p&gt;表示结构化元件间的物理连线。它的值由驱动元件的值决定， 例如连续赋值或门的输出。如果没有驱动元件连接到线网，线网的缺省值为 z。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;net_kind [msb:lsb] net1,net2,...,netN;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;msb/lsb&lt;/code&gt; 是用于定义线网范围的常量表达式。如果没有定义范围，缺省的长度1位。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;msb&lt;/code&gt; 指定最高有效位对应下标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lsb&lt;/code&gt; 指定最低有效位对应下标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;wire/tri&lt;/code&gt; 用于连接单元的连线是最常见的线网类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;wor/trior&lt;/code&gt; 线或指如果某个驱动源为1，那么线网的值也为1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;wand/triand&lt;/code&gt; 线与网指如果某个驱动源为 0，那么线网的值为0。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;trireg&lt;/code&gt; 此线网存储数值（类似于寄存器），并且用于电容节点的建模。当三态寄存器的所 有驱动源都处于高阻态，也就是说，值为 z时，三态寄存器线网保存作用在线网上的最后一个值。此外，三态寄存器线网的缺省初始值为 x。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;tri0/tri1&lt;/code&gt; 这类线网可用于线逻辑的建模，即线网有多于一个驱动源。 tri0（tri1）线网的特征是，若无驱动源驱动，它的值为0（tri1的值为1）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;supply0/supply1&lt;/code&gt; supply0用于对“地”建模，即低电平0；supply1网用于对电源建模，即高电平1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="section-17"&gt;向量线网&lt;/h4&gt;
&lt;p&gt;在定义向量线网时可选用关键词scalared或vectored。如果一个线网定义时使用了关键词 vectored, 那么就不允许&lt;a href="#%E4%BD%8D%E9%80%89%E6%8B%A9"&gt;位选择&lt;/a&gt;和&lt;a href="#%E9%83%A8%E5%88%86%E9%80%89%E6%8B%A9"&gt;部分选择&lt;/a&gt;该线网。换句话说，必须对线网整体赋值。而如果使用了scalared，则允许位选择和部分选择（这是缺省值）。&lt;/p&gt;
&lt;h3 id="section-18"&gt;寄存器类型&lt;/h3&gt;
&lt;p&gt;表示一个抽象的数据存储单元，它只能在 always 语句和 initial 语句中被赋值，并且它的值从一个赋值到另一个赋值被保存下来。寄存器类型的变量具有 x 的缺省值。&lt;/p&gt;
&lt;h4 id="reg"&gt;reg&lt;/h4&gt;
&lt;p&gt;寄存器数据类型reg是最常见的数据类型。寄存器中的值通常被解释为无符号数。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;reg [msb:lsb] reg1,reg2,...,regN;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;msb/lsb 是用于定义线网范围的常量表达式。如果没有定义范围，缺省的长度1位。
&lt;ul&gt;
&lt;li&gt;msb 指定最高有效位对应下标&lt;/li&gt;
&lt;li&gt;lsb 指定最低有效位对应下标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="section-19"&gt;存储器&lt;/h4&gt;
&lt;p&gt;存储器是一个寄存器数组。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;reg [msb:lsb] memory1[upper1:lower1],
    memory2[upper2:lower2];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组的维数不能大于 2。注意存储器属于寄存器数组类型。线网数据类型没有相应的存储器类型。 存储器赋值不能在一条赋值语句中完成，但是寄存器可以。因此在存储器被赋值时，需要定义一个索引。&lt;/p&gt;
&lt;h4 id="integer"&gt;integer&lt;/h4&gt;
&lt;p&gt;整数寄存器包含整数值。整数寄存器可以作为普通寄存器使用，典型应用为高层次行为建模。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;integer int1,int2,...,intN[msb:lsb];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;msb 和 lsb 是定义整数数组界限的常量表达式，数组界限的定义是可选的。一个整数最少容纳 32 位。但是具体实现可提供更多的位。
一个整数型寄存器可存储有符号数，并且算术操作符提供 2的补码运算结果。
整数不能作为位向量访问。一种截取位值的方法是将整数赋值给一般的 reg 类型变量，然后从中选取相应的位。&lt;/p&gt;
&lt;h4 id="time"&gt;time&lt;/h4&gt;
&lt;p&gt;time类型的寄存器用于存储和处理时间。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;time time1,time2,...,timeN[msb:lsb];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;msb 和 lsb 是表明范围界限的常量表达式。如果未定义界限，每个标识符存储一个至少 64位的时间值。时间类型的寄存器只存储无符号数。&lt;/p&gt;
&lt;h4 id="realrealtime"&gt;real/realtime&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;real real1,real2,...,realN;
realtime real1,real2,...,realN;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;realtime 与 real 类型完全相同。real 说明的变量的缺省值为 0。不允许对 real 声明值域、位界限或字节界限。当将值 x 和 z 赋予 real 类型寄存器时，这些值作 0 处理。&lt;/p&gt;
&lt;h2 id="section-20"&gt;表达式&lt;/h2&gt;
&lt;h3 id="section-21"&gt;操作数&lt;/h3&gt;
&lt;h4 id="section-22"&gt;常数&lt;/h4&gt;
&lt;p&gt;如果表达式中是十进制整数，那么该整数被解释为有符号数。如果整数是基数型整数（定长或非定长），那么该整数作为无符号数对待。更为重要的是对基数表示或非基数表示的负整数处理方式不同。非基数表示形式的负整数作为有符号数处理，而基数表示形式的负整数值作为无符号数（即负号等价于求补）。
参数也可作为操作数。&lt;/p&gt;
&lt;h4 id="section-23"&gt;线网&lt;/h4&gt;
&lt;p&gt;可在表达式中使用标量线网（1位）和向量线网（多位）。线网中的值被解释为无符号数。&lt;/p&gt;
&lt;h4 id="section-24"&gt;寄存器&lt;/h4&gt;
&lt;p&gt;标量和向量寄存器可在表达式中使用。整型寄存器中的值被解释为有符号的二进制补码数，而 reg寄存器或时间寄存器中的值被 解释为无符号数。实数和实数时间类型寄存器中的值被解释为有符号浮点数。&lt;/p&gt;
&lt;h4 id="section-25"&gt;位选择&lt;/h4&gt;
&lt;p&gt;位选择从向量中抽取特定的位。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;net_or_reg_vector[bit_select_expr] 
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="section-26"&gt;部分选择&lt;/h4&gt;
&lt;p&gt;在部分选择中，向量的连续序列被选择。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;net_or_reg_vector[msb_const_expr:lsb_const_expr]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="section-27"&gt;存储器单元存储器单元&lt;/h4&gt;
&lt;p&gt;存储器单元从存储器中选择一个字。不允许对存储器变量值部分选择或位选择。在存储器中读取一个位或部分选择一个字的方法如下：将存储器单元赋值给寄存器变 量，然后对该寄存器变量采用部分选择或位选择操作。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;memory[word_address]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="section-28"&gt;函数调用&lt;/h4&gt;
&lt;p&gt;表达式中可使用函数调用。函数调用可以是系统函数调用（以 $字符开始）或用户定义的函数调用。&lt;/p&gt;
&lt;h3 id="section-29"&gt;操作符&lt;/h3&gt;
&lt;h4 id="section-30"&gt;算术操作符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;+ - * / %&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整数除法截断任何小数部分。&lt;/li&gt;
&lt;li&gt;取模操作符求出与第一个操作符符号相同的余数。&lt;/li&gt;
&lt;li&gt;如果算术操作符中的任意操作数是 X或Z，那么整个结果为X。&lt;/li&gt;
&lt;li&gt;算术表达式结果的长度由最长的操作数决定。在赋值语句下，算术操作结果的长度由操 作符左端目标长度决定。&lt;/li&gt;
&lt;li&gt;在较大的表达式中，所有中间结果应取最大操作数的长度（赋值时，此规则也包括左端目标）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="section-31"&gt;关系操作符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;&amp;gt; &amp;lt; &amp;gt;= &amp;lt;=&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关系操作符的结果为真（ 1）或假（0）。如果操作数中有一位为 X或Z，那么结果为X。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="section-32"&gt;相等关系操作符&lt;/h4&gt;
&lt;p&gt;逻辑等：&lt;code&gt;== !=&lt;/code&gt;
全等：&lt;code&gt;=== !==&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果比较结果为假，则结果为 0；否则结果为1。&lt;/li&gt;
&lt;li&gt;在全等比较中，值 x和z严格按位比较。 也就是说，不进行解释，并且结果一定可知。&lt;/li&gt;
&lt;li&gt;在逻辑比较中，值 x和z具有通常的意义，且 结果可以不为x。也就是说，在逻辑比较中，如果两个操作数之一包含 x或z，结果为未知的值（x）。&lt;/li&gt;
&lt;li&gt;如果操作数的长度不相等，长度较小的操作数在左侧添0补位&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="section-33"&gt;逻辑操作符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&amp;amp; || !&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这些操作符在逻辑值0或1上操作。逻辑操作的结构为0或1。&lt;/li&gt;
&lt;li&gt;对于向量操作, 非0向量作为1处理。&lt;/li&gt;
&lt;li&gt;如果任意一个操作数包含x，结果也为x。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="section-34"&gt;按位操作符&lt;/h4&gt;
&lt;p&gt;一元非：&lt;code&gt;~&lt;/code&gt;
二元：&lt;code&gt;&amp;amp; | ^ ~^ ^~&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这些操作符在输入操作数的对应位上按位操作，并产生向量结果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="section-35"&gt;归约操作符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;&amp;amp; ~&amp;amp; | ~| ^ ~^&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;归约操作符在 &lt;strong&gt;单一操作数&lt;/strong&gt; 的所有位上操作，并产生 1位结果。&lt;/p&gt;
&lt;h4 id="section-36"&gt;移位操作符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;&amp;lt; &amp;gt;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;移位操作符左侧操作数移动右侧操作数表示的次数，它是一个逻辑移位。空闲位添 0 补位。 如果右侧操作数的值为 x 或 z , 移位操作的结果为 x 。&lt;/p&gt;
&lt;h4 id="section-37"&gt;条件操作符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;condition ? expr1 : expr2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;条件操作符根据条件表达式的值选择表达式。&lt;/p&gt;
&lt;h3 id="section-38"&gt;连接&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;{expr1,expr2,...,exprN} &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;连接操作是将小表达式合并形成大表达式的操作。&lt;/p&gt;
&lt;h3 id="section-39"&gt;复制&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;{repetition_number{expr1,expr2,...,exprN}}&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;{3{4'b1011}};    //位向量12'b1011_1011_1011
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;复制通过指定重复次数来执行操作。&lt;/p&gt;
&lt;h3 id="section-40"&gt;分类&lt;/h3&gt;
&lt;p&gt;常量表达式是在编译时就计算出常数值的表达式。通常，常量表达式可由下列要素构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常量文字&lt;/li&gt;
&lt;li&gt;参数名
标量表达式是计算结果为 1位的表达式。如果希望产生标量结果 , 但是表达式产生的结果 为向量, 则最终结果为向量最右侧的位值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-41"&gt;编译指令&lt;/h2&gt;
&lt;p&gt;以 &lt;code&gt;`&lt;/code&gt;（反引号）开始的某些标识符是编译器指令。特定的标识符如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;define, undef&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义宏（文本替换）和取消定义宏，注意使用宏时也需要加上反引号&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;`define WORD 16//建立一个文本宏替代。

wire [`WORD:1] Bus;

`undef WORD
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ifdef, else, endif&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;条件编译&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;`ifdef WINDOWS
parameter WORD_SIZE=16
`else
parameter WORD_SIZE=32
`endif
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default_nettype&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为隐式线网指定线网类型。也就是将那些没有被说明的连线定义线网类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;`default_nettype wire
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;include&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;嵌入内嵌文件的内容。文件既可以用相对路径名定义，也可以用 全路径名定义,&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;`include &amp;quot;../../primitives.v&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;resetall&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将所有的编译指令重新设置为缺省值。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;`resetall
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;timescale&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;将时间单位与实际时间相关联。该指令用于定义时延的单位和时延精度（用于小数单位向整数单位转换）。time_unit 和 time_precision 由值 1、10、和100 以及单位s、ms、us、ns、ps和fs组成。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;//`timescale time_unit / time_precision
`timescale 1ns/100ps
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当一个设计中的多个模块带有自身的 ``timescale` 编译指令时，模拟器总是定位在所有模块的最小时延精度上，并且所有时延都相应地换算为最小时延精度&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unconnected_drive, nounconnected_drive&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在模块实例化中，出现在这两个编译器指令间的任何未连接的输入端口或者为正偏电路 状态或者为反偏电路状态。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;`unconnected_drive pull1
.../*在这两个程序指令间的所有未连接的输入端口为正偏电路状态（连接到高电平）*/
`nounconnected_drive
`unconnected_drive pull0
.../*在这两个程序指令间的所有未连接的输入端口为反偏电路状态（连接到低电平）*/
`nounconnected_drive
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;celldefine, endcelldefine&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个程序指令用于将模块标记为单元模块。它们表示包含模块定义。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;`celldefine
module FD1S3AX(D,CK,Z);
...
endmodule
`endcelldefine 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-42"&gt;模块&lt;/h2&gt;
&lt;p&gt;模块是 Verilog 的基本描述单位，用于描述某个设计的功能或结构及其与其他模块通信的 外部端口。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;module module_name (port_list);
  Declarations:
    reg, wire, parameter,
    input, output, inout,
    function, task, ...
  Statements:
    Initial statement
    Always statement
    Module instantiation
    Gate instantiation
    UDP instantiation
    Continuous assignment
endmodule
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-43"&gt;时延&lt;/h2&gt;
&lt;p&gt;Verilog HDL模型中的所有时延都根据时间单位定义。表示方式为 &lt;code&gt;#&amp;lt;time&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h1 id="section-44"&gt;数据流方式&lt;/h1&gt;
&lt;p&gt;连续赋值用于数据流行为建模。&lt;/p&gt;
&lt;h2 id="section-45"&gt;连续赋值语句&lt;/h2&gt;
&lt;p&gt;连续赋值语句将值赋给线网（连续赋值不能为寄存器赋值）。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;assign LHS_target = RHS_expression;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只要在右端表达式的操作数上有事件（事件为值的变化）发生时，表达式即被计算；如果结果值有变化，新结果就赋给左边的线网。&lt;/p&gt;
&lt;p&gt;连续赋值的目标类型如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;标量线网&lt;/li&gt;
&lt;li&gt;向量线网&lt;/li&gt;
&lt;li&gt;向量的常数型位选择&lt;/li&gt;
&lt;li&gt;向量的常数型部分选择&lt;/li&gt;
&lt;li&gt;上述类型的任意的拼接运算结果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以在一个连续赋值语句中编写多个赋值方式：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;assign Mux = (S == 0) ? A : 'bz,
       Mux = (S == 1) ? B : 'bz,
       Mux = (S == 2) ? C : 'bz,
       Mux = (S == 3) ? D : 'bz;

// equals to

assign Mux = (S == 0) ? A : 'bz;
assign Mux = (S == 1) ? B : 'bz;
assign Mux = (S == 2) ? C : 'bz;
assign Mux = (S == 3) ? D : 'bz;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-46"&gt;线网说明赋值&lt;/h2&gt;
&lt;p&gt;连续赋值可作为线网说明本身的一部分。这样的赋值被称为线网说明赋值。是一种线网声明和连续赋值语句的简化写法。
不允许在同一个线网上出现多个线网说明赋值。如果多个赋值是必需的，则必须使用连续赋值语句。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;wire [3:0] Sum = 4'b0;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-47"&gt;赋值时延&lt;/h2&gt;
&lt;p&gt;{% note info %}
如果在连续赋值语句中没有定义时延，则右端表达式的值立即赋给左端表达式，时延为 0。
{% endnote %}&lt;/p&gt;
&lt;p&gt;定义时延：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;assign #6 Ask = Quiet || Late;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;规定右边表达式结果的计算到其赋给左边目标需经过 6 个时间单位时延。例如，如果在时刻5，Late值发生变化，则赋值的右端表达式被计算，并且 Ask 在时刻11(=5+6) 被赋于新值。&lt;/p&gt;
&lt;p&gt;对于每个时延定义，总共能够指定三类时延值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;上升时延&lt;/li&gt;
&lt;li&gt;下降时延&lt;/li&gt;
&lt;li&gt;关闭时延&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解释：如果右端从非 0 向量变化到 0 向量，那么就使用下降时延。如果右端值到达 z，那么使用下降时延，否则使用上升时延。&lt;/p&gt;
&lt;p&gt;这三类时延的语法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;assign # (rise, fall, turn-off) LHS_target = RHS_expression;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;仅使用一个数字（如 &lt;code&gt;#5&lt;/code&gt;）定义时延时，则上述三类时延均设置为此值。&lt;/p&gt;
&lt;h2 id="section-48"&gt;线网时延&lt;/h2&gt;
&lt;p&gt;时延也可以在线网说明中定义，这个时延表明驱动源值改变与线网本身改变间的时延。和赋值语句时延一起使用时产生叠加效果。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-verilog"&gt;wire #5 Arb;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果时延在线网说明赋值中出现，那么时延不是 线网时延，而是赋值时延。&lt;/p&gt;
&lt;h1 id="section-49"&gt;行为方式&lt;/h1&gt;
&lt;p&gt;(TODO:008)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;initial 语句&lt;/li&gt;
&lt;li&gt;always 语句&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-50"&gt;结构方式&lt;/h1&gt;
&lt;h2 id="section-51"&gt;内置门原语&lt;/h2&gt;
&lt;p&gt;(TODO:005)&lt;/p&gt;
&lt;h2 id="section-52"&gt;开关级原语&lt;/h2&gt;
&lt;p&gt;(TODO:005)&lt;/p&gt;
&lt;h2 id="section-53"&gt;用户定义的原语&lt;/h2&gt;
&lt;p&gt;(TODO:006)&lt;/p&gt;
&lt;h2 id="section-54"&gt;模块实例&lt;/h2&gt;
&lt;p&gt;(TODO:009)&lt;/p&gt;
&lt;h1 id="section-55"&gt;其他&lt;/h1&gt;
&lt;p&gt;(TODO:010)&lt;/p&gt;
&lt;h1 id="section-56"&gt;验证&lt;/h1&gt;
&lt;p&gt;(TODO:011)&lt;/p&gt;
&lt;h1 id="section-57"&gt;参考资料&lt;/h1&gt;
</content></entry><entry><id>Tools/gcc</id><title type="text">GCC - The GNU Compiler Collection</title><summary type="text">基本信息
官网
介绍：GCC，The GNU Compiler Collection，包含多种语言（C, C++, Objective-C, Fortran, Ada, Go) 的前端编译器。携带了相</summary><published>2018-09-19T18:58:19+08:00</published><updated>2018-09-19T18:58:19+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2Fgcc" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://gcc.gnu.org/"&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍：GCC，The GNU Compiler Collection，包含多种语言（C, C++, Objective-C, Fortran, Ada, Go) 的前端编译器。携带了相关的库。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;安装&lt;/h1&gt;
&lt;p&gt;可以通过 &lt;code&gt;build-essential&lt;/code&gt; 包安装。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;apt install build-essential
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="cc"&gt;C/C++&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;C 语言：使用 &lt;code&gt;gcc&lt;/code&gt; 或 &lt;code&gt;g++&lt;/code&gt; 编译。对于 C 语言文件，&lt;code&gt;g++&lt;/code&gt; 内部调用 &lt;code&gt;gcc&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;C++ 语言：使用 &lt;code&gt;g++&lt;/code&gt; 编译 ，由于 C++ 与 C 库文件命名不同，在编译链接过程中 &lt;code&gt;g++&lt;/code&gt; 能找到合适的库文件，而 &lt;code&gt;gcc&lt;/code&gt; 不能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编译分4个阶段：预处理、生成汇编码、编译（生成机器码）、链接&lt;/p&gt;
&lt;p&gt;相关编译指令，参数：
|参数名|描述|
|-|-|
|&lt;code&gt;&amp;lt;source names&amp;gt;&lt;/code&gt;|指定编译源文件|
|&lt;code&gt;-E/e &amp;lt;source names&amp;gt;&lt;/code&gt;|只执行预处理操作（生成 &lt;code&gt;.i&lt;/code&gt; 文件）|
|&lt;code&gt;-S/s &amp;lt;.i file names / source names&amp;gt;&lt;/code&gt;|只执行到生成汇编码（生成 &lt;code&gt;.s&lt;/code&gt; 文件）|
|&lt;code&gt;-c   &amp;lt;.s file names / source names&amp;gt;&lt;/code&gt;|只执行到编译（生成机器码）（生成 &lt;code&gt;.o&lt;/code&gt; 文件）|
|&lt;code&gt;&amp;lt;.o files&amp;gt;&lt;/code&gt;|无选项链接|
|&lt;code&gt;--save-temps&lt;/code&gt;|生成编译过程的中间结果文件|
|&lt;code&gt;-o &amp;lt;output name&amp;gt;&lt;/code&gt;|指定输出文件名|
|&lt;code&gt;-Og -O1 -O2 -O3&lt;/code&gt;|指定优化级别|
|&lt;code&gt;-g&lt;/code&gt;|开启调试开关（编译时生成debug有关的程序信息，供gdb使用）|
|&lt;code&gt;-Wall&lt;/code&gt;|显示编译警告|
|&lt;code&gt;-Wextra&lt;/code&gt;|输出 &lt;code&gt;-Wall&lt;/code&gt; 不包含的警告等|
|&lt;code&gt;-Werror&lt;/code&gt;|将警告视为错误输出|
|&lt;code&gt;-D &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;|加入宏定义，若不指定 &lt;code&gt;value&lt;/code&gt; ，则默认为1|
|&lt;code&gt;-std=&amp;lt;std id&amp;gt;&lt;/code&gt;|指定编译使用的语言标准|
|&lt;code&gt;-fstack-protector\-fno-stack-protector&lt;/code&gt;|是否开启堆栈保护，这里的保护是在返回地址之前加入一个验证值来确保返回地址不被破坏|
|&lt;code&gt;-z execstack&lt;/code&gt;|启用可执行栈，默认是禁用的|&lt;/p&gt;
&lt;p&gt;关于 &lt;code&gt;-std&lt;/code&gt; 中的语言标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C 语言
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;c90/iso9899:1990&lt;/code&gt; C89/C90&lt;/li&gt;
&lt;li&gt;&lt;code&gt;iso9899:199409&lt;/code&gt; C94/C95&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c99/iso9899:1999&lt;/code&gt; C99&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c11/iso9899:2011&lt;/code&gt; C11&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gnu90,gnu99,gnu11&lt;/code&gt; 在标准基础上加入 GNU 扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C++ 语言
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;c++98/c++03&lt;/code&gt; C++98&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c++11&lt;/code&gt; C++11&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c++14&lt;/code&gt; C++14&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c++17/c++1z&lt;/code&gt; C++17&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gnu++98,gnu++11,gnu++14,gnu++1z&lt;/code&gt; 在标准基础上加入 GNU 扩展&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-2"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.csdn.net/bit_clearoff/article/details/53965514"&gt;Linux的gcc和g++的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.cnblogs.com/yhjoker/p/7533438.html"&gt;Linux下编辑、编译、调试命令总结——gcc和gdb描述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://gcc.gnu.org/onlinedocs/gcc/Standards.html"&gt;Language Standards Supported by GCC&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/progLang-php</id><title type="text">PHP Hypertext Preprocessor</title><summary type="text">基本信息
官网
介绍：PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。PHP 脚本在服务器上执行，然后向浏览器发送回纯 HTML 结果。
安装：使用支持 PHP 的 Web 主机，安装 P</summary><published>2018-09-03T10:20:00+08:00</published><updated>2018-09-03T10:20:00+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2FprogLang-php" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://php.net/"&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍：PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。PHP 脚本在服务器上执行，然后向浏览器发送回纯 HTML 结果。&lt;/li&gt;
&lt;li&gt;安装：使用支持 PHP 的 Web 主机，安装 PHP 和 MySQL&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;语法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;PHP 脚本可放置于文档中的任何位置。&lt;/li&gt;
&lt;li&gt;PHP 脚本以 &lt;code&gt;&amp;lt;?php&lt;/code&gt; 开头，以 &lt;code&gt;?&amp;gt;&lt;/code&gt; 结尾：&lt;/li&gt;
&lt;li&gt;PHP 文件的默认文件扩展名是 &amp;quot;.php&amp;quot;。&lt;/li&gt;
&lt;li&gt;PHP 文件通常包含 HTML 标签以及一些 PHP 脚本代码。&lt;/li&gt;
&lt;li&gt;语句以分号结尾（;）&lt;/li&gt;
&lt;li&gt;注释&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;// one-line 

# one-line

/*
multi-line
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;所有用户定义的函数、类和关键词（例如 if、else、echo 等等）都对大小写不敏感。所有变量都对大小写敏感。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-2"&gt;变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;变量规则：
&lt;ul&gt;
&lt;li&gt;变量以 $ 符号开头，其后是变量的名称&lt;/li&gt;
&lt;li&gt;变量名称必须以字母或下划线开头&lt;/li&gt;
&lt;li&gt;变量名称不能以数字开头&lt;/li&gt;
&lt;li&gt;变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _）&lt;/li&gt;
&lt;li&gt;变量名称对大小写敏感（$y 与 $Y 是两个不同的变量）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;变量会在首次为其赋值时被创建&lt;/li&gt;
&lt;li&gt;作用域
&lt;ul&gt;
&lt;li&gt;函数之外声明的变量拥有 global 作用域，只能在函数以外进行访问。&lt;/li&gt;
&lt;li&gt;函数内部声明的变量拥有 local 作用域，只能在函数内部进行访问。&lt;/li&gt;
&lt;li&gt;static 关键词用于声明静态局部变量。&lt;/li&gt;
&lt;li&gt;global 关键词用于访问函数内的全局变量。&lt;/li&gt;
&lt;li&gt;PHP 同时在名为 $GLOBALS[index] 的数组中存储了所有的全局变量。下标存有变量名。这个数组在函数内也可以访问，并能够用于直接更新全局变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;$x=5;
$y=10;

function myTest() {
  global $x,$y;
  $y=$x+$y;
}

myTest();
echo $y; // 输出 15
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-3"&gt;输出&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;echo&lt;/code&gt; 能够输出一个以上的字符串，无返回值。有无括号均可使用：echo 或 echo()。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;print&lt;/code&gt; 只能输出一个字符串，并始终返回 1。有无括号均可使用：print 或 print()。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;字符串中加入对变量，数组某位置的引用：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;$txt1=&amp;quot;Learn PHP&amp;quot;;
$txt2=&amp;quot;W3School.com.cn&amp;quot;;
$cars=array(&amp;quot;Volvo&amp;quot;,&amp;quot;BMW&amp;quot;,&amp;quot;SAAB&amp;quot;);

echo $txt1;
echo &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
echo &amp;quot;Study PHP at $txt2&amp;quot;;
echo &amp;quot;My car is a {$cars[0]}&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-4"&gt;数据类型&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;字符串：字符串可以是引号内的任何文本。可以使用单引号或双引号&lt;/li&gt;
&lt;li&gt;整数
&lt;ul&gt;
&lt;li&gt;整数必须有至少一个数字（0-9）&lt;/li&gt;
&lt;li&gt;整数不能包含逗号或空格&lt;/li&gt;
&lt;li&gt;整数不能有小数点&lt;/li&gt;
&lt;li&gt;整数正负均可&lt;/li&gt;
&lt;li&gt;可以用三种格式规定整数：十进制、十六进制（前缀是 0x）或八进制（前缀是 0）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;浮点数：浮点数是有小数点或指数形式的数字。&lt;code&gt;10.3 2.4e3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;逻辑值（布尔值）：&lt;code&gt;true false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数组：&lt;code&gt;array(&amp;quot;Volvo&amp;quot;,&amp;quot;BMW&amp;quot;,&amp;quot;SAAB&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对象：对象是存储数据和有关如何处理数据的信息的数据类型。首先必须声明对象的类。&lt;/li&gt;
&lt;li&gt;NULL：特殊的 NULL 值表示变量无值。NULL 是数据类型 NULL 唯一可能的值。
&lt;ul&gt;
&lt;li&gt;NULL 值标示变量是否为空。也用于区分空字符串与空值数据库。&lt;/li&gt;
&lt;li&gt;可以通过把值设置为 NULL，将变量清空：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% note info %}
使用 var_dump 函数查看变量类型和变量名。
{% endnote %}&lt;/p&gt;
&lt;h2 id="section-5"&gt;常量&lt;/h2&gt;
&lt;p&gt;常量是单个值的标识符（名称）。在脚本中无法改变该值。有效的常量名以字符或下划线开头（常量名称前面没有 $ 符号）。与变量不同，常量贯穿整个脚本是自动全局的。
如需设置常量，请使用 define() 函数 - 它使用三个参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首个参数定义常量的名称&lt;/li&gt;
&lt;li&gt;第二个参数定义常量的值&lt;/li&gt;
&lt;li&gt;可选的第三个参数规定常量名是否对大小写不敏感。默认是 false。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;define(&amp;quot;GREETING&amp;quot;, &amp;quot;Welcome to W3School.com.cn!&amp;quot;,true);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-6"&gt;数组&lt;/h2&gt;
&lt;p&gt;array() 函数用于创建数组。count()返回数组的长度（元素数）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;索引数组 - 带有数字索引的数组&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;$cars=array(&amp;quot;Volvo&amp;quot;,&amp;quot;BMW&amp;quot;,&amp;quot;SAAB&amp;quot;);

$cars=array();
$cars[0]=&amp;quot;Volvo&amp;quot;;
$cars[1]=&amp;quot;BMW&amp;quot;;
$cars[2]=&amp;quot;SAAB&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;$arrlength=count($cars);
for($x=0;$x&amp;lt;$arrlength;$x++) {
  echo $cars[$x];
  echo &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;关联数组 - 带有指定键的数组&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;$age=array(&amp;quot;Peter&amp;quot;=&amp;gt;&amp;quot;35&amp;quot;,&amp;quot;Ben&amp;quot;=&amp;gt;&amp;quot;37&amp;quot;,&amp;quot;Joe&amp;quot;=&amp;gt;&amp;quot;43&amp;quot;);

$age=array();
$age['Peter']=&amp;quot;35&amp;quot;;
$age['Ben']=&amp;quot;37&amp;quot;;
$age['Joe']=&amp;quot;43&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;foreach($age as $x=&amp;gt;$x_value) {
  echo &amp;quot;Key=&amp;quot; . $x . &amp;quot;, Value=&amp;quot; . $x_value;
  echo &amp;quot;&amp;lt;br&amp;gt;&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;多维数组 - 包含一个或多个数组的数组&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;$cars = array
(
    array(&amp;quot;Volvo&amp;quot;,22,18),
    array(&amp;quot;BMW&amp;quot;,15,13),
    array(&amp;quot;Saab&amp;quot;,5,2),
    array(&amp;quot;Land Rover&amp;quot;,17,15)
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-7"&gt;超全局变量&lt;/h2&gt;
&lt;p&gt;超全局变量是在全部作用域中始终可用的内置变量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$GLOBALS&lt;/code&gt; 用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）
&lt;ul&gt;
&lt;li&gt;名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$_SERVER&lt;/code&gt; 保存关于报头、路径和脚本位置的信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$_REQUEST&lt;/code&gt; 用于收集 HTML 表单提交的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$_POST&lt;/code&gt; 广泛用于收集提交 method=&amp;quot;post&amp;quot; 的 HTML 表单后的表单数据。&lt;code&gt;$_POST&lt;/code&gt; 也常用于传递变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$_GET&lt;/code&gt; 可用于收集提交 HTML 表单 (method=&amp;quot;get&amp;quot;) 之后的表单数据。也可以收集 URL 中的发送的数据。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$_FILES&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$_ENV&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$_COOKIE&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$_SESSION&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-8"&gt;表达式&lt;/h1&gt;
&lt;h2 id="section-9"&gt;运算符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+ - * / % ++ --&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;== != &amp;lt;&amp;gt; &amp;gt; &amp;lt; &amp;gt;= &amp;lt;=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=== !==&lt;/code&gt; 全等：相等且类型相同：&lt;code&gt;100==&amp;quot;100&amp;quot;&lt;/code&gt; 但 &lt;code&gt;100!==&amp;quot;100&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;and or xor &amp;amp;&amp;amp; || !&lt;/code&gt; 逻辑运算符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;= += -= *= /= %=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;串运算符
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 串连接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.=&lt;/code&gt; 串连接赋值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数组运算符
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; 联合（但不覆盖重复的键）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;== != &amp;lt;&amp;gt;&lt;/code&gt; 拥有相同的键/值对&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=== !==&lt;/code&gt; 拥有相同的键/值对，且顺序相同类型相同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-10"&gt;语句&lt;/h1&gt;
&lt;h2 id="section-11"&gt;选择语句&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;if (condition) {} 
elseif (condition) {} 
else {}

switch (expression)
{
case label1:
  break;  
case label2:
  break;
default:
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-12"&gt;迭代语句&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;while (condition) {}
do {} while (condition);
for (init;condition;step) {}
foreach ($array as $value) {}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-13"&gt;函数&lt;/h1&gt;
&lt;h2 id="section-14"&gt;自定义函数&lt;/h2&gt;
&lt;p&gt;函数名能够以字母或下划线开头，且对大小写不敏感。可以通过参数向函数传递信息。参数类似变量。参数被定义在函数名之后，括号内部。您可以添加任意多参数，只要用逗号隔开即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-php"&gt;function functionName($arg1=&amp;quot;default&amp;quot;,$arg2) {
    return arg1 . arg2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-15"&gt;内置函数&lt;/h2&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h1 id="section-16"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.w3school.com.cn/php/index.asp"&gt;PHP 教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/progLang-dockerfile</id><title type="text">Dockerfile</title><summary type="text">基本信息
Dockerfile 为 Docker 提供镜像构建命令及描述。
Docker 书写思想：
自动化，无交互
顺序相关
清理
易读
基础语法
// 注释
INSTRUCTION argumen</summary><published>2018-11-12T19:37:36+08:00</published><updated>2018-11-12T19:37:36+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2FprogLang-dockerfile" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Dockerfile 为 Docker 提供镜像构建命令及描述。&lt;/li&gt;
&lt;li&gt;Docker 书写思想：
&lt;ul&gt;
&lt;li&gt;自动化，无交互&lt;/li&gt;
&lt;li&gt;顺序相关&lt;/li&gt;
&lt;li&gt;清理&lt;/li&gt;
&lt;li&gt;易读&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;基础语法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;//&lt;/code&gt; 注释&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INSTRUCTION arguments&lt;/code&gt; 指令格式，一般指令名大写&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-2"&gt;指令&lt;/h1&gt;
&lt;h2 id="from"&gt;FROM&lt;/h2&gt;
&lt;p&gt;指定基础镜像，必须是第一句有效指令。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM &amp;lt;imagesName:tag&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多个 &lt;code&gt;FROM&lt;/code&gt; 指令使用最后一个。&lt;/p&gt;
&lt;h2 id="maintainer"&gt;MAINTAINER&lt;/h2&gt;
&lt;p&gt;设置维护者信息。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;MAINTAINER Name &amp;lt;Email&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="run"&gt;RUN&lt;/h3&gt;
&lt;p&gt;运行指定命令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shell 格式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;RUN echo HelloWorld
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;exec 格式（不启动 shell）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;RUN [&amp;quot;prog&amp;quot;, &amp;quot;arg1&amp;quot;, &amp;quot;arg2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="env"&gt;ENV&lt;/h3&gt;
&lt;p&gt;设置镜像的环境变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="copy"&gt;COPY&lt;/h3&gt;
&lt;p&gt;将本地文件或文件夹复制到镜像指定路径下。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;COPY /local/path/file /images/path/file
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="add"&gt;ADD&lt;/h3&gt;
&lt;p&gt;可从本地或网上获取，存储到镜像指定路径下，也可对文件自动解包。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;ADD file /images/path/file
ADD latest.tar.gz /var/www/
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;相同复制命令下，ADD 构建的镜像比 COPY 构建的镜像大&lt;/li&gt;
&lt;li&gt;不能对构建目录或上下文之外的文件进行 ADD 操作：不能使用 &lt;code&gt;../path&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;会自动创建目的位置&lt;/li&gt;
&lt;li&gt;会使得构建缓存无效&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="expose"&gt;EXPOSE&lt;/h3&gt;
&lt;p&gt;指定暴露端口。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;EXPOSE &amp;lt;port&amp;gt; [&amp;lt;port&amp;gt;...]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="cmd"&gt;CMD&lt;/h3&gt;
&lt;p&gt;设置镜像启动命令。只有最后一个 CMD 指令有效。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;CMD [&amp;quot;echo&amp;quot;, &amp;quot;Hello World&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="entrypoint"&gt;ENTRYPOINT&lt;/h3&gt;
&lt;p&gt;设置入口点。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;ENTRYPOINT [&amp;quot;echo&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="volume"&gt;VOLUME&lt;/h3&gt;
&lt;p&gt;设置数据卷。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;VOLUME [&amp;quot;/data&amp;quot;, &amp;quot;/data2&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="user"&gt;USER&lt;/h3&gt;
&lt;p&gt;设置构建用户。指定的用户需要在 USER 指令前创建。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;USER user
USER user:group
USER uid:gid
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="workdir"&gt;WORKDIR&lt;/h3&gt;
&lt;p&gt;设置 RUN,CMD,ENTRYPOINT 工作目录。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;WORKDIR /path/workdir
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="onbuild"&gt;ONBUILD&lt;/h3&gt;
&lt;p&gt;用于子镜像的二次构建中执行的 Dockerfile 指令。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;ONBUILD RUN echo &amp;quot;Hello World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="label"&gt;LABEL&lt;/h3&gt;
&lt;p&gt;添加元数据到镜像。尽量使用一个 LABEL 标签，减少构建 layer 数量。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;LABEL multi.label1=&amp;quot;value1&amp;quot; multi.label2=&amp;quot;value2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="arg"&gt;ARG&lt;/h3&gt;
&lt;p&gt;设置构建变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;ARG &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="stopsignal"&gt;STOPSIGNAL&lt;/h3&gt;
&lt;p&gt;指定运行 &lt;code&gt;docker stop&lt;/code&gt; 时，向容器发送的信号。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;STOPSIGNAL SIGKILL
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="healthcheck"&gt;HEALTHCHECK&lt;/h3&gt;
&lt;p&gt;检查容器状态。&lt;/p&gt;
&lt;p&gt;参数有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--interval&lt;/code&gt; 容器启动多长时间后开始检查&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--timeout&lt;/code&gt; 设置超时时间，若超时，则认为容器异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--retried&lt;/code&gt; 设置重试次数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;HEALTHCHECK [OPTIONS] CMD command
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="shell"&gt;SHELL&lt;/h3&gt;
&lt;p&gt;指示更换 shell 环境。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;SHELL [&amp;quot;powershell&amp;quot;, &amp;quot;-command&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-3"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;《Docker 从入门到实战》 黄靖钧 机械工业出版社&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/progLang-css</id><title type="text">Cascading Style Sheets</title><summary type="text">基本信息
介绍：CSS 存储 HTML 样式，定义如何显示 HTML 元素。
在 HTML 中使用样式表，参见 {% post_link tool/progLang-HTML %}
层叠
样式表允许以</summary><published>2018-09-08T10:30:40+08:00</published><updated>2018-09-08T10:30:40+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2FprogLang-css" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;介绍：CSS 存储 HTML 样式，定义如何显示 HTML 元素。&lt;/li&gt;
&lt;li&gt;在 HTML 中使用样式表，参见 {% post_link tool/progLang-HTML %}&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;层叠&lt;/h1&gt;
&lt;p&gt;样式表允许以多种方式规定样式信息。样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。
当同一个 HTML 元素被不止一个样式定义时，层叠顺序如下，其中数字 4 拥有最高的优先权。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器缺省设置&lt;/li&gt;
&lt;li&gt;外部样式表&lt;/li&gt;
&lt;li&gt;内部样式表（位于 &lt;head&gt; 标签内部）&lt;/li&gt;
&lt;li&gt;内联样式（在 HTML 元素内部）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明：&lt;head&gt; 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。&lt;/p&gt;
&lt;p&gt;通过 CSS 继承，子元素将继承最高级元素所拥有的属性&lt;/p&gt;
&lt;h1 id="section-2"&gt;语法&lt;/h1&gt;
&lt;p&gt;CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;selector {declaration1; declaration2; ... declarationN }
selector {property: value}

h1 {color:red; font-size:14px;}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;选择器：指定需要改变样式的 HTML 元素。&lt;/li&gt;
&lt;li&gt;每条声明由一个属性和一个值组成。
&lt;ul&gt;
&lt;li&gt;如果要定义不止一个声明，则需要用分号将每个声明分开。&lt;/li&gt;
&lt;li&gt;属性（property）是设置的样式属性（style attribute）。每个属性有一个值。&lt;/li&gt;
&lt;li&gt;属性和值被冒号分开。&lt;/li&gt;
&lt;li&gt;如果值为若干单词，则要给值加引号。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% note info %}
CSS 对大小写不敏感。不过存在一个例外：如果涉及到与 HTML 文档一起工作的话，class 和 id 名称对大小写是敏感的。
{% endnote %}&lt;/p&gt;
&lt;h1 id="section-3"&gt;选择器&lt;/h1&gt;
&lt;h2 id="section-4"&gt;分组&lt;/h2&gt;
&lt;p&gt;允许对不同种类选择器定义相同的样式规则。
使用逗号分隔多个选择器以实现选择器的分组（并列关系）：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;h1,h2,h3,h4,h5,h6 {
    color: green;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-5"&gt;元素选择器&lt;/h2&gt;
&lt;p&gt;文档的元素就是最基本的选择器。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;html {color:black;}
h1 {color:blue;}
h2 {color:silver;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通配选择器&lt;/strong&gt;匹配所有元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;* {color:red;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-6"&gt;基于上下文关系&lt;/h2&gt;
&lt;h3 id="section-7"&gt;后代选择器&lt;/h3&gt;
&lt;p&gt;后代选择器允许你根据文档的上下文关系来确定某个标签的样式。&lt;/p&gt;
&lt;p&gt;使用空格分隔选择器以实现后代选择器（后代关系）：
希望列表中的 strong 元素变为斜体字，而不是通常的粗体字：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;li strong {
    font-style: italic;
    font-weight: normal;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-8"&gt;子元素选择器&lt;/h3&gt;
&lt;p&gt;与后代选择器相比，子元素选择器只能选择作为某元素子元素的元素。
使用 &lt;code&gt;&amp;gt;&lt;/code&gt; 分隔选择器以实现子元素选择器（父子关系）：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;h1 &amp;gt; strong {color:red;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-9"&gt;相邻兄弟选择器&lt;/h3&gt;
&lt;p&gt;相邻兄弟选择器可选择紧接在另一元素后的元素，且二者有相同父元素。
使用 &lt;code&gt;+&lt;/code&gt; 分隔选择器以实现相邻兄弟选择器（相邻兄弟关系）：
选择紧接在 h1 元素后出现的 p 元素，h1 和 p 元素拥有共同的父元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;h1 + p {margin-top:50px;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-10"&gt;基于属性&lt;/h2&gt;
&lt;h3 id="id"&gt;id 选择器&lt;/h3&gt;
&lt;p&gt;id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。
以 &lt;code&gt;#&lt;/code&gt; 来定义 id 选择器。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;#red {color:red;}
#green {color:green;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过加入元素类型前缀，可指定元素类型（但由于 id 唯一性，此做法意义不大）：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;div#red {color:red;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-11"&gt;类选择器&lt;/h3&gt;
&lt;p&gt;类选择器可以为标有特定 class 的 HTML 元素指定特定的样式。
以 &lt;code&gt;.&lt;/code&gt; 来定义 id 选择器。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;.center {text-align: center}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 HTML 中，一个 class 值中可能包含一个词列表，各个词之间用空格分隔。可以使用多类选择器匹配这种情况。
通过把两个类选择器链接在一起，仅可以选择同时包含这些类名的元素（类名的顺序不限）。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;.important.urgent {background:silver;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;p class=&amp;quot;important urgent&amp;quot;&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过加入元素类型前缀，可指定元素类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;td.fancy {
	color: #f60;
	background: #666;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;td class=&amp;quot;fancy&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-12"&gt;属性选择器&lt;/h3&gt;
&lt;p&gt;可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。&lt;/p&gt;
&lt;h4 id="section-13"&gt;简单属性选择&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;为带有 title 属性的所有元素设置样式：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;[title]
{
    color:red;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;根据多个属性进行选择，只需将属性选择器链接在一起即可。将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;a[href][title] {color:red;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="section-14"&gt;根据具体属性值&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;为 title=&amp;quot;W3School&amp;quot; 的所有元素设置样式：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;[title=W3School]
{
    border:5px solid blue;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;为包含指定值的 title 属性的所有元素设置样式。适用于由空格分隔的属性值：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;[title~=hello] { color:red; }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;为带有包含指定值的 lang 属性的所有元素设置样式（选择 lang 属性等于 en 或以 en- 开头的所有元素）。适用于由连字符分隔的属性值：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;[lang|=en] { color:red; }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;选择 abc 属性值以 &amp;quot;def&amp;quot; 开头的所有元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;[abc^=&amp;quot;def&amp;quot;]{}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;选择 abc 属性值以 &amp;quot;def&amp;quot; 结尾的所有元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;[abc$=&amp;quot;def&amp;quot;]{}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;选择 abc 属性值中包含子串 &amp;quot;def&amp;quot; 的所有元素&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;[abc*=&amp;quot;def&amp;quot;]{}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过加入元素类型前缀，可指定元素类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;input[type=&amp;quot;text&amp;quot;]
{
    width:150px;
    display:block;
    margin-bottom:10px;
    background-color:yellow;
    font-family: Verdana, Arial;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-15"&gt;伪类&lt;/h2&gt;
&lt;p&gt;CSS 伪类用于向某些选择器添加特殊的效果。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;selector : pseudo-class {property: value}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;{% note info %}
伪类名称对大小写不敏感。
{% endnote %}&lt;/p&gt;
&lt;h3 id="section-16"&gt;锚伪类&lt;/h3&gt;
&lt;p&gt;通过伪类表示元素状态：链接的不同状态都可以不同的方式显示，这些状态包括：活动状态，已被访问状态，未被访问状态，和鼠标悬停状态。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;a:link {color: #FF0000}		/* 未访问的链接 */
a:visited {color: #00FF00}	/* 已访问的链接 */
a:hover {color: #FF00FF}	/* 鼠标移动到链接上 */
a:active {color: #0000FF}	/* 选定的链接 */
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;{% note warning %}
在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。
在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。
{% endnote %}&lt;/p&gt;
&lt;h3 id="first-child"&gt;:first-child&lt;/h3&gt;
&lt;p&gt;使用 :first-child 伪类来选择作为其父元素的第一个子元素的元素：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;p:first-child {font-weight: bold;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匹配：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;div&amp;gt;
    &amp;lt;p&amp;gt;These are the necessary steps:&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="lang"&gt;:lang&lt;/h3&gt;
&lt;p&gt;:lang 伪类使你有能力为不同的语言定义特殊的规则。&lt;/p&gt;
&lt;p&gt;:lang 类为属性值为 no 的 q 元素定义引号的类型：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;q:lang(no){
    quotes: &amp;quot;~&amp;quot; &amp;quot;~&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-17"&gt;伪元素&lt;/h2&gt;
&lt;p&gt;CSS 伪元素用于向某些选择器设置特殊效果。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;selector:pseudo-element {property:value;}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="first-line"&gt;:first-line&lt;/h3&gt;
&lt;p&gt;&amp;quot;first-line&amp;quot; 伪元素用于向文本的首行设置特殊样式（只能用于块级元素）。&lt;/p&gt;
&lt;h3 id="first-letter"&gt;:first-letter&lt;/h3&gt;
&lt;p&gt;&amp;quot;first-letter&amp;quot; 伪元素用于向文本的首字母设置特殊样式（只能用于块级元素）：&lt;/p&gt;
&lt;h3 id="before"&gt;:before&lt;/h3&gt;
&lt;p&gt;&amp;quot;:before&amp;quot; 伪元素可以在元素的内容前面插入新内容。&lt;/p&gt;
&lt;h3 id="after"&gt;:after&lt;/h3&gt;
&lt;p&gt;&amp;quot;:after&amp;quot; 伪元素可以在元素的内容之后插入新内容。&lt;/p&gt;
&lt;h1 id="section-18"&gt;属性&lt;/h1&gt;
&lt;h2 id="section-19"&gt;背景&lt;/h2&gt;
&lt;p&gt;所有背景属性都不能继承。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;background-color&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;背景色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;background-image&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;背景图像&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;background-repeat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;背景重复&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;background-position&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;背景定位&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;background-attachment&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;背景与可视区的关联（固定或滚动）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;background-size&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;背景图片的尺寸&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;background-origin&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;背景图片的定位区域&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;background-clip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;背景的绘制区域&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-20"&gt;文本&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;color&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文本颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;direction&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文本方向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;line-height&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;letter-spacing&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字符间距&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;text-align&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对齐元素中的文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;text-decoration&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向文本添加修饰&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;text-indent&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;缩进元素中文本的首行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;text-transform&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;控制元素中的字母&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;unicode-bidi&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文本方向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;white-space&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素中空白的处理方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;word-spacing&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字间距&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;hanging-punctuation&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定标点字符是否位于线框之外&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;punctuation-trim&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定是否对标点字符进行修剪&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;text-align-last&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置如何对齐最后一行或紧挨着强制换行符之前的行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;text-emphasis&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向元素的文本应用重点标记以及重点标记的前景色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;text-justify&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定当 text-align 设置为 &amp;quot;justify&amp;quot; 时所使用的对齐方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;text-outline&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定文本的轮廓&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;text-overflow&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定当文本溢出包含元素时发生的事情&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;text-shadow&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向文本添加阴影&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;text-wrap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定文本的换行规则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;word-break&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定非中日韩文本的换行规则&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;word-wrap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;允许对长的不可分割的单词进行分割并换行到下一行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-21"&gt;字体&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;font&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;简写属性。作用是把所有针对字体的属性设置在一个声明中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;font-family&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字体系列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;font-size&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字体的尺寸&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;font-style&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字体风格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;font-variant&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;以小型大写字体或者正常字体显示文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;font-weight&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字体的粗细&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;@font-face 规则：使用自己的字体：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;&amp;lt;style&amp;gt; 
@font-face{
    font-family: myFirstFont;
    src: url('Sansation_Light.ttf');
    font-weight:bold;
}

div{
    font-family:myFirstFont;
}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-22"&gt;列表&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;list-style&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;简写属性。用于把所有用于列表的属性设置于一个声明中。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;list-style-image&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将图象设置为列表项标志。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;list-style-position&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列表中列表项标志的位置。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;list-style-type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列表项标志的类型。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-23"&gt;表格&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;border-collapse&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否把表格边框合并为单一的边框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;border-spacing&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;分隔单元格边框的距离&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;caption-side&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表格标题的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;empty-cells&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;是否显示表格中的空单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;table-layout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示单元、行和列的算法&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-24"&gt;轮廓&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;outline&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在一个声明中设置所有的轮廓属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;outline-color&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;轮廓的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;outline-style&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;轮廓的样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;outline-width&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;轮廓的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-25"&gt;多列&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;column-count&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定元素应该被分隔的列数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;column-fill&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定如何填充列&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;column-gap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定列之间的间隔&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;column-rule&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置所有 column-rule-* 属性的简写属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;column-rule-color&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定列之间规则的颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;column-rule-style&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定列之间规则的样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;column-rule-width&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定列之间规则的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;column-span&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定元素应该横跨的列数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;column-width&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定列的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;columns&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定设置 column-width 和 column-count 的简写属性&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-26"&gt;定位&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;position&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把元素放置到一个静态的、相对的、绝对的、或固定的位置中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;top&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;right&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义了定位元素右外边距边界与其包含块右边界之间的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;bottom&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义了定位元素下外边距边界与其包含块下边界之间的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;left&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义了定位元素左外边距边界与其包含块左边界之间的偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;overflow&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置当元素的内容溢出其区域时发生的事情&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;clip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置元素的形状。元素被剪入这个形状之中，然后显示出来&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vertical-align&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置元素的垂直对齐方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;z-index&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置元素的堆叠顺序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;display&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;改变生成的框的类型（&lt;code&gt;block,inline,none&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用 &lt;code&gt;float&lt;/code&gt; 属性实现元素&lt;strong&gt;浮动&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="section-27"&gt;尺寸&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;height&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素的高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;line-height&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;max-height&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素的最大高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;max-width&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素的最大宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;min-height&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素的最小高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;min-width&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素的最小宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;width&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-28"&gt;分类&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置一个元素的侧面是否允许其他的浮动元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cursor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定当指向某元素之上时显示的指针类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;display&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置是否及如何显示元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义元素在哪个方向浮动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;position&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把元素放置到一个静态的、相对的、绝对的、或固定的位置中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;visibility&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置元素是否可见或不可见&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-29"&gt;框模型&lt;/h2&gt;
&lt;p&gt;边距属性赋值顺序：上、右、下、左
边距属性均具有对应的 &lt;code&gt;-bottom,-left,-right,-top&lt;/code&gt; 属性设置某个方向上的值。
边框属性除了 &lt;code&gt;border-bottom&lt;/code&gt; 等属性外，还有 &lt;code&gt;border-bottom-style&lt;/code&gt; 等属性。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;padding&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内边距&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;margin&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;外边距&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;border&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;边框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;border-style&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;边框样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;border-width&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;边框宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;border-color&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;边框颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;border-image&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用图片来绘制边框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;border-radius&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;圆角边框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;box-shadow&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向方框添加一个或多个阴影&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;值复制特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果缺少左外边距的值，则使用右外边距的值。&lt;/li&gt;
&lt;li&gt;如果缺少下外边距的值，则使用上外边距的值。&lt;/li&gt;
&lt;li&gt;如果缺少右外边距的值，则使用上外边距的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="http://www.w3school.com.cn/i/ct_css_margin_value.gif" alt="" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;外边框合并特性&lt;/strong&gt;：
外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。&lt;/p&gt;
&lt;h2 id="section-30"&gt;转换&lt;/h2&gt;
&lt;h3 id="d"&gt;2D&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向元素应用 2D 或 3D 转换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transform-origin&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;允许你改变被转换元素的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;2D Transform 方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix(n,n,n,n,n,n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 2D 转换，使用六个值的矩阵&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;translate(x,y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 2D 转换，沿着 X 和 Y 轴移动元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;translateX(n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 2D 转换，沿着 X 轴移动元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;translateY(n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 2D 转换，沿着 Y 轴移动元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;scale(x,y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 2D 缩放转换，改变元素的宽度和高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;scaleX(n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 2D 缩放转换，改变元素的宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;scaleY(n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 2D 缩放转换，改变元素的高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;rotate(angle)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 2D 旋转，在参数中规定角度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;skew(x-angle,y-angle)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 2D 倾斜转换，沿着 X 和 Y 轴&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;skewX(angle)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 2D 倾斜转换，沿着 X 轴&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;skewY(angle)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 2D 倾斜转换，沿着 Y 轴&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="d-1"&gt;3D&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transform&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向元素应用 2D 或 3D 转换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transform-origin&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;允许你改变被转换元素的位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transform-style&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定被嵌套元素如何在 3D 空间中显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;perspective&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定 3D 元素的透视效果&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;perspective-origin&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定 3D 元素的底部位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;backface-visibility&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义元素在不面对屏幕时是否可见&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;3D Transform 方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 3D 转换，使用 16 个值的 4x4 矩阵&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;translate3d(x,y,z)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 3D 转化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;translateX(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 3D 转化，仅使用用于 X 轴的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;translateY(y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 3D 转化，仅使用用于 Y 轴的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;translateZ(z)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 3D 转化，仅使用用于 Z 轴的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;scale3d(x,y,z)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 3D 缩放转换&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;scaleX(x)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 3D 缩放转换，通过给定一个 X 轴的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;scaleY(y)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 3D 缩放转换，通过给定一个 Y 轴的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;scaleZ(z)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 3D 缩放转换，通过给定一个 Z 轴的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;rotate3d(x,y,z,angle)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 3D 旋转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;rotateX(angle)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义沿 X 轴的 3D 旋转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;rotateY(angle)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义沿 Y 轴的 3D 旋转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;rotateZ(angle)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义沿 Z 轴的 3D 旋转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;perspective(n)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义 3D 转换元素的透视视图&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-31"&gt;过渡&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transition&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;简写属性，用于在一个属性中设置四个过渡属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transition-property&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定应用过渡的 CSS 属性的名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transition-duration&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义过渡效果花费的时间。默认是 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transition-timing-function&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定过渡效果的时间曲线。默认是 &amp;quot;ease&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;transition-delay&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定过渡效果何时开始。默认是 0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-32"&gt;动画&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;@keyframes&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定动画&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;animation&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;所有动画属性的简写属性，除了 animation-play-state 属性&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;animation-name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定 @keyframes 动画的名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;animation-duration&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定动画完成一个周期所花费的秒或毫秒。默认是 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;animation-timing-function&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定动画的速度曲线。默认是 &amp;quot;ease&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;animation-delay&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定动画何时开始。默认是 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;animation-iteration-count&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定动画被播放的次数。默认是 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;animation-direction&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定动画是否在下一周期逆向地播放。默认是 &amp;quot;normal&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;animation-play-state&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定动画是否正在运行或暂停。默认是 &amp;quot;running&amp;quot;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;animation-fill-mode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定对象动画时间之外的状态&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;@keyframes myfirst{
    from {background: red;}
    to {background: yellow;}
}
div{
    animation: myfirst 5s;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-css"&gt;div{
    animation-name: myfirst;
    animation-duration: 5s;
    animation-timing-function: linear;
    animation-delay: 2s;
    animation-iteration-count: infinite;
    animation-direction: alternate;
    animation-play-state: running;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-33"&gt;用户界面&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;appearance&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;允许您将元素设置为标准用户界面元素的外观&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;box-sizing&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;允许您以确切的方式定义适应某个区域的具体内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;icon&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;为创作者提供使用图标化等价物来设置元素样式的能力&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;nav-down&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定在使用 arrow-down 导航键时向何处导航&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;nav-index&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置元素的 tab 键控制次序&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;nav-left&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定在使用 arrow-left 导航键时向何处导航&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;nav-right&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定在使用 arrow-right 导航键时向何处导航&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;nav-up&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定在使用 arrow-up 导航键时向何处导航&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;outline-offset&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;resize&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;规定是否可由用户对元素的尺寸进行调整&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id="section-34"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.w3school.com.cn/css/index.asp"&gt;CSS 教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.w3school.com.cn/css3/index.asp"&gt;CSS3 教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/progLang-sql</id><title type="text">Structured Query Language</title><summary type="text">基本信息
介绍：结构化查询语言，用于存取数据以及查询、更新和管理关系数据库系统。存在着很多不同版本的 SQL 语言，但是为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的关键词。</summary><published>2018-09-03T18:51:10+08:00</published><updated>2018-09-03T18:51:10+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2FprogLang-sql" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;介绍：结构化查询语言，用于存取数据以及查询、更新和管理关系数据库系统。存在着很多不同版本的 SQL 语言，但是为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的关键词。但&lt;strong&gt;许多相似语义的内容其具体写法可能会有不同&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% note warning %}
SQL 对大小写不敏感。
SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。
使用 SQL 需先了解具体数据库的描述方法。
{% endnote %}&lt;/p&gt;
&lt;h1 id="section-1"&gt;数据操作语言&lt;/h1&gt;
&lt;h2 id="select"&gt;SELECT&lt;/h2&gt;
&lt;p&gt;SELECT 语句用于从表中选取数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT column FROM table_name
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;从名为 &amp;quot;Persons&amp;quot; 的数据库表，获取名为 &amp;quot;LastName&amp;quot; 和 &amp;quot;FirstName&amp;quot; 的列的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT LastName,FirstName FROM Persons
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;从 &amp;quot;Persons&amp;quot; 表中选取所有的列。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * FROM Persons
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="distinct"&gt;DISTINCT&lt;/h3&gt;
&lt;p&gt;关键词 DISTINCT 用于返回唯一不同的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 Company&amp;quot; 列中仅选取唯一不同的值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT DISTINCT Company FROM Orders 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="where"&gt;WHERE&lt;/h3&gt;
&lt;p&gt;如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选取居住在城市 &amp;quot;Beijing&amp;quot; 中的人&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * FROM Persons WHERE City='Beijing'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可用运算符：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;&amp;gt;&lt;/td&gt;
&lt;td&gt;不等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;大于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;大于等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;小于等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BETWEEN&lt;/td&gt;
&lt;td&gt;在某个范围内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IN&lt;/td&gt;
&lt;td&gt;规定多个可能取值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LIKE&lt;/td&gt;
&lt;td&gt;搜索某种模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;AND&lt;/td&gt;
&lt;td&gt;合取两个条件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;OR&lt;/td&gt;
&lt;td&gt;析取两个条件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;NOT&lt;/td&gt;
&lt;td&gt;条件取反&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * FROM Persons WHERE (FirstName='Thomas' OR FirstName='William') AND LastName='Carter'
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="like"&gt;LIKE&lt;/h4&gt;
&lt;p&gt;LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;通配符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;%&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;替代一个或多个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仅替代一个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[charlist]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字符列中的任何单一字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;[^charlist]&lt;/code&gt; 或 &lt;code&gt;[!charlist]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;不在字符列中的任何单一字符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;选取居住在以 &amp;quot;N&amp;quot; 开始的城市里的人&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT * FROM Persons WHERE City LIKE 'N%'
SELECT * FROM Persons WHERE City NOT LIKE '%lon%'
SELECT * FROM Persons WHERE LastName LIKE 'C_r_er'
SELECT * FROM Persons WHERE City LIKE '[ALN]%'
SELECT * FROM Persons WHERE City LIKE '[!ALN]%'
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="in"&gt;IN&lt;/h4&gt;
&lt;p&gt;IN 操作符允许我们在 WHERE 子句中规定多个可能的取值。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT column_name(s) FROM table_name
WHERE column_name IN (value1,value2,...)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="between-and"&gt;BETWEEN AND&lt;/h4&gt;
&lt;p&gt;操作符 BETWEEN ... AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT column_name(s) FROM table_name
WHERE column_name BETWEEN value1 AND value2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;{% note warning %}
不同的数据库对 BETWEEN...AND 操作符的处理方式是有差异的。区间端点的选择是不确定的。
{% endnote %}&lt;/p&gt;
&lt;h3 id="order-by"&gt;ORDER BY&lt;/h3&gt;
&lt;p&gt;ORDER BY 语句用于对结果集进行排序。如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT Company, OrderNumber FROM Orders ORDER BY Company
SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;主次关键字，以及主次关键字采用不同顺序：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber
SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="top"&gt;TOP&lt;/h3&gt;
&lt;p&gt;TOP 子句用于规定要返回的记录的数目。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从 &amp;quot;Persons&amp;quot; 表中选取头两条记录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT TOP 2 * FROM Persons
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;从 &amp;quot;Persons&amp;quot; 表中选取选取 50% 的记录。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT TOP 50 PERCENT * FROM Persons
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="as"&gt;AS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;表的 SQL Alias 语法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT column_name(s) FROM table_name AS alias_name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用别名简化书写。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT po.OrderID, p.LastName, p.FirstName
FROM Persons AS p, Product_Orders AS po
WHERE p.LastName='Adams' AND p.FirstName='John'
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;列的 SQL Alias 语法&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT column_name AS alias_name FROM table_name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以改变返回列表的列名。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT LastName AS Family, FirstName AS Name
FROM Persons
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="join"&gt;JOIN&lt;/h3&gt;
&lt;p&gt;JOIN 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。&lt;/p&gt;
&lt;p&gt;{% note info %}
数据库中的表可通过键将彼此联系起来。主键（Primary Key）是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。
{% endnote %}&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo
FROM Persons
INNER JOIN Orders
ON Persons.Id_P = Orders.Id_P
ORDER BY Persons.LastName
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;JOIN 或 INNER JOIN: 如果两个表中有至少一个匹配，则返回行&lt;/li&gt;
&lt;li&gt;LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行&lt;/li&gt;
&lt;li&gt;RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行&lt;/li&gt;
&lt;li&gt;FULL JOIN: 即使没有匹配，也从返回两表所有的行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="union"&gt;UNION&lt;/h3&gt;
&lt;p&gt;UNION 操作符用于合并两个或多个 SELECT 语句的结果集。请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT column_name(s) FROM table_name1
UNION
SELECT column_name(s) FROM table_name2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="update"&gt;UPDATE&lt;/h2&gt;
&lt;p&gt;Update 语句用于修改表中的数据。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;UPDATE table_name SET column_name = new_value WHERE column_name = a_value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为 lastname 是 &amp;quot;Wilson&amp;quot; 的人添加 firstname：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;UPDATE Person SET FirstName = 'Fred' WHERE LastName = 'Wilson' 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更新多列：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;UPDATE Person SET Address = 'Zhongshan 23', City = 'Nanjing' WHERE LastName = 'Wilson'
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="delete"&gt;DELETE&lt;/h2&gt;
&lt;p&gt;DELETE 语句用于删除表中的行。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DELETE FROM table_name WHERE column = a_value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除所有行：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;DELETE FROM table_name
DELETE * FROM table_name
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="insert-into"&gt;INSERT INTO&lt;/h2&gt;
&lt;p&gt;INSERT INTO 语句用于向表格中插入新的行。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;INSERT INTO table_name VALUES (value1, value2,....)
INSERT INTO table_name (column1, column2,...) VALUES (value1, value2,....)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="select-into"&gt;SELECT INTO&lt;/h2&gt;
&lt;p&gt;SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。
SELECT INTO 语句常用于创建表的备份复件或者用于对记录进行存档。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把所有的列插入新表&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT *
INTO new_table_name [IN externaldatabase] 
FROM old_tablename
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;只把希望的列插入新表&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;SELECT column_name(s)
INTO new_table_name [IN externaldatabase] 
FROM old_tablename
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可结合 WHERE 子句，JOIN 子句等。&lt;/p&gt;
&lt;h1 id="section-2"&gt;数据定义语言&lt;/h1&gt;
&lt;h2 id="create-database"&gt;CREATE DATABASE&lt;/h2&gt;
&lt;p&gt;CREATE DATABASE 用于创建数据库。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE DATABASE database_name
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="create-table"&gt;CREATE TABLE&lt;/h2&gt;
&lt;p&gt;CREATE TABLE 语句用于创建数据库中的表。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE table_name
(
column_name1 datatype,
column_name2 datatype,
column_name3 datatype,
....
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关于数据类型，不同数据库有一定差别，参见 &lt;a href="http://www.w3school.com.cn/sql/sql_datatypes.asp"&gt;SQL 数据类型&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id="create-index"&gt;CREATE INDEX&lt;/h2&gt;
&lt;p&gt;CREATE INDEX 语句用于在表中创建索引。
在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。用户无法看到索引，它们只能被用来加速搜索/查询。更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在表上创建一个简单的索引。允许使用重复的值：&amp;quot;column_name&amp;quot; 规定需要索引的列。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE INDEX index_name ON table_name (column_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在表上创建一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE UNIQUE INDEX index_name ON table_name (column_name)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;以降序索引某个列中的值&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE INDEX PersonIndex ON Person (LastName DESC) 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="alter-table"&gt;ALTER TABLE&lt;/h2&gt;
&lt;p&gt;ALTER TABLE 语句用于在已有的表中添加、修改或删除列。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在表中添加列&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;ALTER TABLE table_name ADD column_name datatype
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;删除表中的列&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;ALTER TABLE table_name DROP COLUMN column_name
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;改变表中列的数据类型&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;ALTER TABLE table_name ALTER COLUMN column_name datatype
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="drop"&gt;DROP&lt;/h2&gt;
&lt;p&gt;通过使用 DROP 语句，可以轻松地删除索引、表和数据库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;DROP INDEX index_name&lt;/li&gt;
&lt;li&gt;DROP TABLE table_name&lt;/li&gt;
&lt;li&gt;DROP DATABASE database_name&lt;/li&gt;
&lt;li&gt;TRUNCATE TABLE table_name 仅仅删除表格中的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="auto-increment"&gt;AUTO INCREMENT&lt;/h2&gt;
&lt;p&gt;Auto-increment 会在新记录插入表中时生成一个唯一的数字。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE Persons
(
P_Id int NOT NULL AUTO_INCREMENT,
LastName varchar(255) NOT NULL,
FirstName varchar(255),
Address varchar(255),
City varchar(255),
PRIMARY KEY (P_Id)
)

ALTER TABLE Persons AUTO_INCREMENT=100
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-3"&gt;数据约束&lt;/h2&gt;
&lt;p&gt;约束用于限制加入表的数据的类型。
可以在创建表时规定约束（通过 CREATE TABLE 语句，在数据类型后标注），或者在表创建之后也可以（通过 ALTER TABLE 语句）。
约束可命名，用于取消约束。&lt;/p&gt;
&lt;h3 id="not-null"&gt;NOT NULL&lt;/h3&gt;
&lt;p&gt;NOT NULL 约束强制列不接受 NULL 值。&lt;/p&gt;
&lt;h3 id="unique"&gt;UNIQUE&lt;/h3&gt;
&lt;p&gt;UNIQUE 约束唯一标识数据库表中的每条记录。
UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。PRIMARY KEY 拥有自动定义的 UNIQUE 约束。
请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。&lt;/p&gt;
&lt;h3 id="primary-key"&gt;PRIMARY KEY&lt;/h3&gt;
&lt;p&gt;PRIMARY KEY 约束唯一标识数据库表中的每条记录。
主键必须包含唯一的值。主键列不能包含 NULL 值。
每个表都应该有一个主键，并且每个表只能有一个主键。&lt;/p&gt;
&lt;h3 id="foreign-key"&gt;FOREIGN KEY&lt;/h3&gt;
&lt;p&gt;一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sql"&gt;CREATE TABLE Orders
(
Id_O int NOT NULL PRIMARY KEY,
OrderNo int NOT NULL,
Id_P int FOREIGN KEY REFERENCES Persons(Id_P)
)

CREATE TABLE Orders
(
Id_O int NOT NULL,
OrderNo int NOT NULL,
Id_P int,
PRIMARY KEY (Id_O),
CONSTRAINT fk_PerOrders FOREIGN KEY (Id_P)
REFERENCES Persons(Id_P)
)

ALTER TABLE Orders
ADD FOREIGN KEY (Id_P)
REFERENCES Persons(Id_P)

ALTER TABLE Orders
ADD CONSTRAINT fk_PerOrders
FOREIGN KEY (Id_P)
REFERENCES Persons(Id_P)

ALTER TABLE Orders
DROP FOREIGN KEY fk_PerOrders

ALTER TABLE Orders
DROP CONSTRAINT fk_PerOrders
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="check"&gt;CHECK&lt;/h3&gt;
&lt;p&gt;CHECK 约束用于限制列中的值的范围。
如果对单个列定义 CHECK 约束，那么该列只允许特定的值。
如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。&lt;/p&gt;
&lt;h3 id="default"&gt;DEFAULT&lt;/h3&gt;
&lt;p&gt;DEFAULT 约束用于向列中插入默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。&lt;/p&gt;
&lt;h1 id="section-4"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.w3school.com.cn/sql/index.asp"&gt;SQL 教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/progLang-makefile</id><title type="text">Makefile</title><summary type="text">基本信息
Makefile 为 make 提供依赖描述和编译指令等设置。
基础知识
注释 #
转义 \
通配符：* ? ~
显式规则
Makefile 规则：指定依赖关系与生成命令。
target .</summary><published>2018-09-16T10:20:00+08:00</published><updated>2018-09-16T10:20:00+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2FprogLang-makefile" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Makefile 为 make 提供依赖描述和编译指令等设置。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;基础知识&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;注释 &lt;code&gt;#&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;转义 &lt;code&gt;\&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通配符：&lt;code&gt;* ? ~&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-2"&gt;显式规则&lt;/h1&gt;
&lt;p&gt;Makefile 规则：指定依赖关系与生成命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;target ... : prerequisites ...
    command
    ...
    ...

targets : prerequisites ; command
    command
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;target
可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签。可以使用通配符。&lt;/li&gt;
&lt;li&gt;prerequisites
生成该target所依赖的文件和/或target&lt;/li&gt;
&lt;li&gt;command
该target要执行的命令（任意的shell命令），如果其不与“target:prerequisites”在一行，那么，必须以 Tab 键开头，如 果和prerequisites在一行，那么可以用分号做为分隔。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% note info %}
prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。
{% endnote %}&lt;/p&gt;
&lt;p&gt;还可以通过这种方式表达依赖关系，多个目标依赖一个文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Make 将第一个目标作为最终目标&lt;/li&gt;
&lt;li&gt;没有依赖项的目标一般不会被自动执行（除非是第一个），需要向 make 传递参数来执行特定目标&lt;/li&gt;
&lt;li&gt;可以使用 &lt;code&gt;\&lt;/code&gt; 折行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;多目标&lt;/h2&gt;
&lt;p&gt;有可能我们的多个目标同时依赖于一个文件，并且 其生成的命令大体类似。可以使用自动化变量 &lt;code&gt;$@&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;bigoutput littleoutput : text.g
    generate text.g -$(subst output,,$@) &amp;gt; $@

# equal to

bigoutput : text.g
    generate text.g -big &amp;gt; bigoutput
littleoutput : text.g
    generate text.g -little &amp;gt; littleoutput
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态模式：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;&amp;lt;targets ...&amp;gt; : &amp;lt;target-pattern&amp;gt; : &amp;lt;prereq-patterns ...&amp;gt;
    &amp;lt;commands&amp;gt;
    ...
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。&lt;/li&gt;
&lt;li&gt;target-parrtern是指明了targets的模式，也就是的目标集模式。&lt;/li&gt;
&lt;li&gt;prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;objects = foo.o bar.o

all: $(objects)

$(objects): %.o: %.c
    $(CC) -c $(CFLAGS) $&amp;lt; -o $@

# equal to

foo.o : foo.c
    $(CC) -c $(CFLAGS) foo.c -o foo.o
bar.o : bar.c
    $(CC) -c $(CFLAGS) bar.c -o bar.o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;静态模式很灵活：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;files = foo.elc bar.o lose.o

$(filter %.o,$(files)): %.o: %.c
    $(CC) -c $(CFLAGS) $&amp;lt; -o $@
$(filter %.elc,$(files)): %.elc: %.el
    emacs -f batch-byte-compile $&amp;lt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用编译器的功能自动生成依赖关系：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;cc -M foo.c 
gcc -M foo.c # include std
gcc -MM foo.c # exclude std
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-4"&gt;&lt;a href="https://seisman.github.io/how-to-write-makefile/implicit_rules.html#"&gt;隐晦规则&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile。&lt;/p&gt;
&lt;h1 id="section-5"&gt;命令&lt;/h1&gt;
&lt;h2 id="section-6"&gt;命令显示&lt;/h2&gt;
&lt;p&gt;命令必须以 Tab 开始，以 Tab 开始的行会被视为命令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 @ 字符在命令行前，那么， 这个命令将不被make显示出来&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果make执行时，带入make参数 &lt;code&gt;-n&lt;/code&gt; 或 &lt;code&gt;--just-print&lt;/code&gt; ，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么 顺序的。而make参数 &lt;code&gt;-s&lt;/code&gt; 或 &lt;code&gt;--silent&lt;/code&gt; 或 &lt;code&gt;--quiet&lt;/code&gt; 则是全面禁止命令的显示。&lt;/p&gt;
&lt;h2 id="section-7"&gt;命令执行&lt;/h2&gt;
&lt;p&gt;当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意 的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。
一般来说，make会以UNIX的标准Shell，也就是 /bin/sh 来执行命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;exec:
    cd /home/hchen; pwd
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-8"&gt;命令出错&lt;/h2&gt;
&lt;p&gt;每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规 则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码 非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。&lt;/p&gt;
&lt;p&gt;忽略命令的出错，我们可以在Makefile的命令行前加一个减号 - （在Tab键之后） ，标记为不管命令出不出错都认为是成功的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;clean:
    -rm -f *.o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给make加上 &lt;code&gt;-i&lt;/code&gt; 或是 &lt;code&gt;--ignore-errors&lt;/code&gt; 参数，那么，Makefile中 所有命令都会忽略错误。而如果一个规则是以 &lt;code&gt;.IGNORE&lt;/code&gt; 作为目标的，那么这个规则中的所有命令将会 忽略错误。
给make加上 &lt;code&gt;-k&lt;/code&gt; 或是 &lt;code&gt;--keep-going&lt;/code&gt; ，这个参数的意思是，如果某 规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。&lt;/p&gt;
&lt;h2 id="make"&gt;嵌套Make&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;subsystem:
    cd subdir &amp;amp;&amp;amp; $(MAKE)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你要传递变量到下级Makefile中，那么你可以使用这样的声明: &lt;code&gt;export &amp;lt;variable ...&amp;gt;;&lt;/code&gt;
如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明: &lt;code&gt;unexport &amp;lt;variable ...&amp;gt;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;有两个变量，一个是 &lt;code&gt;SHELL&lt;/code&gt; ，一个是 &lt;code&gt;MAKEFLAGS&lt;/code&gt; ，这两个变量不管你是否export，其总是要传递到下层 Makefile中，特别是 &lt;code&gt;MAKEFLAGS&lt;/code&gt; 变量，其中包含了make的参数 信息，如果我们执行“总控Makefile”时有make参数或是在上层 Makefile中定义了这个变量，那么 &lt;code&gt;MAKEFLAGS&lt;/code&gt; 变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。&lt;/p&gt;
&lt;p&gt;如果你不想往下层传递参数，可显式指定参数为空：&lt;code&gt;$(MAKE) MAKEFLAGS=&lt;/code&gt;
参数 &lt;code&gt;-w&lt;/code&gt; 或是 &lt;code&gt;--print-directory&lt;/code&gt; 会在make的过程 中输出一些信息，让你看到目前的工作目录。&lt;/p&gt;
&lt;h1 id="section-9"&gt;变量&lt;/h1&gt;
&lt;h2 id="section-10"&gt;定义变量&lt;/h2&gt;
&lt;p&gt;变量名可含有字符、数字，下划线（可以是数字开头）。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;objects = main.o kbd.o command.o display.o \
     insert.o search.o files.o utils.o
edit : $(objects)
    cc -o edit $(objects)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 &lt;code&gt;$&lt;/code&gt; 符号，但最好用小括号 &lt;code&gt;()&lt;/code&gt; 或是大括号 &lt;code&gt;{}&lt;/code&gt; 把变量给包括起来。&lt;/p&gt;
&lt;p&gt;{% note info %}
如果你要使用真实的 &lt;code&gt;$&lt;/code&gt; 字符，那么你需要用 &lt;code&gt;$$&lt;/code&gt; 来表示。变量会在使用它的地方精确地展开。
{% endnote %}&lt;/p&gt;
&lt;p&gt;在定义变量的值时，我们可以使用其它变量来构造变量的值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt;：在 &lt;code&gt;=&lt;/code&gt; 左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。但这可能带来循环定义。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:=&lt;/code&gt;：只能使用前面已定义好了的变量。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?=&lt;/code&gt;：如果没有被定义过，那么定义此变量，如果先前被定义过，那么这条语将什么也不做&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+=&lt;/code&gt;：给变量追加值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们要定义一个变量，其值是一个空格：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;nullstring :=
space := $(nullstring) # end of the line
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边 是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采 用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。
{% note warning %}
请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意
{% endnote %}&lt;/p&gt;
&lt;h3 id="section-11"&gt;变量覆盖&lt;/h3&gt;
&lt;p&gt;如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想 在Makefile中设置这类参数的值，那么，你可以使用 &lt;code&gt;override&lt;/code&gt; 指示符。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;override &amp;lt;variable&amp;gt;; = &amp;lt;value&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-12"&gt;多行变量&lt;/h3&gt;
&lt;p&gt;define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束。其工作方 式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头， 所以如果你用define定义的命令变量中没有以 Tab 键开头，那么make 就不会把其认为是命令。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;define two-lines
echo foo
echo $(bar)
endef
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-13"&gt;使用变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;变量值替换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;$(var:a=b)&lt;/code&gt; 其意思是， 把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;把变量的值再当成变量&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;x = y
y = z
a := $($(x))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-14"&gt;局部变量&lt;/h2&gt;
&lt;p&gt;可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以 和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而 不会影响规则链以外的全局变量的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;&amp;lt;target ...&amp;gt; : &amp;lt;variable-assignment&amp;gt;;
&amp;lt;target ...&amp;gt; : overide &amp;lt;variable-assignment&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同样可对 target 应用模式：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;&amp;lt;pattern ...&amp;gt;; : &amp;lt;variable-assignment&amp;gt;;
&amp;lt;pattern ...&amp;gt;; : override &amp;lt;variable-assignment&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-15"&gt;&lt;a href="https://seisman.github.io/how-to-write-makefile/variables.html#id7"&gt;环境变量&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;.DEFAULT_GOAL&lt;/code&gt; 指定默认目标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SHELL&lt;/code&gt; 指定默认 Shell&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="section-16"&gt;文件搜索路径&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;VPATH&lt;/code&gt; 变量：如果没有指明这个变量，make只会在当前 的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下 ，到所指定的目录中去找寻文件了。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;VPATH = src:../headers
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还可以使用 &lt;code&gt;vpath&lt;/code&gt; 关键字：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vpath &amp;lt;pattern&amp;gt; &amp;lt;directories&amp;gt;&lt;/code&gt;
为符合模式&lt;pattern&gt;的文件指定搜索目录&lt;directories&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vpath &amp;lt;pattern&amp;gt;&lt;/code&gt;
清除符合模式&lt;pattern&gt;的文件的搜索目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vpath&lt;/code&gt;
清除所有已被设置好了的文件搜索目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;vapth&lt;/code&gt; 使用方法中的&lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt;需要包含 &lt;code&gt;%&lt;/code&gt; 字符。 &lt;code&gt;%&lt;/code&gt; 的意思是匹配零或若干字符&lt;/p&gt;
&lt;p&gt;我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的&lt;pattern&gt; ，或是被重复了的&lt;pattern&gt;，那么，make会按照vpath语句的先后顺序来执行搜索。&lt;/p&gt;
&lt;h2 id="section-17"&gt;自动化变量&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$@&lt;/code&gt; : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， &lt;code&gt;$@&lt;/code&gt; 就是匹配于目标中模式定义的集合。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$%&lt;/code&gt; : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 &lt;code&gt;foo.a(bar.o)&lt;/code&gt; ，那么， &lt;code&gt;$%&lt;/code&gt; 就是 &lt;code&gt;bar.o&lt;/code&gt; ， &lt;code&gt;$@&lt;/code&gt; 就是 &lt;code&gt;foo.a&lt;/code&gt; 。如果目标不是函数库文件那么，其值为空。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&amp;lt;&lt;/code&gt; : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 &lt;code&gt;%&lt;/code&gt; ）定义的，那么 &lt;code&gt;$&amp;lt;&lt;/code&gt;将是符合模式的一系列的文件集。注意，其是一个一个取出来的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$?&lt;/code&gt; : 所有比目标新的依赖目标的集合。以空格分隔。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$^&lt;/code&gt; : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$+&lt;/code&gt; : 这个变量很像 &lt;code&gt;$^&lt;/code&gt; ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$*&lt;/code&gt; : 这个变量表示目标模式中 &lt;code&gt;%&lt;/code&gt; 及其之前的部分。如果目标是 &lt;code&gt;dir/a.foo.b&lt;/code&gt; ，并且目标的模式是 &lt;code&gt;a.%.b&lt;/code&gt; ，那么， &lt;code&gt;$*&lt;/code&gt; 的值就是 &lt;code&gt;dir/a.foo&lt;/code&gt; 。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么 &lt;code&gt;$*&lt;/code&gt; 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 &lt;code&gt;$*&lt;/code&gt; 就是除了后缀的那一部分。例如：如果目标是 &lt;code&gt;foo.c&lt;/code&gt; ，因为&lt;code&gt;.c&lt;/code&gt; 是make所能识别的后缀名，所以， &lt;code&gt;$*&lt;/code&gt; 的值就是 &lt;code&gt;foo&lt;/code&gt; 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 &lt;code&gt;$*&lt;/code&gt; ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 &lt;code&gt;$*&lt;/code&gt; 就是空值。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上述所列出来的自动量变量中。四个变量（&lt;code&gt;$@&lt;/code&gt; 、 &lt;code&gt;$&amp;lt;&lt;/code&gt; 、 &lt;code&gt;$%&lt;/code&gt; 、 &lt;code&gt;$*&lt;/code&gt; ）在扩展时
只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前
目录下的符合模式的文件名，只需要搭配上 &lt;code&gt;D&lt;/code&gt; 或 &lt;code&gt;F&lt;/code&gt; 字样。这是GNU make中老版本的特性，
在新版本中，我们使用函数 &lt;code&gt;dir&lt;/code&gt; 或 &lt;code&gt;notdir&lt;/code&gt; 就可以做到了。 &lt;code&gt;D&lt;/code&gt; 的含义就是Directory，
就是目录， &lt;code&gt;F&lt;/code&gt; 的含义就是File，就是文件。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$(@D)&lt;/code&gt;
表示 &lt;code&gt;$@&lt;/code&gt; 的目录部分（不以斜杠作为结尾），如果 &lt;code&gt;$@&lt;/code&gt; 值是 &lt;code&gt;dir/foo.o&lt;/code&gt; ，那么
&lt;code&gt;$(@D)&lt;/code&gt; 就是 &lt;code&gt;dir&lt;/code&gt; ，而如果 &lt;code&gt;$@&lt;/code&gt; 中没有包含斜杠的话，其值就是 &lt;code&gt;.&lt;/code&gt; （当前目录）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(@F)&lt;/code&gt;
表示 &lt;code&gt;$@&lt;/code&gt; 的文件部分，如果 &lt;code&gt;$@&lt;/code&gt; 值是 &lt;code&gt;dir/foo.o&lt;/code&gt; ，那么 &lt;code&gt;$(@F)&lt;/code&gt; 就是 &lt;code&gt;foo.o&lt;/code&gt; ，
&lt;code&gt;$(@F)&lt;/code&gt; 相当于函数 &lt;code&gt;$(notdir $@)&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(*D)&lt;/code&gt;, &lt;code&gt;$(*F)&lt;/code&gt;
和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， &lt;code&gt;$(*D)&lt;/code&gt; 返回 &lt;code&gt;dir&lt;/code&gt; ，
而 &lt;code&gt;$(*F)&lt;/code&gt; 返回 &lt;code&gt;foo&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(%D)&lt;/code&gt;, &lt;code&gt;$(%F)&lt;/code&gt;
分别表示了函数包文件成员的目录部分和文件部分。这对于形同 &lt;code&gt;archive(member)&lt;/code&gt; 形式的目标中的
&lt;code&gt;member&lt;/code&gt; 中包含了不同的目录很有用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(&amp;lt;D)&lt;/code&gt;, &lt;code&gt;$(&amp;lt;F)&lt;/code&gt;
分别表示依赖文件的目录部分和文件部分。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(^D)&lt;/code&gt;, &lt;code&gt;$(^F)&lt;/code&gt;
分别表示所有依赖文件的目录部分和文件部分。（无相同的）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(+D)&lt;/code&gt;, &lt;code&gt;$(+F)&lt;/code&gt;
分别表示所有依赖文件的目录部分和文件部分。（可以有相同的）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(?D)&lt;/code&gt;, &lt;code&gt;$(?F)&lt;/code&gt;
分别表示被更新的依赖文件的目录部分和文件部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-18"&gt;文件指示&lt;/h1&gt;
&lt;p&gt;在Makefile使用 include 关键字可以把别的Makefile包含进来，filename 可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;include &amp;lt;filename1&amp;gt; &amp;lt;filename2&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-19"&gt;更多&lt;/h1&gt;
&lt;h2 id="section-20"&gt;伪目标&lt;/h2&gt;
&lt;p&gt;为了避免目标名和文件重名的情况，可以使用一个特殊的标记“.PHONY”来显式地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。
注意伪目标同样也可成为依赖，其指定的是执行关系。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;.PHONY : clean
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-21"&gt;条件判断&lt;/h2&gt;
&lt;p&gt;使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值， 或是比较变量和常量的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;libs_for_gcc = -lgnu
normal_libs =

foo: $(objects)
ifeq ($(CC),gcc)
    $(CC) -o foo $(objects) $(libs_for_gcc)
else
    $(CC) -o foo $(objects) $(normal_libs)
endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;条件表达式使用：比较参数 arg1 和 arg2 的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;ifeq (&amp;lt;arg1&amp;gt;, &amp;lt;arg2&amp;gt;)
ifeq '&amp;lt;arg1&amp;gt;' '&amp;lt;arg2&amp;gt;'
ifeq &amp;quot;&amp;lt;arg1&amp;gt;&amp;quot; &amp;quot;&amp;lt;arg2&amp;gt;&amp;quot;
ifeq &amp;quot;&amp;lt;arg1&amp;gt;&amp;quot; '&amp;lt;arg2&amp;gt;'
ifeq '&amp;lt;arg1&amp;gt;' &amp;quot;&amp;lt;arg2&amp;gt;&amp;quot;

ifdef &amp;lt;variable-name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;条件关键字&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ifeq&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;值是否相同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ifneq&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;值是否不同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ifdef&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;测试变量值是否非空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ifndef&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;测试变量值是否为空&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-22"&gt;函数&lt;/h2&gt;
&lt;p&gt;调用：&lt;code&gt;$(&amp;lt;function&amp;gt; &amp;lt;arguments&amp;gt;)&lt;/code&gt;，参数间以逗号 , 分隔，而函数名和参数之间以“空格”分隔。函数调用以 $ 开头，以圆括号 或花括号把函数名和参数括起。
|函数|描述|
|-|-|
|&lt;code&gt;$(subst &amp;lt;from&amp;gt;,&amp;lt;to&amp;gt;,&amp;lt;text&amp;gt;)&lt;/code&gt;|把字串 &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;&amp;lt;from&amp;gt;&lt;/code&gt; 字符串替换成 &lt;code&gt;&amp;lt;to&amp;gt;&lt;/code&gt; |
|&lt;code&gt;$(patsubst &amp;lt;pattern&amp;gt;,&amp;lt;replacement&amp;gt;,&amp;lt;text&amp;gt;)&lt;/code&gt;|查找 &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 中的单词是否符合模式 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; ，如果匹配的话，则以 &lt;code&gt;&amp;lt;replacement&amp;gt;&lt;/code&gt; 替换。可使用通配符 &lt;code&gt;%&lt;/code&gt;|
|&lt;code&gt;$(strip &amp;lt;string&amp;gt;)&lt;/code&gt;|去掉 &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; 字串中开头和结尾的空字符。|
|&lt;code&gt;$(findstring &amp;lt;find&amp;gt;,&amp;lt;in&amp;gt;)&lt;/code&gt;|在字串 &lt;code&gt;&amp;lt;in&amp;gt;&lt;/code&gt; 中查找 &lt;code&gt;&amp;lt;find&amp;gt;&lt;/code&gt; 字串。如果找到，那么返回 &lt;code&gt;&amp;lt;find&amp;gt;&lt;/code&gt; ，否则返回空字符串。|
|&lt;code&gt;$(filter &amp;lt;pattern...&amp;gt;,&amp;lt;text&amp;gt;)&lt;/code&gt;|以 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 模式过滤 &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 字符串中的单词，保留符合模式 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 的单词。|
|&lt;code&gt;$(filter-out &amp;lt;pattern...&amp;gt;,&amp;lt;text&amp;gt;)&lt;/code&gt;|以 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 模式过滤 &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 字符串中的单词，去除符合模式 &lt;code&gt;&amp;lt;pattern&amp;gt;&lt;/code&gt; 的单词。|
|&lt;code&gt;$(sort &amp;lt;list&amp;gt;)&lt;/code&gt;|给字符串 &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; 中的单词排序（升序）。会去掉 &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; 中相同的单词|
|&lt;code&gt;$(word &amp;lt;n&amp;gt;,&amp;lt;text&amp;gt;)&lt;/code&gt;|取字符串 &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 中第 &lt;code&gt;&amp;lt;n&amp;gt;&lt;/code&gt; 个单词。（从一开始）|
|&lt;code&gt;$(wordlist &amp;lt;ss&amp;gt;,&amp;lt;e&amp;gt;,&amp;lt;text&amp;gt;)&lt;/code&gt;|从字符串 &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 中取从 &lt;code&gt;&amp;lt;ss&amp;gt;&lt;/code&gt; 开始到 &lt;code&gt;&amp;lt;e&amp;gt;&lt;/code&gt; 的单词串。|
|&lt;code&gt;$(words &amp;lt;text&amp;gt;)&lt;/code&gt;|统计 &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 中字符串中的单词个数。|
|&lt;code&gt;$(firstword &amp;lt;text&amp;gt;)&lt;/code&gt;|取字符串 &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 中的第一个单词。|
|&lt;code&gt;$(dir &amp;lt;names...&amp;gt;)&lt;/code&gt;|从文件名序列 &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt; 中取出目录部分。目录部分是指最后一个反斜杠（ &lt;code&gt;/&lt;/code&gt; ）之前的部分。如果没有反斜杠，那么返回 &lt;code&gt;./&lt;/code&gt; |
|&lt;code&gt;$(notdir &amp;lt;names...&amp;gt;)&lt;/code&gt;|从文件名序列 &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt; 中取出非目录部分。非目录部分是指最後一个反斜杠（ &lt;code&gt;/&lt;/code&gt; ）之后的部分。|
|&lt;code&gt;$(suffix &amp;lt;names...&amp;gt;)&lt;/code&gt;|从文件名序列 &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt; 中取出各个文件名的后缀。|
|&lt;code&gt;$(basename &amp;lt;names...&amp;gt;)&lt;/code&gt;|从文件名序列 &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt; 中取出各个文件名的前缀部分。|
|&lt;code&gt;$(addsuffix &amp;lt;suffix&amp;gt;,&amp;lt;names...&amp;gt;)&lt;/code&gt;|把后缀 &lt;code&gt;&amp;lt;suffix&amp;gt;&lt;/code&gt; 加到 &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt; 中的每个单词后面。|
|&lt;code&gt;$(addprefix &amp;lt;prefix&amp;gt;,&amp;lt;names...&amp;gt;)&lt;/code&gt;|把前缀 &lt;code&gt;&amp;lt;prefix&amp;gt;&lt;/code&gt; 加到 &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt; 中的每个单词后面。|
|&lt;code&gt;$(join &amp;lt;list1&amp;gt;,&amp;lt;list2&amp;gt;)&lt;/code&gt;|把 &lt;code&gt;&amp;lt;list2&amp;gt;&lt;/code&gt; 中的单词对应地加到 &lt;code&gt;&amp;lt;list1&amp;gt;&lt;/code&gt; 的单词后面。如果 &lt;code&gt;&amp;lt;list1&amp;gt;&lt;/code&gt; 的单词个数要比 &lt;code&gt;&amp;lt;list2&amp;gt;&lt;/code&gt; 的多，那么， &lt;code&gt;&amp;lt;list1&amp;gt;&lt;/code&gt; 中的多出来的单词将保持原样。如果&lt;code&gt;&amp;lt;list2&amp;gt;&lt;/code&gt; 的单词个数要比 &lt;code&gt;&amp;lt;list1&amp;gt;&lt;/code&gt; 多，那么， &lt;code&gt;&amp;lt;list2&amp;gt;&lt;/code&gt; 多出来的单词将被复制到&lt;code&gt;&amp;lt;list1&amp;gt;&lt;/code&gt; 中。|
|&lt;code&gt;$(foreach &amp;lt;var&amp;gt;,&amp;lt;list&amp;gt;,&amp;lt;text&amp;gt;)&lt;/code&gt;|把参数 &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; 中的单词逐一取出放到参数 &lt;code&gt;&amp;lt;var&amp;gt;&lt;/code&gt; 所指定的变量中，然后再执行 &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 所包含的表达式。每一次 &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 会返回一个字符串，循环过程中，&lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。|
|&lt;code&gt;$(if &amp;lt;condition&amp;gt;,&amp;lt;then-part&amp;gt;,&amp;lt;else-part&amp;gt;)&lt;/code&gt;|如果 &lt;code&gt;&amp;lt;condition&amp;gt;&lt;/code&gt; 为真（非空字符串），那个 &lt;code&gt;&amp;lt;then-part&amp;gt;&lt;/code&gt;会是整个函数的返回值，如果 &lt;code&gt;&amp;lt;condition&amp;gt;&lt;/code&gt; 为假（空字符串），那么 &lt;code&gt;&amp;lt;else-part&amp;gt;&lt;/code&gt; 会是整个函数的返回值，此时如果 &lt;code&gt;&amp;lt;else-part&amp;gt;&lt;/code&gt; 没有被定义，那么，整个函数返回空字串。|
|&lt;code&gt;$(call &amp;lt;expression&amp;gt;,&amp;lt;parm1&amp;gt;,&amp;lt;parm2&amp;gt;,...,&amp;lt;parmn&amp;gt;)&lt;/code&gt;|当make执行这个函数时， &lt;code&gt;&amp;lt;expression&amp;gt;&lt;/code&gt; 参数中的变量，如 &lt;code&gt;$(1)&lt;/code&gt; 、 &lt;code&gt;$(2)&lt;/code&gt; 等，会被参数 &lt;code&gt;&amp;lt;parm1&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;parm2&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;parm3&amp;gt;&lt;/code&gt; 依次取代。而 &lt;code&gt;&amp;lt;expression&amp;gt;&lt;/code&gt; 的返回值就是 call 函数的返回值。|
|&lt;code&gt;$(origin &amp;lt;variable&amp;gt;)&lt;/code&gt;|返回这个变量是哪里来的|
|&lt;code&gt;$(shell cmd)&lt;/code&gt;|shell函数把执行操作系统命令后的输出作为函数返回。make 会新生成一个Shell程序来执行命令。|
|&lt;code&gt;$(error &amp;lt;text ...&amp;gt;)&lt;/code&gt;|产生一个致命的错误， &lt;code&gt;&amp;lt;text ...&amp;gt;&lt;/code&gt; 是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。|
|&lt;code&gt;$(warning &amp;lt;text ...&amp;gt;)&lt;/code&gt;|并不会让make退出，只是输出一段警告信息，而make继续执行。|&lt;/p&gt;
&lt;p&gt;如果我们要取 &lt;code&gt;&amp;lt;text&amp;gt;&lt;/code&gt; 中最后的一个单词，我们可以这样：&lt;code&gt;$(word $(words &amp;lt;text&amp;gt;),&amp;lt;text&amp;gt;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;origin&lt;/code&gt; 函数返回值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;undefined&lt;/code&gt;
如果 &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; 从来没有定义过，origin函数返回这个值 &lt;code&gt;undefined&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;default&lt;/code&gt;
如果 &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; 是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;environment&lt;/code&gt;
如果 &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; 是一个环境变量，并且当Makefile被执行时， &lt;code&gt;-e&lt;/code&gt; 参数没有被打开。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;file&lt;/code&gt;
如果 &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; 这个变量被定义在Makefile中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;command line&lt;/code&gt;
如果 &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; 这个变量是被命令行定义的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;override&lt;/code&gt;
如果 &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; 是被override指示符重新定义的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;automatic&lt;/code&gt;
如果 &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; 是一个命令运行中的自动化变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-23"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://seisman.github.io/how-to-write-makefile/overview.html"&gt;跟我一起写Makefile&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/nuget</id><title type="text">NuGet</title><summary type="text">基本信息
官网
介绍：.NET 平台上的包管理器。支持创建，共享，安装，管理包。
特点：NuGet 提供支持专用托管的中心 nuget.org 存储库。NuGet 为开发人员提供创建、发布和使用包所需</summary><published>2018-09-17T17:40:02+08:00</published><updated>2018-09-17T17:40:02+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2Fnuget" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.nuget.org/"&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍：.NET 平台上的包管理器。支持创建，共享，安装，管理包。&lt;/li&gt;
&lt;li&gt;特点：NuGet 提供支持专用托管的中心 nuget.org 存储库。NuGet 为开发人员提供创建、发布和使用包所需的工具。最重要的是，NuGet 能维护项目中所用包的引用列表，并且能够通过该列表还原和更新这些包。NuGet 管理包缓存和全局包文件夹，使安装和重新安装过程更为快捷。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;使用包&lt;/h1&gt;
&lt;p&gt;NuGet 会记住每个已安装包的标识和版本号，并将其录制到 &lt;code&gt;packages.config&lt;/code&gt; 或项目文件（使用 &lt;code&gt;PackageReference&lt;/code&gt;）中，具体取决于项目类型和 NuGet 版本。 使用 NuGet 4.0+，&lt;code&gt;PackageReference&lt;/code&gt; 为首选方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;&amp;lt;package id=&amp;quot;Newtonsoft.json&amp;quot; version=&amp;quot;6.0.4&amp;quot; allowedVersions=&amp;quot;[6,7)&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;PackageReference Include=&amp;quot;Newtonsoft.json&amp;quot; Version=&amp;quot;[6, 7)&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-2"&gt;查找包&lt;/h2&gt;
&lt;p&gt;搜索语法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;关键字：搜索操作将查找包含任何给定关键字的相关包。 示例：&lt;code&gt;modern UI&lt;/code&gt;。 若要搜索包含所有给定关键字的包，请在搜索词之间使用“+”，例如 &lt;code&gt;modern+UI&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;短语：在引号内输入搜索词可查找与其大小写完全匹配的匹配项。 示例：&lt;code&gt;&amp;quot;modern UI&amp;quot; package&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;筛选：可以按照语法 &lt;code&gt;&amp;lt;property&amp;gt;:&amp;lt;term&amp;gt;&lt;/code&gt; 使用搜索词来搜索特定属性，其中，&lt;code&gt;&amp;lt;property&amp;gt;&lt;/code&gt;（区分大小写）可为 &lt;code&gt;id&lt;/code&gt;,&lt;code&gt;packageid&lt;/code&gt;,&lt;code&gt;version&lt;/code&gt;,&lt;code&gt;title&lt;/code&gt;,&lt;code&gt;tags&lt;/code&gt;,&lt;code&gt;author&lt;/code&gt;,&lt;code&gt;description&lt;/code&gt;,&lt;code&gt;summary&lt;/code&gt; 和 &lt;code&gt;owner&lt;/code&gt;。 可将搜索词添加在引号中（如需要），还可以同时搜索多个属性。 此外，按 &lt;code&gt;id&lt;/code&gt; 属性搜索得到的是子字符串匹配项，而按 &lt;code&gt;s&lt;/code&gt; 搜索将得到确切匹配。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;id:NuGet.Core                # Match any part of the id property
Id:&amp;quot;Nuget.Core&amp;quot;
ID:jQuery
title:jquery                 # Searches title as cliown on the package listing
PackageId:jquery             # Match the package id exactly
id:jquery id:ui              # Search for multiple terms in the id
id:jquery tags:validation    # Search multiple properties
id:&amp;quot;jquery.ui&amp;quot;               # Phrase search
invalid:jquery ui            # Unsupported properties are ignored, so this
                             # is the same as searching on jquery ui
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-3"&gt;&lt;a href="https://docs.microsoft.com/zh-cn/nuget/consume-packages/ways-to-install-a-package#what-happens-when-a-package-is-installed"&gt;安装包&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id="section-4"&gt;&lt;a href="https://docs.microsoft.com/zh-cn/nuget/consume-packages/package-restore"&gt;还原包&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;要还原包，首先根据需要安装项目的直接依赖项，然后在整个依赖项关系图中安装这些包的所有依赖项。
如果尚未安装程序包，NuGet 首先尝试从缓存中检索它。 如果在缓存中未找到包，则 NuGet 将尝试从所有已启用的源下载该包。
默认情况下，NuGet 还原操作使用 global-packages 和 http-cache 文件夹中的包。&lt;/p&gt;
&lt;h2 id="section-5"&gt;&lt;a href="https://docs.microsoft.com/zh-cn/nuget/consume-packages/reinstalling-and-updating-packages0"&gt;重装和更新包&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id="section-6"&gt;&lt;a href="https://docs.microsoft.com/zh-cn/nuget/consume-packages/dependency-resolution"&gt;依赖项解析&lt;/a&gt;&lt;/h2&gt;
&lt;h1 id="section-7"&gt;&lt;a href="https://docs.microsoft.com/zh-cn/nuget/create-packages/overview-and-workflow"&gt;创建包&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;{% note info %}
待完善
{% endnote %}&lt;/p&gt;
&lt;h1 id="section-8"&gt;&lt;a href="https://docs.microsoft.com/zh-cn/nuget/hosting-packages/overview"&gt;承载包&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;{% note info %}
待完善
{% endnote %}&lt;/p&gt;
&lt;h1 id="nuget-cli"&gt;&lt;a href="https://docs.microsoft.com/zh-cn/nuget/tools/nuget-exe-cli-reference"&gt;NuGet CLI&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="section-9"&gt;配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;修改和查看配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-cli"&gt;nuget config -Set &amp;lt;name&amp;gt;=[&amp;lt;value&amp;gt;] [&amp;lt;name&amp;gt;=&amp;lt;value&amp;gt; ...] [options]
nuget config -AsPath &amp;lt;name&amp;gt; [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;清除或列出本地 NuGet 资源&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-cli"&gt;nuget locals &amp;lt;folder&amp;gt; [options]

nuget locals all -list
nuget locals http-cache -clear
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;管理源列表&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-cli"&gt;nuget sources &amp;lt;operation&amp;gt; -Name &amp;lt;name&amp;gt; -Source &amp;lt;source&amp;gt;

nuget sources Add -Name &amp;quot;MyServer&amp;quot; -Source \\myserver\packages
nuget sources Disable -Name &amp;quot;MyServer&amp;quot;
nuget source Enable -Name &amp;quot;nuget.org&amp;quot;
nuget sources add -name foo.bar -source C:\NuGet\local -username foo -password bar -StorePasswordInClearText -configfile %AppData%\NuGet\my.config
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;显示来自给定源的包列表&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-cli"&gt;nuget list [search terms] [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-10"&gt;创建&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;打包&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-cli"&gt;nuget pack &amp;lt;nuspecPath | projectPath&amp;gt; [options] [-Properties ...]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;签名&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-cli"&gt;nuget sign &amp;lt;package(s)&amp;gt; [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-11"&gt;推送&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-cli"&gt;nuget pucli &amp;lt;packagePath&amp;gt; [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-12"&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-cli"&gt;nuget install &amp;lt;packageID | configFilePath&amp;gt; [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-13"&gt;还原&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-cli"&gt;nuget restore &amp;lt;projectPath&amp;gt; [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-14"&gt;更新&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-cli"&gt;nuget update &amp;lt;configPath&amp;gt; [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-15"&gt;验证&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-cli"&gt;nuget verify &amp;lt;-All|-Signatures&amp;gt; &amp;lt;package(s)&amp;gt; [options]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-16"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/nuget/what-is-nuget"&gt;An introduction to NuGet&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/progLang-xml</id><title type="text">eXtensible Markup Language</title><summary type="text">基本信息
介绍：XML 被设计用来传输和存储数据，具有自我描述性。
语法
XML 文档形成一种树结构。
所有元素都须有关闭标签。
标签对大小写敏感
必须正确地嵌套
必须包含根元素
属性值须加引号
空格</summary><published>2018-09-02T18:16:01+08:00</published><updated>2018-09-02T18:16:01+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2FprogLang-xml" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;介绍：XML 被设计用来传输和存储数据，具有自我描述性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;语法&lt;/h1&gt;
&lt;p&gt;XML 文档形成一种树结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有元素都须有关闭标签。&lt;/li&gt;
&lt;li&gt;标签对大小写敏感&lt;/li&gt;
&lt;li&gt;必须正确地嵌套&lt;/li&gt;
&lt;li&gt;必须包含根元素&lt;/li&gt;
&lt;li&gt;属性值须加引号&lt;/li&gt;
&lt;li&gt;空格会被保留&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;ISO-8859-1&amp;quot;?&amp;gt;
&amp;lt;root name=&amp;quot;_root&amp;quot;&amp;gt;
  &amp;lt;child&amp;gt;
    &amp;lt;subchild&amp;gt;.....&amp;lt;/subchild&amp;gt;
  &amp;lt;/child&amp;gt;
&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;{% note info %}
元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。
{% endnote %}&lt;/p&gt;
&lt;h2 id="section-2"&gt;特殊字符&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;原字符&lt;/th&gt;
&lt;th&gt;转义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;lt;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;ge;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;amp;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;'&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;apos;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;amp;quot;&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-3"&gt;注释&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;!-- comment --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-4"&gt;元素命名&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;名称可以含字母、数字以及其他的字符&lt;/li&gt;
&lt;li&gt;名称不能以数字或者标点符号开始&lt;/li&gt;
&lt;li&gt;名称不能以字符 “xml”（或者 XML、Xml）开始&lt;/li&gt;
&lt;li&gt;名称不能包含空格&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-5"&gt;命名空间&lt;/h2&gt;
&lt;h3 id="section-6"&gt;定义&lt;/h3&gt;
&lt;p&gt;XML 命名空间属性被放置于元素的开始标签之中，并使用以下的语法：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;xmlns:namespace-prefix=&amp;quot;namespaceURI&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。&lt;/p&gt;
&lt;h3 id="section-7"&gt;使用&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;f:table xmlns:f=&amp;quot;http://www.w3school.com.cn/furniture&amp;quot;&amp;gt;
   &amp;lt;f:name&amp;gt;African Coffee Table&amp;lt;/f:name&amp;gt;
   &amp;lt;f:width&amp;gt;80&amp;lt;/f:width&amp;gt;
   &amp;lt;f:length&amp;gt;120&amp;lt;/f:length&amp;gt;
&amp;lt;/f:table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认命名空间：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;table xmlns=&amp;quot;http://www.w3.org/TR/html4/&amp;quot;&amp;gt;
   &amp;lt;tr&amp;gt;
   &amp;lt;td&amp;gt;Apples&amp;lt;/td&amp;gt;
   &amp;lt;td&amp;gt;Bananas&amp;lt;/td&amp;gt;
   &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="cdata"&gt;CDATA&lt;/h2&gt;
&lt;p&gt;术语 CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。
CDATA 部分中的所有内容都会被解析器忽略。
CDATA 部分由 &lt;strong&gt;&amp;lt;![CDATA[&lt;/strong&gt; 开始，由 &lt;strong&gt;]]&amp;gt;&lt;/strong&gt; 结束。&lt;/p&gt;
&lt;h1 id="xml"&gt;XML 语法描述（验证）&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;DTD&lt;/li&gt;
&lt;li&gt;XML Schema&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="xml-1"&gt;XML 样式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;CSS 样式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml-stylesheet type=&amp;quot;text/css&amp;quot; href=&amp;quot;style.css&amp;quot;?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;XSLT (eXtensible Stylesheet Language Transformations) 样式&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;?xml-stylesheet type=&amp;quot;text/xsl&amp;quot; href=&amp;quot;style.xsl&amp;quot;?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-8"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.w3school.com.cn/xml/index.asp"&gt;XML 教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/apt</id><title type="text">APT - Advanced Packaging Tool</title><summary type="text">基本信息
介绍：apt，Advanced Packaging Tool 是Linux下的一款安装包管理工具。常用于 Debian, Ubuntu 等系统。是 dpkg 的前端。
常用命令
{% not</summary><published>2018-09-19T10:30:40+08:00</published><updated>2018-09-19T10:30:40+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2Fapt" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;介绍：apt，Advanced Packaging Tool 是Linux下的一款安装包管理工具。常用于 Debian, Ubuntu 等系统。是 dpkg 的前端。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;常用命令&lt;/h1&gt;
&lt;p&gt;{% note info %}
很多 apt 命令需要管理员权限。
{% endnote %}&lt;/p&gt;
&lt;h2 id="section-2"&gt;更新数据库&lt;/h2&gt;
&lt;p&gt;安装软件前常需更新软件包数据库，以保证信息是最新的。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;apt update
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-3"&gt;查找&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;apt search &amp;lt;seach name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-4"&gt;查看&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;apt show &amp;lt;package_name&amp;gt; # 查看package内容

apt list # 查看软件包列表
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;list&lt;/code&gt; 选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--upgradeable&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可升级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--installed&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;已安装&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--all&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;系统中所有能找到的package&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-versions&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;所有版本&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-5"&gt;安装&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;apt install &amp;lt;package_name1&amp;gt; &amp;lt;package_name2&amp;gt; ...
apt reinstall &amp;lt;package_name&amp;gt; # 重新安装包
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--no-upgrade&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;安装该package但是不升级&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--only-upgrade&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;升级该package&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;=&amp;lt;version_number&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定版本&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-6"&gt;卸载&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;apt remove &amp;lt;package_name&amp;gt; # 移除该package
apt purge &amp;lt;package_name&amp;gt; # 彻底删除该package（包含配置文件）

apt autoremove # 自动移除部分无用软件包
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;remove&lt;/code&gt; 选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--purge&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除包，包括删除配置文件&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-7"&gt;更新&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;apt upgrade
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-8"&gt;参考资料&lt;/h1&gt;
&lt;p&gt;网络&lt;/p&gt;
</content></entry><entry><id>Tools/powershell</id><title type="text">PowerShell</title><summary type="text">基本信息
官网
介绍：Powershell 是一个执行系统和应用程序管理自动化的命令行脚本环境。需要.NET环境的支持，同时支持.NET对象。Powershell 中每个内容都是对象，.NET 中的对</summary><published>2018-09-27T18:40:02+08:00</published><updated>2018-09-27T18:40:02+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2Fpowershell" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/powershell/powershell"&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍：Powershell 是一个执行系统和应用程序管理自动化的命令行脚本环境。需要.NET环境的支持，同时支持.NET对象。Powershell 中每个内容都是对象，.NET 中的对象相关操作可以在 Powershell 中调用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;基础知识&lt;/h1&gt;
&lt;h2 id="section-2"&gt;快捷键&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;快捷键&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ALT+F7&lt;/td&gt;
&lt;td&gt;清除命令的历史记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PgUp PgDn&lt;/td&gt;
&lt;td&gt;显示当前会话的第一个命令和最后一个命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Enter&lt;/td&gt;
&lt;td&gt;执行当前命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;End&lt;/td&gt;
&lt;td&gt;将光标移至当前命令的末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Del&lt;/td&gt;
&lt;td&gt;从右开始删除输入的命令字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Esc&lt;/td&gt;
&lt;td&gt;清空当前命令行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F2&lt;/td&gt;
&lt;td&gt;自动补充历史命令至指定字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F4&lt;/td&gt;
&lt;td&gt;删除命令行至光标右边指定字符处&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F7&lt;/td&gt;
&lt;td&gt;对话框显示命令行历史记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F8&lt;/td&gt;
&lt;td&gt;检索包含指定字符的命令行历史记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;F9&lt;/td&gt;
&lt;td&gt;根据命令行的历史记录编号选择命令，历史记录编号可以通过F7查看&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;左/右方向键&lt;/td&gt;
&lt;td&gt;左右移动光标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;上/下方向键&lt;/td&gt;
&lt;td&gt;切换命令行的历史记录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Home&lt;/td&gt;
&lt;td&gt;光标移至命令行最左端&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Backspace&lt;/td&gt;
&lt;td&gt;从右删除命令行字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+C&lt;/td&gt;
&lt;td&gt;取消正在执行的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+左/右方向键&lt;/td&gt;
&lt;td&gt;在单词之间移动光标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Ctrl+Home&lt;/td&gt;
&lt;td&gt;删除光标最左端的所有字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Tab&lt;/td&gt;
&lt;td&gt;自动补齐命令或者文件名&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-3"&gt;管道和重定向&lt;/h2&gt;
&lt;p&gt;管道：把上一条命令的输出作为下一条命令的输入。使用字符 &lt;code&gt;|&lt;/code&gt;。
传统的Cmd管道是基于文本的，但是Powershell是基于对象。&lt;/p&gt;
&lt;p&gt;两个管道模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;顺序模式（较慢）：在顺序模式中管道中同一时间只执行一条命令，只有当前一条命令的所有执行完毕，才会把所有结果交付给下一条 命令。这种模式速度慢并且耗内存，因为必须需要很多次分配空间存储中间结果。&lt;/li&gt;
&lt;li&gt;流模式（较快）：流模式会立即执行所有命令，同一时间可能在执行多条命令。前一条命令可能会产生多个结果，但是一旦产生其中一个结果，就会立即交付给下一条命令处理。这样的流模式节省比较节省内-存，可能管道的某个任务还在执行，但是已经有部分结果输出了。减少了中间结果的保存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重定向：把命令的输出保存到文件中，&lt;code&gt;&amp;gt;&lt;/code&gt; 为覆盖，&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 追加。&lt;/p&gt;
&lt;h2 id="section-4"&gt;数学运算&lt;/h2&gt;
&lt;p&gt;Powershell 支持基本的数学运算，也能自动识别计算机容量单位，包括KB，MB，GB，TB，PB。通过使用 .NET 中的数学库可以使用更多的数学函数。&lt;/p&gt;
&lt;h2 id="section-5"&gt;执行外部命令&lt;/h2&gt;
&lt;p&gt;调用外部程序。类似传统 shell。&lt;/p&gt;
&lt;h2 id="cmdlets"&gt;Cmdlets&lt;/h2&gt;
&lt;p&gt;cmdlets是Powershell的内部命令。每个命令有一个动词和名词组成，命令的作用一目了然。
&lt;strong&gt;可以使用 &lt;code&gt;Get-Command&lt;/code&gt; 获取所有命令，使用 &lt;code&gt;Get-Help&lt;/code&gt; 获取命令帮助。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常用命令：
|命令|别名|
|-|-|
|&lt;code&gt;Get-Location&lt;/code&gt;|&lt;code&gt;pwd&lt;/code&gt;|
|&lt;code&gt;Set-Location&lt;/code&gt;|&lt;code&gt;cd&lt;/code&gt;|
|&lt;code&gt;Get-ChildrenItem&lt;/code&gt;|&lt;code&gt;ls&lt;/code&gt; &lt;code&gt;dir&lt;/code&gt;|
|&lt;code&gt;Invoke-Item&lt;/code&gt;||
|&lt;code&gt;Remove-Item&lt;/code&gt;|&lt;code&gt;rm&lt;/code&gt; &lt;code&gt;del&lt;/code&gt;|
|&lt;code&gt;Move-Item&lt;/code&gt;|&lt;code&gt;mv&lt;/code&gt; &lt;code&gt;move&lt;/code&gt;|
|&lt;code&gt;Copy-Item&lt;/code&gt;|&lt;code&gt;cp&lt;/code&gt; &lt;code&gt;copy&lt;/code&gt;|
|&lt;code&gt;Get-Item&lt;/code&gt;||
|&lt;code&gt;Get-Content&lt;/code&gt;|&lt;code&gt;cat&lt;/code&gt;|
|&lt;code&gt;Invoke-WebRequest&lt;/code&gt;|&lt;code&gt;wget&lt;/code&gt; &lt;code&gt;curl&lt;/code&gt;|
|&lt;code&gt;Get-Process&lt;/code&gt;|&lt;code&gt;ps&lt;/code&gt;|
|&lt;code&gt;Stop-Process&lt;/code&gt;|&lt;code&gt;kill&lt;/code&gt;|
|&lt;code&gt;Start-Process&lt;/code&gt;|&lt;code&gt;start&lt;/code&gt;|
|&lt;code&gt;Clear-Host&lt;/code&gt;|&lt;code&gt;cls&lt;/code&gt; &lt;code&gt;clear&lt;/code&gt;|
|&lt;code&gt;Write-Output&lt;/code&gt;|&lt;code&gt;echo&lt;/code&gt;|
|&lt;code&gt;Compare-Object&lt;/code&gt;|&lt;code&gt;diff&lt;/code&gt;|&lt;/p&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h2 id="section-6"&gt;别名&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Get-Alias&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set-Alias&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Export-Alias&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Import-Alias&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-7"&gt;变量&lt;/h2&gt;
&lt;p&gt;变量名均是以美元符 &lt;code&gt;$&lt;/code&gt; 开始，剩余字符可以是数字、字母、下划线的任意字符，并且powershell变量名大小写不敏感。某些特殊的字符在powershell中有特殊的用途，一般不推荐使用这些字符作为变量名。当然你硬要使用，请把整个变量名后缀用花括号括起来。
Powershell将变量的相关信息的记录存放在名为 &lt;code&gt;variable:&lt;/code&gt; 的驱动中。如果要查看所有定义的变量，可以直接遍历 &lt;code&gt;variable:&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;$a = 10
$b = 4
$result = $a * $b
$a,$b = $b,$a
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Clear-Variable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Get-Variable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;New-Variable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Remove-Variable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Set-Variable&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Powershell 自动化变量 是那些一旦打开Powershell就会自动加载的变量。这些变量一般存放的内容包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户信息：例如用户的根目录$home&lt;/li&gt;
&lt;li&gt;配置信息:例如powershell控制台的大小，颜色，背景等。&lt;/li&gt;
&lt;li&gt;运行时信息：例如一个函数由谁调用，一个脚本运行的目录等。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-8"&gt;数组&lt;/h2&gt;
&lt;p&gt;创建数组可以使用逗号，或使用完整表示 &lt;code&gt;@()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;$nums = 2,0,1,2
$nums = 1..5
$array = 1,&amp;quot;2012世界末日&amp;quot;,([System.Guid]::NewGuid()),(get-date)

$a=@() # empty
$a=,&amp;quot;moss&amp;quot; # one element
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数组的元素可以使用索引寻址，第一个元素的索引为0，第i个元素的索引为i-1，最后一个元素的索引为Count-1，但是Powershell为了使用方便，直接可以将 -1 作为最后的一个元素的索引。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;$books[0]
$books[-1]
$result[0,3,5,12] # multi-element
$books[($books.Count)..0] # reverse

$books += &amp;quot;元素4&amp;quot; # append
$num = $num[0..1]+$num[3] # remove $num[2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Powershell数组一般具有多态性，如果你不指定元素的具体类型，解释器会自动选择合适的类型存储每个元素。如果要统一限制所有元素的类型，可是使用类型名和一对方括号作为数组变量的类型。这样每当赋值时，会自动类型检查。如果目标数据类型不能转换成功，就会抛出一个异常。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;[int[]] $nums=@()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-9"&gt;哈希表&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;@{}&lt;/code&gt; 创建哈希表（类似 .NET 中 Dictionary）。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;$stu = @{ Name = &amp;quot;小明&amp;quot;;Age=&amp;quot;12&amp;quot;;sex=&amp;quot;男&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-10"&gt;管道应用&lt;/h1&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h1 id="section-11"&gt;对象&lt;/h1&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h1 id="section-12"&gt;分支&lt;/h1&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h1 id="section-13"&gt;循环&lt;/h1&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h1 id="section-14"&gt;函数&lt;/h1&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h1 id="section-15"&gt;脚本&lt;/h1&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h1 id="section-16"&gt;模块&lt;/h1&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h1 id="section-17"&gt;文本匹配&lt;/h1&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h1 id="section-18"&gt;文件系统&lt;/h1&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h1 id="section-19"&gt;工作流&lt;/h1&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h1 id="section-20"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/powershell/"&gt;PowerShell Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.pstips.net/powershell-online-tutorials"&gt;PowerShell 教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/vim</id><title type="text">Vim</title><summary type="text">基本信息
官网
介绍：Vim 是一个功能非常强大，且具有很强扩展性的编辑器。
安装
apt install vim
基础
i 插入模式（当前字符之前）
h j k l 四方向移动
x 删除当前字符
d</summary><published>2018-09-06T10:20:00+08:00</published><updated>2018-09-06T10:20:00+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2Fvim" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.vim.org/"&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍：Vim 是一个功能非常强大，且具有很强扩展性的编辑器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;安装&lt;/h1&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;apt install vim
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-2"&gt;基础&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;i&lt;/code&gt; 插入模式（当前字符之前）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h j k l&lt;/code&gt; 四方向移动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; 删除当前字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dd&lt;/code&gt; 删除当前行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt; 删除换行符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; 撤销&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+R&lt;/code&gt; 重做&lt;/li&gt;
&lt;li&gt;&lt;code&gt;U&lt;/code&gt; 撤销当前行的所有操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a&lt;/code&gt; 插入模式（当前字符之后）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;I&lt;/code&gt; 移动前行第一个非空字符，进入插入模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A&lt;/code&gt; 移动到行尾字符，进入插入模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt; 下方建立新行，进入插入模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O&lt;/code&gt; 上方建立新行，进入插入模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-3"&gt;移动&lt;/h1&gt;
&lt;p&gt;{% note success %}
计数+动作=多次执行
{% endnote %}&lt;/p&gt;
&lt;h2 id="section-4"&gt;词移动&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;w b&lt;/code&gt; 到前/后词首&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e ge&lt;/code&gt; 到前/后词尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;W B&lt;/code&gt; 到前/后词首&lt;/li&gt;
&lt;li&gt;&lt;code&gt;E gE&lt;/code&gt; 到前/后词尾&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-5"&gt;行中移动&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; 行尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; 第一个非空字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;O&lt;/code&gt; 行首&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-6"&gt;行中指定字符&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;fx Fx&lt;/code&gt; 向前/后字符x&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tx Tx&lt;/code&gt; 向前/后字符x前&lt;/li&gt;
&lt;li&gt;&lt;code&gt;;&lt;/code&gt; 重复上个命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;,&lt;/code&gt; 反向重复上个命令&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-7"&gt;匹配括号&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-8"&gt;指定行&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;2G&lt;/code&gt; 第二行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt; 文件末&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gg&lt;/code&gt; 文件首&lt;/li&gt;
&lt;li&gt;&lt;code&gt;50%&lt;/code&gt; 移动到文本的50%位置&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-9"&gt;滚屏&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl+U/D&lt;/code&gt; 上/下半屏&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+E/Y&lt;/code&gt; 上/下一行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+F/B&lt;/code&gt; 上/下一屏&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zz&lt;/code&gt; 光标到中间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zt&lt;/code&gt; 光标到顶部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zb&lt;/code&gt; 光标到底部&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-10"&gt;查找&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/str&lt;/code&gt; 查找下一个 &lt;code&gt;str&lt;/code&gt;，支持方向键访问历史，历史模式匹配&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 下一个匹配项&lt;/li&gt;
&lt;li&gt;&lt;code&gt;?str&lt;/code&gt; 查找上一个 &lt;code&gt;str&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;N&lt;/code&gt; 反方向重复前一次查找&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:set [no]ignorecase&lt;/code&gt; 大小写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; 查找当前单词的下一个（全字匹配）
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g*&lt;/code&gt; 非全字匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 查找当前单词的上一个（全字匹配）
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;g#&lt;/code&gt; 非全字匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:set [no]hlsearch&lt;/code&gt; 高亮&lt;/li&gt;
&lt;li&gt;特殊记号：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\&amp;gt;&lt;/code&gt; 匹配单次末尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\&amp;lt;&lt;/code&gt; 匹配单次开头&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^&lt;/code&gt; 行首&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$&lt;/code&gt; 行尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 单个字符&lt;/li&gt;
&lt;li&gt;反斜杠取消转义&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-11"&gt;标记&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;`` ''&lt;/code&gt; 跳转回上次跳转前的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl-O&lt;/code&gt; 跳到一个较老的地方&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl-I&lt;/code&gt; 跳到一个较新的地方&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:jumps&lt;/code&gt; 查看跳转位置列表&lt;/li&gt;
&lt;li&gt;自定义标记：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ma&lt;/code&gt; 用 a 标记当前位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;`a&lt;/code&gt; 跳到 a 标记的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;‘a&lt;/code&gt; 跳到 a 标记的行的行首&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:marks&lt;/code&gt; 查看标记列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预定义标记：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;'&lt;/code&gt; 跳转前的光标位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;&lt;/code&gt; 最后编辑的光标位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[&lt;/code&gt; 最后修改的开始位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;]&lt;/code&gt; 最后修改的结束位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-12"&gt;文本对象&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;For more: text-objects&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;aw&lt;/code&gt; = A word&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is&lt;/code&gt; = Inner sentence&lt;/li&gt;
&lt;li&gt;&lt;code&gt;as&lt;/code&gt; = A sentence&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-13"&gt;改动&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 改变当前字符大小写，并移动到下个字符（不是操作符，不能连接一个动作命令，但在可视模式中可范围作用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% note info %}
删除等操作的文本会被存储到寄存器中
{% endnote %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt; 删除操作符
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;dd&lt;/code&gt; 删除当前行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; 修改（删除+进入插入模式）操作符
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cc&lt;/code&gt; 修改当前行（仅保留缩进）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; =&lt;code&gt;dl&lt;/code&gt;，删除当前光标字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt; =&lt;code&gt;dh&lt;/code&gt;，删除当前光标左边字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;D&lt;/code&gt; =&lt;code&gt;d$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;C&lt;/code&gt; =&lt;code&gt;c$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; =&lt;code&gt;cl&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt; =&lt;code&gt;cc&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rx&lt;/code&gt; 使用字符x替换当前字符
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;4rx&lt;/code&gt; 删除4个字符，插入x&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 重复上一次修改操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; 当前光标处插入寄存器的内容，配合计数可复制多次
&lt;ul&gt;
&lt;li&gt;通过对第一个字符执行 &lt;code&gt;xp&lt;/code&gt; 实现交换其与其后字符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;P&lt;/code&gt; 当前光标前插入寄存器的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;y&lt;/code&gt; 将当前文本存储到寄存器中
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Y yy&lt;/code&gt; 拷贝一整行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在支持剪切板的vim中（clipboard）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;y p&lt;/code&gt; 命令前加入 &lt;code&gt;&amp;quot;*&lt;/code&gt; 实现对剪贴板的操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% note success %}
操作符+动作模式/文本对象=区域操作
{% endnote %}&lt;/p&gt;
&lt;h1 id="section-14"&gt;模式&lt;/h1&gt;
&lt;h2 id="section-15"&gt;可视模式&lt;/h2&gt;
&lt;p&gt;{% note default %}
选择一部分，按操作符
{% endnote %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;v&lt;/code&gt; 普通可视模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;V&lt;/code&gt; 按行可视模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+V&lt;/code&gt; 区块可视模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o O&lt;/code&gt; 移动到选中区域的另一端（或对角）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-16"&gt;替换模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;R&lt;/code&gt; 替换模式（覆盖原文本）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-17"&gt;编辑&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl+P&lt;/code&gt; 猜测补全&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-18"&gt;离开和继续&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Ctrl+Z :suspend&lt;/code&gt; 挂起，回到shell&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fg&lt;/code&gt; 从挂起状态恢复&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:!{command}&lt;/code&gt; 执行单个外壳命令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:!ls&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:mksession vimbook.vim&lt;/code&gt; 创建一个会话文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:source vimbook.vim&lt;/code&gt; 还原会话
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vim -S vimbook.vim&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-19"&gt;文件&lt;/h1&gt;
&lt;p&gt;命令后缀 &lt;code&gt;!&lt;/code&gt; 表示强制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:quit :q&lt;/code&gt; 退出&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:enter :e&lt;/code&gt; 装载当前文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:edit filename&lt;/code&gt; 关闭当前文件，打开指定文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:write :w&lt;/code&gt; 写入当前文件
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:wall&lt;/code&gt; 全部存盘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:saveas a&lt;/code&gt; 另存为a&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:file a&lt;/code&gt; 改变当前文件名，但不保存（且原文件不受影响）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vim a b c&lt;/code&gt; 打开多个文件（先进入第一个）
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:next&lt;/code&gt; 进入下个文件
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:wnext&lt;/code&gt; 等价于 &lt;code&gt;:write &amp;amp; :next&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:previous&lt;/code&gt; 进入上个文件
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;:wprevious&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:last&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:first&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:args&lt;/code&gt; 查看打开文件列表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:args a b c&lt;/code&gt; 打开多个文件（支持通配符，如 &lt;code&gt;*.txt&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Ctrl+^&lt;/code&gt; 两个文件间快速跳转&lt;/li&gt;
&lt;li&gt;标记：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;quot;&lt;/code&gt; 上次离开此文件的位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 最后一次修改的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-20"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/yianwillis/vimcdoc"&gt;vimcdoc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/make</id><title type="text">Make</title><summary type="text">基本信息
官网
介绍：一个能处理依赖关系，进行自动化编译的工具。
make 不仅可以用于处理程序编译过程，也可以处理更多的含依赖关系的事务
基础知识
GNU的 make 工作时的执行步骤如下：
读入所</summary><published>2018-09-16T18:58:19+08:00</published><updated>2018-09-16T18:58:19+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2Fmake" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.gnu.org/software/make/"&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍：一个能处理依赖关系，进行自动化编译的工具。&lt;/li&gt;
&lt;li&gt;make 不仅可以用于处理程序编译过程，也可以处理更多的含依赖关系的事务&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;基础知识&lt;/h1&gt;
&lt;p&gt;GNU的 make 工作时的执行步骤如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读入所有的Makefile。&lt;/li&gt;
&lt;li&gt;读入被include的其它Makefile。&lt;/li&gt;
&lt;li&gt;初始化文件中的变量。&lt;/li&gt;
&lt;li&gt;推导隐晦规则，并分析所有规则。&lt;/li&gt;
&lt;li&gt;为所有的目标文件创建依赖关系链。&lt;/li&gt;
&lt;li&gt;根据依赖关系，决定哪些目标要重新生成。&lt;/li&gt;
&lt;li&gt;执行生成命令。&lt;/li&gt;
&lt;/ol&gt;
</content></entry><entry><id>Tools/progLang-html</id><title type="text">Hyper Text Markup Language</title><summary type="text">基本信息
介绍：一种描述网页的标记语言。
相关：XHTML（可扩展超文本标记语言，更严格更纯净的 HTML 版本）
语法
HTML 文档描述网页
HTML 文档包含 HTML 标签和纯文本
HTML </summary><published>2018-09-06T14:16:00+08:00</published><updated>2018-09-06T14:16:00+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2FprogLang-html" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;介绍：一种描述网页的标记语言。&lt;/li&gt;
&lt;li&gt;相关：XHTML（可扩展超文本标记语言，更严格更纯净的 HTML 版本）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;语法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;HTML 文档描述网页
&lt;ul&gt;
&lt;li&gt;HTML 文档包含 HTML 标签和纯文本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTML 标记标签通常被称为 HTML 标签。
&lt;ul&gt;
&lt;li&gt;HTML 标签是由尖括号包围的关键词，比如 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;HTML 标签通常是成对出现的，比如 &lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;/b&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标签对中的第一个标签是开始标签，第二个标签是结束标签&lt;/li&gt;
&lt;li&gt;开始和结束标签也被称为开放标签和闭合标签&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。
&lt;ul&gt;
&lt;li&gt;HTML 元素以开始标签起始&lt;/li&gt;
&lt;li&gt;HTML 元素以结束标签终止&lt;/li&gt;
&lt;li&gt;元素的内容是开始标签与结束标签之间的内容&lt;/li&gt;
&lt;li&gt;某些 HTML 元素具有空内容（empty content）&lt;/li&gt;
&lt;li&gt;空元素在开始标签中进行关闭（以开始标签的结束而结束）&lt;/li&gt;
&lt;li&gt;大多数 HTML 元素可拥有属性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。
&lt;ul&gt;
&lt;li&gt;属性总是以名称/值对的形式出现，比如：&lt;code&gt;name=&amp;quot;value&amp;quot;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;属性总是在 HTML 元素的开始标签中规定。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTML 块元素：块级元素在浏览器显示时，通常会以新行来开始（和结束）。&lt;/li&gt;
&lt;li&gt;HTML 内联元素：内联元素在显示时通常不会以新行开始。&lt;/li&gt;
&lt;li&gt;颜色：&lt;code&gt;#000000&lt;/code&gt; = &lt;code&gt;rgb(0,0,0)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;!DOCTYPE&amp;gt;&lt;/code&gt; 指定 HTML 版本&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://www.w3school.com.cn/tags/html_ref_entities.html"&gt;特殊字符&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="section-2"&gt;文档结构&lt;/h1&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
        
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;

    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-3"&gt;头部&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 元素是所有头部元素的容器。&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 内的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息，等等。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文档的标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;为页面上的所有链接规定默认地址或默认目标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文档与外部资源之间的关系&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;样式信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;客户端脚本&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Title of the document&amp;lt;/title&amp;gt;
    &amp;lt;base href=&amp;quot;http://www.w3school.com.cn/images/&amp;quot; /&amp;gt;
    &amp;lt;base target=&amp;quot;_blank&amp;quot; /&amp;gt;
    &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;mystyle.css&amp;quot; /&amp;gt;
    &amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
        body {background-color:yellow}
        p {color:blue}
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-4"&gt;常用标签&lt;/h1&gt;
&lt;h2 id="section-5"&gt;分隔&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;hr /&amp;gt;&lt;/code&gt; 水平线&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;br /&amp;gt;&lt;/code&gt; 换行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-6"&gt;注释&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;!-- This is a comment --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-7"&gt;语义&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文档或节的页眉&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;导航链接的容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;section&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文档中的节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;独立的自包含文章&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;aside&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内容之外的内容（比如侧栏）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文档或节的页脚&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;details&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;额外的细节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;summary&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;details 元素的标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;bdi&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;与其他文本不同的文本方向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;dialog&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对话框或窗口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;figure&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;自包含内容，比如图示、图表、照片、代码清单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;main&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文档的主内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;mark&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;重要或强调的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;menuitem&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用户能够从弹出菜单调用的命令/菜单项目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;meter&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;已知范围（尺度）内的标量测量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;progress&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;任务进度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;time&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日期/时间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;wbr&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可能的折行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-8"&gt;文本&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;-&lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标题&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;段落&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;粗体文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;big&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;大号字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;着重文字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;斜体字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;small&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;小号字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;加重语气&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;sub&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下标字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;sup&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;上标字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;ins&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;插入字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;del&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;code&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;计算机代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;kbd&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;键盘码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;samp&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;计算机代码样本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;tt&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打字机代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;var&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;预格式文本&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;abbr&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;缩写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;acronym&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;首字母缩写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;address&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;bdo&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文字方向&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;长的引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;q&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;短的引用语&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;cite&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;引用、引证&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;dfn&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;一个定义项目&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;超链接&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;a href=&amp;quot;url&amp;quot; target=&amp;quot;_blank&amp;quot; name=&amp;quot;name&amp;quot;&amp;gt;text&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-9"&gt;列表&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;无序列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有序列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;dl&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;自定义列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;dt&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;自定义列表项头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;dd&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;自定义列表项内容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-10"&gt;表格&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;定义表格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;th&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表头&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单元格数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;table border=&amp;quot;1&amp;quot;&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;th&amp;gt;Heading&amp;lt;/th&amp;gt;
        &amp;lt;th&amp;gt;Another Heading&amp;lt;/th&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;row 1, cell 1&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;row 1, cell 2&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
    &amp;lt;tr&amp;gt;
        &amp;lt;td&amp;gt;row 2, cell 1&amp;lt;/td&amp;gt;
        &amp;lt;td&amp;gt;row 2, cell 2&amp;lt;/td&amp;gt;
    &amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-11"&gt;表单&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 元素。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;标签&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;多种类型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;select&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下拉列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;textarea&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;多行输入字段（文本域）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;button&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按钮&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;datalist&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;为 &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 元素规定预定义选项列表&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; 输入类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;text&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;供文本输入的单行输入字段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;password&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;密码字段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;radio&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单选按钮&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;checkbox&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;复选框&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;submit&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;提交表单数据至表单处理程序的按钮&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;button&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按钮&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;color&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;颜色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;date&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日期&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日期和时间（有时区）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;datetime-local&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;日期和时间（无时区）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;month&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;月份和年份&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;week&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;周和年&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;time&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;选择时间（无时区）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;number&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;数字值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;range&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;一定范围内的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;email&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;电子邮件地址的输入字段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;search&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;搜索字段（搜索字段的表现类似常规文本字段）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;tel&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;电话号码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;url&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;URL 地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;form action=&amp;quot;action_page.php&amp;quot; method=&amp;quot;GET&amp;quot;&amp;gt;
    First name:&amp;lt;br/&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;firstname&amp;quot; value=&amp;quot;Mickey&amp;quot;&amp;gt;&amp;lt;br&amp;gt;
    Last name:&amp;lt;br/&amp;gt;&amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;lastname&amp;quot; value=&amp;quot;Mouse&amp;quot;&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Submit&amp;quot;&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;select name=&amp;quot;cars&amp;quot;&amp;gt;
    &amp;lt;option value=&amp;quot;volvo&amp;quot;&amp;gt;Volvo&amp;lt;/option&amp;gt;
    &amp;lt;option value=&amp;quot;saab&amp;quot;&amp;gt;Saab&amp;lt;/option&amp;gt;
    &amp;lt;option value=&amp;quot;fiat&amp;quot;&amp;gt;Fiat&amp;lt;/option&amp;gt;
    &amp;lt;option value=&amp;quot;audi&amp;quot;&amp;gt;Audi&amp;lt;/option&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;input list=&amp;quot;browsers&amp;quot;&amp;gt;
&amp;lt;datalist id=&amp;quot;browsers&amp;quot;&amp;gt;
   &amp;lt;option value=&amp;quot;Internet Explorer&amp;quot;&amp;gt;
   &amp;lt;option value=&amp;quot;Firefox&amp;quot;&amp;gt;
   &amp;lt;option value=&amp;quot;Chrome&amp;quot;&amp;gt;
   &amp;lt;option value=&amp;quot;Opera&amp;quot;&amp;gt;
   &amp;lt;option value=&amp;quot;Safari&amp;quot;&amp;gt;
&amp;lt;/datalist&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-12"&gt;媒体&lt;/h2&gt;
&lt;h3 id="section-13"&gt;绘图&lt;/h3&gt;
&lt;p&gt;HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。
画布是一个矩形区域，您可以控制其每一像素。
canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;canvas id=&amp;quot;myCanvas&amp;quot; width=&amp;quot;200&amp;quot; height=&amp;quot;100&amp;quot;&amp;gt;&amp;lt;/canvas&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;内联 SVG：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;svg xmlns=&amp;quot;http://www.w3.org/2000/svg&amp;quot; version=&amp;quot;1.1&amp;quot; height=&amp;quot;190&amp;quot;&amp;gt;
    &amp;lt;polygon points=&amp;quot;100,10 40,180 190,60 10,60 160,180&amp;quot; style=&amp;quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&amp;quot; /&amp;gt;
&amp;lt;/svg&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;Canvas
&lt;ul&gt;
&lt;li&gt;依赖分辨率&lt;/li&gt;
&lt;li&gt;不支持事件处理器&lt;/li&gt;
&lt;li&gt;弱的文本渲染能力&lt;/li&gt;
&lt;li&gt;能够以 .png 或 .jpg 格式保存结果图像&lt;/li&gt;
&lt;li&gt;最适合图像密集型的游戏，其中的许多对象会被频繁重绘&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;SVG
&lt;ul&gt;
&lt;li&gt;不依赖分辨率&lt;/li&gt;
&lt;li&gt;支持事件处理器&lt;/li&gt;
&lt;li&gt;最适合带有大型渲染区域的应用程序（比如谷歌地图）&lt;/li&gt;
&lt;li&gt;复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）&lt;/li&gt;
&lt;li&gt;不适合游戏应用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="section-14"&gt;图像&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;img src=&amp;quot;url&amp;quot; alt=&amp;quot;text&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-15"&gt;音频&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;audio controls=&amp;quot;controls&amp;quot; height=&amp;quot;100&amp;quot; width=&amp;quot;100&amp;quot;&amp;gt;
    &amp;lt;source src=&amp;quot;song.mp3&amp;quot; type=&amp;quot;audio/mp3&amp;quot; /&amp;gt;
    &amp;lt;source src=&amp;quot;song.ogg&amp;quot; type=&amp;quot;audio/ogg&amp;quot; /&amp;gt;
    &amp;lt;embed height=&amp;quot;100&amp;quot; width=&amp;quot;100&amp;quot; src=&amp;quot;song.mp3&amp;quot; /&amp;gt;
&amp;lt;/audio&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-16"&gt;视频&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;video width=&amp;quot;320&amp;quot; height=&amp;quot;240&amp;quot; controls=&amp;quot;controls&amp;quot;&amp;gt;
    &amp;lt;source src=&amp;quot;movie.mp4&amp;quot; type=&amp;quot;video/mp4&amp;quot; /&amp;gt;
    &amp;lt;source src=&amp;quot;movie.ogg&amp;quot; type=&amp;quot;video/ogg&amp;quot; /&amp;gt;
    &amp;lt;source src=&amp;quot;movie.webm&amp;quot; type=&amp;quot;video/webm&amp;quot; /&amp;gt;
    &amp;lt;object data=&amp;quot;movie.mp4&amp;quot; width=&amp;quot;320&amp;quot; height=&amp;quot;240&amp;quot;&amp;gt;
        &amp;lt;embed src=&amp;quot;movie.swf&amp;quot; width=&amp;quot;320&amp;quot; height=&amp;quot;240&amp;quot; /&amp;gt;
    &amp;lt;/object&amp;gt;
&amp;lt;/video&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-17"&gt;网页&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;iframe src=&amp;quot;demo_iframe.htm&amp;quot; width=&amp;quot;200&amp;quot; height=&amp;quot;200&amp;quot;&amp;gt;&amp;lt;/iframe&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-18"&gt;分块&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 块元素，可容纳其他元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; 内联元素，可容纳其他元素&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-19"&gt;更多&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; 插件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;embed&amp;gt;&lt;/code&gt; 外部（非 HTML）内容的容器&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-20"&gt;元素属性&lt;/h1&gt;
&lt;p&gt;共有属性：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性名&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;class&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对元素分类&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;元素唯一标识符&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id="section-21"&gt;脚本&lt;/h1&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
    document.write(&amp;quot;Hello World!&amp;quot;)
&amp;lt;/script&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;url&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-22"&gt;样式&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;在文档头部引用外部样式表&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;link rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text/css&amp;quot; href=&amp;quot;mystyle.css&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;在文档头部使用内部样式表&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-html"&gt;&amp;lt;style type=&amp;quot;text/css&amp;quot;&amp;gt;
    body {background-color: red}
    p {margin-left: 20px}
&amp;lt;/style&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;使用元素的 &lt;code&gt;style&lt;/code&gt; 属性设置内联样式&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-23"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.w3school.com.cn/html/index.asp"&gt;HTML 教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Tools/git</id><title type="text">Git</title><summary type="text">基本信息
官网
介绍：一个分布式版本管理系统。
特点
Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快</summary><published>2018-09-26T18:58:19+08:00</published><updated>2018-09-26T18:58:19+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Tools%2Fgit" /><category term="Tools" /><content type="html">&lt;h1 id="section"&gt;基本信息&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://git-scm.com/"&gt;官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;介绍：一个分布式版本管理系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;特点&lt;/h1&gt;
&lt;p&gt;Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个快照流。Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具。
在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。
Git 中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。Git 用以计算校验和的机制叫做 SHA-1 散列。实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。
你执行的 Git 操作，几乎只往 Git 数据库中增加数据。很难让 Git 执行任何不可逆操作，或者让它以任何方式清 除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。&lt;/p&gt;
&lt;h1 id="section-2"&gt;基础知识&lt;/h1&gt;
&lt;p&gt;Git 有三种状态，你的文件可能处 于其中之一：&lt;strong&gt;已提交&lt;/strong&gt;（committed）、&lt;strong&gt;已修改&lt;/strong&gt;（modified）和&lt;strong&gt;已暂存&lt;/strong&gt;（staged）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;已提交表示数据已经安全的保存在本地数据库中。&lt;/li&gt;
&lt;li&gt;已修改表示修改了文件，但还没保存到数据库中。&lt;/li&gt;
&lt;li&gt;已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此引入 Git 项目的三个工作区域的概念：&lt;strong&gt;Git 仓库&lt;/strong&gt;、&lt;strong&gt;工作目录&lt;/strong&gt;以及&lt;strong&gt;暂存区域&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。&lt;/li&gt;
&lt;li&gt;工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。&lt;/li&gt;
&lt;li&gt;暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作索引，不过一般说法还是叫暂存区域。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本的 Git 工作流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在工作目录中修改文件。&lt;/li&gt;
&lt;li&gt;暂存文件，将文件的快照放入暂存区域。&lt;/li&gt;
&lt;li&gt;提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果 Git 目录中保存着的特定版本文件，就属于已提交状态。如果作了修改并已放入暂存区域，就属于已暂存状 态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。&lt;/p&gt;
&lt;p&gt;有三种方法可以找到 Git 命令的使用手册：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git help &amp;lt;verb&amp;gt;
git &amp;lt;verb&amp;gt; --help
man git-&amp;lt;verb&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-3"&gt;配置&lt;/h1&gt;
&lt;p&gt;使用 &lt;code&gt;git config&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;控制 Git 外观和行为的配置变量存储在三个不同的位置（每一个级别覆盖上一级别的配置）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;/etc/gitconfig&lt;/code&gt; 包含系统上每一个用户及他们仓库的通用配置。通过 &lt;code&gt;--system&lt;/code&gt; 访问和修改。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~/.gitconfig&lt;/code&gt; 或 &lt;code&gt;~/.config/git/config&lt;/code&gt; 只针对当前用户。通过 &lt;code&gt;--global&lt;/code&gt; 访问和修改。&lt;/li&gt;
&lt;li&gt;当前使用仓库的 Git 目录中的 config 文件（就是 &lt;code&gt;.git/config&lt;/code&gt;）：针对该仓库。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用 &lt;code&gt;--list&lt;/code&gt; 选项查看所有配置。使用 &lt;code&gt;git config &amp;lt;key&amp;gt;&lt;/code&gt; 查看某一项配置，使用 &lt;code&gt;git config &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt; 修改某一项配置，&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git config --global user.name &amp;quot;John Doe&amp;quot;
git config --global user.email johndoe@example.com 
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;设置项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;user.name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;user.email&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;邮箱&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;core.editor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;默认文本编辑器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;{% note info %}
当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改。
{% endnote %}&lt;/p&gt;
&lt;h2 id="section-4"&gt;指定忽略文件&lt;/h2&gt;
&lt;p&gt;修改项目根目录下的 &lt;code&gt;.gitignore&lt;/code&gt; 文件，列出要忽略的文件模式。&lt;/p&gt;
&lt;p&gt;文件 &lt;code&gt;.gitignore&lt;/code&gt; 的格式规范如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有空行或者以 &lt;code&gt;#&lt;/code&gt; 开头的行都会被 Git 忽略。&lt;/li&gt;
&lt;li&gt;可以使用标准的 glob 模式匹配。&lt;/li&gt;
&lt;li&gt;匹配模式可以以（&lt;code&gt;/&lt;/code&gt;）开头防止递归。&lt;/li&gt;
&lt;li&gt;匹配模式可以以（&lt;code&gt;/&lt;/code&gt;）结尾指定目录。&lt;/li&gt;
&lt;li&gt;要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（&lt;code&gt;!&lt;/code&gt;）取反。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% note info%}
Github 上提供的一些 &lt;code&gt;.gitignore&lt;/code&gt; 文件：https://github.com/github/gitignore
{% endnote %}&lt;/p&gt;
&lt;h2 id="section-5"&gt;别名&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git config --global alias.&amp;lt;newname&amp;gt; &amp;lt;originname&amp;gt;

git config --global alias.visual '!gitk'
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git 只是简单地将别名替换为对应的命令。然而，你可能想要执行外部命令，而不是一个 Git 子命令。如果是那样的话，可以在命令前面加入 &lt;code&gt;!&lt;/code&gt; 符号。&lt;/p&gt;
&lt;h1 id="section-6"&gt;获取仓库&lt;/h1&gt;
&lt;h2 id="section-7"&gt;在现有目录中初始化仓库&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git init
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-8"&gt;克隆现有的仓库&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git clone [url]

git clone https://github.com/libgit2/libgit2 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git 支持多种数据传输协议。上面的例子使用的是 &lt;code&gt;https://&lt;/code&gt; 协议，不过你也可以使用 &lt;code&gt;git://&lt;/code&gt; 协议或者使用 SSH 传输协议，比如 &lt;code&gt;user@server:path/to/repo.git &lt;/code&gt;&lt;/p&gt;
&lt;h1 id="section-9"&gt;查看状态&lt;/h1&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git status
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-s -short&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;更为紧凑的格式输出&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关于紧凑格式输出中，文件名前标记的解释：
|标记|描述|
|-|-|
|&lt;code&gt;M &lt;/code&gt;|被修改了并放入了暂存区|
|&lt;code&gt; M&lt;/code&gt;|被修改了但是还没放入暂存区|
|&lt;code&gt;??&lt;/code&gt;|新添加的未跟踪文件|
|&lt;code&gt;A &lt;/code&gt;|新添加到暂存区中的文件|&lt;/p&gt;
&lt;h2 id="section-10"&gt;查看已暂存和未暂存的修改&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git diff
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;diff&lt;/code&gt; 命令查看具体修改内容。
默认此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--cached --staged&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;比较已暂存的内容和仓库中的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可以使用 &lt;code&gt;git difftool&lt;/code&gt; 命令来用 Araxis ，emerge 或 vimdiff 等软件输出 diff 分析结果。使用 &lt;code&gt;git difftool --tool-help&lt;/code&gt; 命令来看你的系统支持哪些 Git Diff 插件。&lt;/p&gt;
&lt;h1 id="section-11"&gt;查看历史&lt;/h1&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git log

git log --pretty=format:&amp;quot;%h - %an, %ar : %s&amp;quot;
git log --since=2.weeks
git log -Sfunction_name
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--decorate&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查看各个分支当前所指的对象&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-p&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;按补丁格式显示每个更新之间的差异&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--stat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示每次更新的文件修改统计信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--shortstat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只显示 &lt;code&gt;--stat&lt;/code&gt; 中最后的行数修改添加移除统计&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--name-only&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仅在提交信息后显示已修改的文件清单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--name-status&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示新增、修改、删除的文件清单&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--abbrev-commit&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仅显示 SHA-1 的前几个字符，而非所有的 40 个字符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--relative-date&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用较短的相对时间显示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--graph&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;形象地展示分支、合并历史&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--pretty&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--oneline&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--all&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-&amp;lt;num&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仅显示最近的几次提交&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--since=2.weeks --after&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列出所有最近两周内的提交&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--until=&amp;lt;time&amp;gt; --before&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列出所有到某时间为止的提交&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--author&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仅显示指定作者的提交&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--committer&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仅显示指定提交者相关的提交&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--grep&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;搜索提交说明中的关键字&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--all-match&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仅显示同时满足所有指定选项的提交（默认是或关系）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;列出那些添加或移除了某些字符串的提交&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;path&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只显示某些路径的历史提交（因为是放在最后位置上的选项，所以用两个短划线（&lt;code&gt;--&lt;/code&gt;）隔开之前的选项和后面限定的路径名。 ）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;关于 &lt;code&gt;git log --pretty=format&lt;/code&gt; 常用的选项见 &lt;a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"&gt;参考资料&lt;/a&gt;&lt;/p&gt;
&lt;h1 id="section-12"&gt;提交&lt;/h1&gt;
&lt;p&gt;工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。&lt;/p&gt;
&lt;h2 id="section-13"&gt;跟踪新文件&amp;amp;暂存已修改文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git add &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git add&lt;/code&gt; 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。
&lt;code&gt;add&lt;/code&gt; 是个多功能命令，可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中” （暂存区）更合适。&lt;/p&gt;
&lt;h2 id="section-14"&gt;移除文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git rm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果只是简单地从工作目录中手工删除文件，会将工作区中文件状态置为已删除，然后再运行 &lt;code&gt;git rm&lt;/code&gt; 记录此次移除文件的操作。这样下一次提交时，该文件就不再纳入版本管理了。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-f&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;强制移除文件（如果删除之前修改过并且已经放到暂存区域）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--cached&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把文件从 Git 仓库中删除，但保留在当前工作目录中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-15"&gt;移动文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git mv file_from file_to
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其实，运行 &lt;code&gt;git mv README.md README&lt;/code&gt; 就相当于运行了下面三条命令：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;mv README.md README
git rm README.md
git add README 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-16"&gt;取消暂存的文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git reset HEAD &amp;lt;filename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-17"&gt;撤消对文件的修改&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git checkout -- [file] 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将文件还原成上次提交时的样子。&lt;/p&gt;
&lt;h2 id="section-18"&gt;提交更新&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;commit&lt;/code&gt; 命令将暂存内容提交到仓库。
这种方式会启动文本编辑器以便输入本次提交的说明。文本编辑器中会以注释行的方式显示一些与提交相关的信息，默认显示 &lt;code&gt;git status&lt;/code&gt; 的信息。退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将 &lt;code&gt;diff&lt;/code&gt; 输出包含到提交注释信息中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-m&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;直接指定提交信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;自动把所有已经跟踪过的文件暂存起来一并提交&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--amend&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;尝试重新提交&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id="section-19"&gt;标签&lt;/h1&gt;
&lt;p&gt;Git 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点。
Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。&lt;/li&gt;
&lt;li&gt;附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的 标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。&lt;/p&gt;
&lt;h2 id="section-20"&gt;列出标签&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git tag
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-21"&gt;创建标签&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;# annotated tag
git tag -a [tag name] [-m [info]]

# lightweight tag
git tag [tag name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认情况下，&lt;code&gt;tag&lt;/code&gt; 命令给最近的提交打标签。如果要指定提交，需要在命令的末尾指定提交的校验和（或部分校验和）。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git tag -a v1.2 9fceb02
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-22"&gt;共享标签&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git push origin [tagname]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;默认情况下，&lt;code&gt;git push&lt;/code&gt; 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。&lt;/p&gt;
&lt;h2 id="section-23"&gt;检出标签&lt;/h2&gt;
&lt;p&gt;在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定 的标签版本完全一样，可以使用 &lt;code&gt;git checkout -b [branchname] [tagname]&lt;/code&gt; 在特定的标签上创建一个新分支。&lt;/p&gt;
&lt;h1 id="section-24"&gt;分支&lt;/h1&gt;
&lt;h2 id="section-25"&gt;创建分支&amp;amp;删除分支&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git branch [branchname] [from branchname]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 Git 中，使用一个指针 &lt;code&gt;HEAD&lt;/code&gt; ，指向当前所在的本地分支（可看成别名）。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查看每一个分支的最后一次提交&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-vv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查看设置的所有跟踪分支和时间关系等信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--merged&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只显示已经合并到当前分支的分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--no-merged&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只显示未合并到当前分支的分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除分支（此分支必须已被合并）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;强制删除分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-u --set-upstream-to&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;修改跟踪的上游分支&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;设置当前的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 &lt;code&gt;-u&lt;/code&gt; 或 &lt;code&gt;--set-upstream-to&lt;/code&gt; 选项运行 &lt;code&gt;git branch&lt;/code&gt; 来显式地设置。&lt;/p&gt;
&lt;h2 id="section-26"&gt;检出分支&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git checkout [branchname]
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;创建新分支并检出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--track&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;创建跟踪远程分支的本地分支&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="section-27"&gt;合并分支&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git merge [branchname]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将指定分支合并到当前分支。&lt;/p&gt;
&lt;h3 id="section-28"&gt;处理冲突&lt;/h3&gt;
&lt;p&gt;如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。此时 Git 做了合并，但是没有自动地创建一个新的合并提交。Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 &lt;code&gt;git status&lt;/code&gt; 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。在你解决了所有文件里的冲突之后，对每个文件使用 &lt;code&gt;git add&lt;/code&gt; 命令来将其标记为冲突已解决。一旦暂存这 些原本有冲突的文件，Git 就会将它们标记为冲突已解决。
如果你想使用图形化工具来解决冲突，可以运行 &lt;code&gt;git mergetool&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="section-29"&gt;远程分支&lt;/h2&gt;
&lt;p&gt;远程跟踪分支是远程分支状态的引用。它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。它们以 &lt;code&gt;(remote)/(branch)&lt;/code&gt; 形式命名。&lt;/p&gt;
&lt;h2 id="section-30"&gt;变基&lt;/h2&gt;
&lt;p&gt;参见官方文档。&lt;/p&gt;
&lt;h1 id="section-31"&gt;远程仓库&lt;/h1&gt;
&lt;h2 id="section-32"&gt;查看远程仓库&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git remote
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;-v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git remote show [remote-name]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;show&lt;/code&gt; 命令会列出远程仓库的 URL 与跟踪分支的信息。&lt;/p&gt;
&lt;p&gt;远程引用是对远程仓库的引用（指针），包括分支、标签等等。你可以通过 &lt;code&gt;git ls-remote (remote)&lt;/code&gt; 来显式地获得远程引用的完整列表，或者通过 &lt;code&gt;git remote show (remote)&lt;/code&gt; 获得远程分支的更多信息。&lt;/p&gt;
&lt;h2 id="section-33"&gt;添加远程仓库&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git remote add &amp;lt;shortname&amp;gt; &amp;lt;url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-34"&gt;远程仓库的移除与重命名&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git remote rename [oldname] [newname]

git remote rm [name]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-35"&gt;从远程仓库中抓取与拉取&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git fetch [remote-name]
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--all&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;抓取所有远程库的数据&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;fetch&lt;/code&gt; 会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。它并不会自动合并或修改你当前的工作。当准备好时你必须手动将其合并入你的工 作。
如果你有一个分支设置为跟踪一个远程分支，可以使用 &lt;code&gt;git pull&lt;/code&gt; 命令来自动的抓取然后合并远程分支到当前分支。运行 &lt;code&gt;git pull&lt;/code&gt; 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。
要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。
可以运行 &lt;code&gt;git merge origin/[branchname]&lt;/code&gt; 将这些工作合并到当前所在的分支。如果想要在自己的新分支上工作，可以将其建立在远程跟踪分支之上。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git checkout -b [branchname] origin/[branchname]
git checkout --track origin/[branchname]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-36"&gt;推送到远程仓库&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git push [remote-name] [branchname]

git push [remote-name] [tagname]
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;选项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--tags&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把所有不在远程仓库服务器上的标签全部推送&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;--delete [branchname]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除远程分支&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;git push origin serverfix
git push origin serverfix:serverfix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有些工作被简化了。Git 自动将 &lt;code&gt;serverfix&lt;/code&gt; 分支名字展开为 &lt;code&gt;refs/heads/serverfix:refs/heads/serverfix&lt;/code&gt;，那意味着，“推送本地的 &lt;code&gt;serverfix&lt;/code&gt; 分支来更新远程仓库上的 &lt;code&gt;serverfix&lt;/code&gt; 分支。”&lt;/p&gt;
&lt;h1 id="section-37"&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://git-scm.com/doc"&gt;Git Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://git-scm.com/book/en/v2"&gt;Git Book&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Learning/the-mutual-realization-of-stack-and-queue</id><title type="text">栈与队列的相互实现</title><summary type="text">本文介绍使用栈实现队列和使用队列实现栈的方法。为使问题更加有意义，我们将尽量选择一个较优的实现方法。
问题引入
栈：先进后出的线性结构，仅允许对栈顶进行添加（push），删除（pop），访问（peek</summary><published>2018-08-28T17:30:22+08:00</published><updated>2018-08-28T17:30:22+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Learning%2Fthe-mutual-realization-of-stack-and-queue" /><category term="Learning" /><content type="html">&lt;p&gt;本文介绍使用栈实现队列和使用队列实现栈的方法。为使问题更加有意义，我们将尽量选择一个较优的实现方法。&lt;/p&gt;
&lt;h1 id="section"&gt;问题引入&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;栈：先进后出的线性结构，仅允许对栈顶进行添加（push），删除（pop），访问（peek）操作，空间复杂度线性，单次操作时间复杂度为常数&lt;/li&gt;
&lt;li&gt;队列：先进先出线性结构，仅允许对队尾进行添加（enqueue）操作，以及对队首进行删除（dequeue），访问（peek）操作，空间复杂度线性，单次操作时间复杂度为常数&lt;/li&gt;
&lt;li&gt;需要解决的问题，在使用常数个额外空间的条件下：
&lt;ul&gt;
&lt;li&gt;使用两个栈尽可能高效地实现一个队列&lt;/li&gt;
&lt;li&gt;使用两个队列尽可能高效地实现一个栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;解决方法&lt;/h1&gt;
&lt;h2 id="section-2"&gt;使用栈实现队列&lt;/h2&gt;
&lt;h3 id="section-3"&gt;思路&lt;/h3&gt;
&lt;p&gt;考虑到栈先进后出与队列先进先出的特点，使用一个栈 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 作为队列尾，数据从这里流入；使用另一个栈 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 作为队列头，数据从这里流出。我们要求先流入的数据先流出，
通过将栈 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 中的元素不断弹出，并压入栈 &lt;span class="math"&gt;\(B\)&lt;/span&gt;，利用先进后出特性，&lt;span class="math"&gt;\(B\)&lt;/span&gt; 的出栈顺序即 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 出栈顺序的逆序，而 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 出栈顺序为其入栈顺序的逆序，故 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 的出栈顺序为 &lt;span class="math"&gt;\(A\)&lt;/span&gt; 的入栈顺序，即达到先进先出的效果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;栈能将输入逆序这一点很重要，之后我们还将用到。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="section-4"&gt;复杂度分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;：栈的空间复杂度是线性的，而且这里队列中的每一个数据仅会在两个栈中的某一个中存在，故此实现的空间复杂度为线性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：注意到每个数据从入队到出队只会经历：进入 &lt;span class="math"&gt;\(A\)&lt;/span&gt;，离开 &lt;span class="math"&gt;\(A\)&lt;/span&gt;，进入 &lt;span class="math"&gt;\(B\)&lt;/span&gt;，离开 &lt;span class="math"&gt;\(B\)&lt;/span&gt; 四次移动，且每次移动复杂度为常数，故均摊复杂度为常数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-5"&gt;使用队列实现栈&lt;/h2&gt;
&lt;h3 id="section-6"&gt;思路&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;这里遇到了个难题：利用栈可以很容易地支持翻转操作，但队列无法直接对输入序列进行顺序的改变。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;队列中一个重要特点是，我们可以通过不断删除队列头，并将其放入队列尾，实现在不影响顺序的前提下对队列中每个元素的访问，访问一遍后，我们仍可以很容易恢复到最初的队列状态。
但这一操作的弊端是，我们访问某个元素，必须将其前面的所有元素出队，这一操作的时间复杂度是最坏情况下是线性的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;既然我们能访问所有元素了，那只要访问最后一个就是先入后出了，很简单嘛，可是队列“滚”的次数太多了（为线性）...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为下文叙述方便，将上述操作定义为过程“循环出入队”，即将队首出队后入队，实现队列滚动。时间复杂度由以上分析，为 &lt;span class="math"&gt;\(O(|Q|))\)&lt;/span&gt;。
我们使用一个类似缓冲池的技巧：设两个队列 &lt;span class="math"&gt;\(Q_s,Q_a\)&lt;/span&gt;，&lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 用于存储靠近栈顶的一部分元素，&lt;span class="math"&gt;\(Q_s\)&lt;/span&gt; 用于存储其余的元素。其中 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 有可变的容量上限 &lt;span class="math"&gt;\(cap(Q_a)\)&lt;/span&gt;，&lt;span class="math"&gt;\(Q_s\)&lt;/span&gt; 容量无限制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你可以把 &lt;span class="math"&gt;\(Q_s\)&lt;/span&gt; 看成内存（主存），把 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 看成 CPU 中的高速缓存&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来，我们依次实现栈的三个操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;入栈操作&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 不满，直接入队到 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 。时间复杂度：&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 满，将 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 出队，并将队列头入队到 &lt;span class="math"&gt;\(Q_s\)&lt;/span&gt;。然后将待入栈元素入队到 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt;。时间复杂度：&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="2"&gt;
&lt;li&gt;出栈操作&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 非空，对 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 循环出入队，使得原队尾在队头，返回队尾，并出队。时间复杂度：&lt;span class="math"&gt;\(O(|Q_a|)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 空，对 &lt;span class="math"&gt;\(Q_s\)&lt;/span&gt; 循环出入队，使得原队尾部的 &lt;span class="math"&gt;\(|Q_a|+1\)&lt;/span&gt; 个元素出队，返回队尾，其余元素进入 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt;，顺序不变。时间复杂度：&lt;span class="math"&gt;\(O(|Q_s|)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="3"&gt;
&lt;li&gt;访问栈顶操作&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 非空，对 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 循环出入队，使得原队尾在队头，返回队尾，并恢复最初顺序，时间复杂度：&lt;span class="math"&gt;\(O(|Q_a|)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 空，对 &lt;span class="math"&gt;\(Q_s\)&lt;/span&gt; 循环出入队，使得原队尾部的 &lt;span class="math"&gt;\(|Q_a|\)&lt;/span&gt; 个元素出队，返回队尾，所有元素进入 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt;，顺序不变。时间复杂度：&lt;span class="math"&gt;\(O(|Q_s|)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为让这个实现变得有效，我们先来分析其时间复杂度来自哪里：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个元素&lt;/strong&gt;从入栈到出栈经历了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;压入：&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;（可选）从 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 到 &lt;span class="math"&gt;\(Q_s\)&lt;/span&gt;：&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;（可选）从 &lt;span class="math"&gt;\(Q_s\)&lt;/span&gt; 到 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt;：&lt;span class="math"&gt;\(O(|Q_s|/|Q_a|)\)&lt;/span&gt;（最坏情况）&lt;/li&gt;
&lt;li&gt;弹出 以下两种二选一：
&lt;ul&gt;
&lt;li&gt;从 &lt;span class="math"&gt;\(Q_s\)&lt;/span&gt; 出队：&lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;从 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 出队：&lt;span class="math"&gt;\(O(|Q_a|)\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来考虑最坏情况，那么每个元素经历入队出队共计 &lt;span class="math"&gt;\(O(|Q_s|/|Q_a|+|Q_a|)\)&lt;/span&gt;.
由 &lt;span class="math"&gt;\(|Q_s|/|Q_a|+|Q_a| \ge 2\sqrt{|Q_s|}\)&lt;/span&gt; 当且仅当 &lt;span class="math"&gt;\(|Q_s|/|Q_a|=|Q_a|\)&lt;/span&gt; 即 &lt;span class="math"&gt;\(|Q_a|=\sqrt{|Q_s|}\)&lt;/span&gt;。故最低为 &lt;span class="math"&gt;\(O(\sqrt{|Q_s|})\)&lt;/span&gt;
故当我们将 &lt;span class="math"&gt;\(Q_a\)&lt;/span&gt; 的容量限制在 &lt;span class="math"&gt;\(\sqrt{|Q_s|}\)&lt;/span&gt; 时，对于 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 个元素的栈，有 &lt;span class="math"&gt;\(|Q_s|\le n\)&lt;/span&gt; 总复杂度估计为 &lt;span class="math"&gt;\(O(n\sqrt n)\)&lt;/span&gt;.
平均每次操作复杂度$O(n\sqrt n/(2n))=O(\sqrt n)$，由此可见，性能的确有较大提高。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你像上面那样类比了计算机中的组件，那么我们的算法所做的，就可以看成从内存中读取一段，放入高速缓存中，利用高命中率来减少我们对相对低速的内存的访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="section-7"&gt;复杂度分析&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;空间复杂度&lt;/strong&gt;：队列的空间复杂度是线性的，而且这里栈中的每一个数据仅会在两个队列中的某一个中存在，故此实现的空间复杂度为线性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;时间复杂度&lt;/strong&gt;：通过思路中的分析，单次操作均摊复杂度为 &lt;span class="math"&gt;\(O(\sqrt{n})\)&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-8"&gt;扩展阅读与参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://cstheory.stackexchange.com/questions/2562/one-stack-two-queues/5655#5655"&gt;时间复杂度下限的讨论&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://cstheory.stackexchange.com/questions/2562/one-stack-two-queues/2589#2589"&gt;队列实现栈的 C# 代码实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Learning/ojops-problem-design</id><title type="text">OJ-oriented Problem Solving 命题报告</title><summary type="text">题面
题目概述
时间限制：1000 ms
空间限制：128 MB
命题人：Stardust D.L.
验题人：GodCallMeGod, Pexure
题目描述
小 A 和你我一样，正坐在电脑前刷题。</summary><published>2018-09-11T17:30:22+08:00</published><updated>2018-09-11T17:30:22+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Learning%2Fojops-problem-design" /><category term="Learning" /><content type="html">&lt;h1 id="section"&gt;&lt;a href="https://vijos.org/d/StarOI/p/5b95252dd3d8a13cf377eee5"&gt;题面&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="section-1"&gt;题目概述&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;时间限制：1000 ms&lt;/li&gt;
&lt;li&gt;空间限制：128 MB&lt;/li&gt;
&lt;li&gt;命题人：Stardust D.L.&lt;/li&gt;
&lt;li&gt;验题人：GodCallMeGod, Pexure&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-2"&gt;题目描述&lt;/h2&gt;
&lt;p&gt;小 A 和你我一样，正坐在电脑前刷题。但茫茫多的 OJ 和茫茫多的题目，让他感到无从下手。幸运的是，小 A 得到了一个神奇的工具，能很快生成一个指定长度的题目列表，还能标识出题目的难度等级。小 A 用这个工具生成了一个长度为 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 的题目列表，但这个题目列表中难度安排不太令人满意，为了提高刷题体验，也尽快提高问题求解能力，小 A 决定把其中一些题换掉，来让题目难度安排更加合理。
形式化的，设题目列表 &lt;span class="math"&gt;\(a\)&lt;/span&gt;，&lt;span class="math"&gt;\(a_i(1\le i\le n)\)&lt;/span&gt; 表示第 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 道题的难度（数值越大，难度越高），定义 对于题目列表的“难度渐进”值 &lt;span class="math"&gt;\(Q(a)\)&lt;/span&gt; 为：&lt;/p&gt;
&lt;div class="math"&gt;
\[
Q(a)=\sum_{i=2}^n \min(1,a_i-a_{i-1})
\]&lt;/div&gt;
&lt;p&gt;小 A 希望将 &lt;strong&gt;某一些&lt;/strong&gt; &lt;span class="math"&gt;\(a_i\)&lt;/span&gt; 改成 &lt;span class="math"&gt;\(a_i'\)&lt;/span&gt;（由于可以任意挑题目，所以这里选取的 &lt;span class="math"&gt;\(a_i'\in \mathbb{Z}\)&lt;/span&gt; 是任意的，即使是负值也可以），使得修改后的新序列 &lt;span class="math"&gt;\(a'\)&lt;/span&gt;，&lt;span class="math"&gt;\(Q(a')\)&lt;/span&gt; 最大。为了尽快开始做题，小 A 希望被替换的题目数量越少越好。请求出最少替换几道题目能使得 &lt;span class="math"&gt;\(Q(a')\)&lt;/span&gt; 最大。&lt;/p&gt;
&lt;h2 id="section-3"&gt;输入&lt;/h2&gt;
&lt;p&gt;第一行一个整数 &lt;span class="math"&gt;\(T\)&lt;/span&gt;，表示 &lt;span class="math"&gt;\(T\)&lt;/span&gt; 组测试数据。
之后对于每组测试数据：
第一行一个整数 &lt;span class="math"&gt;\(n\)&lt;/span&gt;，表示题目列表长度。
第二行 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 个整数 &lt;span class="math"&gt;\(a_i\)&lt;/span&gt;，表示每道题目的难度。&lt;/p&gt;
&lt;h2 id="section-4"&gt;输出&lt;/h2&gt;
&lt;p&gt;&lt;span class="math"&gt;\(T\)&lt;/span&gt; 行，每行一个整数表示答案。&lt;/p&gt;
&lt;h2 id="section-5"&gt;样例&lt;/h2&gt;
&lt;h3 id="section-6"&gt;输入&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;4
3
1 1 2
4
1 2 2 5
10
46 42 22 45 14 33 3 21 9 5
20
38 35 11 86 31 47 3 6 71 93 42 74 95 3 94 47 89 46 98 10
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-7"&gt;输出&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1
1
8
13
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-8"&gt;解释&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一组：将第一个 $1$ 改成 $0$&lt;/li&gt;
&lt;li&gt;第二组：将第二个 $2$ 改成 $3$ 或 $4$&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-9"&gt;数据范围&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;$1\le T \le 5$&lt;/li&gt;
&lt;li&gt;$1\le n\le 3000$&lt;/li&gt;
&lt;li&gt;$1\le a_i \le 10^5,a_i\in \mathbb$&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-10"&gt;命题思路&lt;/h1&gt;
&lt;p&gt;以最长上升子序列的 &lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt; 动态规划算法为核心，进行一定程度包装和扩展，实现对此算法的灵活应用。&lt;/p&gt;
&lt;h1 id="section-11"&gt;解题思路&lt;/h1&gt;
&lt;p&gt;首先简化题意，可以发现 &lt;span class="math"&gt;\(Q(a)\)&lt;/span&gt; 最大值为 &lt;span class="math"&gt;\(n-1\)&lt;/span&gt;，当且仅当 &lt;span class="math"&gt;\(a\)&lt;/span&gt; 严格递增时达到最大值。所以问题变成：&lt;strong&gt;把一个序列改成严格单调递增的，至少需要改多少个数？&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id="section-12"&gt;解法 1&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;状态&lt;/strong&gt;： &lt;span class="math"&gt;\(d_{i,j}\)&lt;/span&gt; 表示前 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 个数，将 &lt;span class="math"&gt;\(a_i\)&lt;/span&gt; 修改为 &lt;span class="math"&gt;\(j\)&lt;/span&gt; ，使序列严格递增时，修改次数的最小值。
&lt;strong&gt;转移&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="math"&gt;
\[
d_{i,j}=[j\ne a_i]+\min_{k &amp;lt; j}d_{i-1,k}
\]&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(j=a_i\)&lt;/span&gt;，则不必修改，转移为 &lt;span class="math"&gt;\(d_{i,j}=\min_{k &amp;lt; j}d_{i-1,k}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;若 &lt;span class="math"&gt;\(j\ne a_i\)&lt;/span&gt;，则需要修改，转移为 &lt;span class="math"&gt;\(d_{i,j}=1+\min_{k &amp;lt; j}d_{i-1,k}\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;临界值&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\[
d_{1,j}=\begin{cases}
0,&amp;amp;j=a_1\\
1,&amp;amp;j\ne a_1
\end{cases}
\]&lt;/div&gt;
&lt;p&gt;而问题的答案即 &lt;span class="math"&gt;\(d_{n,x}\)&lt;/span&gt; 中的最小值。
此解法状态数 &lt;span class="math"&gt;\(O(n\times\max(n,m))\)&lt;/span&gt; （其中 &lt;span class="math"&gt;\(m\)&lt;/span&gt; 为 &lt;span class="math"&gt;\(a_i\)&lt;/span&gt; 的可能取值种数）状态转移 &lt;span class="math"&gt;\(O(m)\)&lt;/span&gt;，故时间复杂度为 &lt;span class="math"&gt;\(O(nm^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于数值范围较大，通过离散化可将 &lt;span class="math"&gt;\(m\)&lt;/span&gt; 降至与 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 同阶，但由于此题的“严格递增”条件，&lt;strong&gt;普通的离散化可能会带来错解&lt;/strong&gt;。这一点我们在之后解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="section-13"&gt;解法 2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;此方法与解法一“对偶”，但实现要容易得多。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;状态&lt;/strong&gt;： &lt;span class="math"&gt;\(d_{i,j}\)&lt;/span&gt; 表示前 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 个数，修改 $0\le j\le i$ 次使序列严格递增时，&lt;span class="math"&gt;\(a_i\)&lt;/span&gt; 的最小值。
&lt;strong&gt;转移&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="math"&gt;
\[
d_{i,j}=\begin{cases}
\min (a_i,d_{i-1,j-1}+1)&amp;amp;d_{i-1,j} &amp;lt; a_i\\
d_{i-1,j-1}+1,&amp;amp;d_{i-1,j} \ge a_i
\end{cases}
\]&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;若不修改 &lt;span class="math"&gt;\(a_i\)&lt;/span&gt; 则要求 &lt;span class="math"&gt;\(d_{i-1,j} &amp;lt; a_i\)&lt;/span&gt;，故此时有转移 &lt;span class="math"&gt;\(d_{i,j}=a_i\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;若修改 &lt;span class="math"&gt;\(a_i\)&lt;/span&gt; 则由状态值定义，一定会改成前一个数 &lt;span class="math"&gt;\(+1\)&lt;/span&gt;，即此时有转移 &lt;span class="math"&gt;\(d_{i,j}=d_{i-1,j-1}+1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;未能转移的状态都是不可行解。&lt;/li&gt;
&lt;li&gt;临界值&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;
\[
d_{1,j}=\begin{cases}
a_1,&amp;amp;j=0\\
-\infty,&amp;amp;j=1\\
\end{cases}
\]&lt;/div&gt;
&lt;p&gt;而问题的答案即 &lt;span class="math"&gt;\(d_{n,x}\)&lt;/span&gt; 中最小的 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 使得 &lt;span class="math"&gt;\(d_{n,x}\)&lt;/span&gt; 存在。
此解法状态数 &lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;，状态转移 &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;，故时间复杂度为 &lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id="section-14"&gt;解法 3（标准解法）&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;其实此题的 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 可提升至 $10&lt;sup&gt;6$，&lt;span class="math"&gt;\(a_i\)&lt;/span&gt; 数值范围可无限制（例如 $10&lt;/sup&gt;{18}$）。但对于这样的数据，前两种做法显然无能为力。所以我们需要一个全新的思路。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们考虑一个相似的问题：把一个序列改成单调 &lt;strong&gt;不降&lt;/strong&gt; 的，至少需要改多少个数？即要保证
&lt;span class="math"&gt;\(i &amp;lt; j \Rightarrow a_i\le a_j\)&lt;/span&gt;
这个问题的解法是 &lt;strong&gt;保留最长不降子序列&lt;/strong&gt;。最长非降子序列形成了一个阶梯式结构，可以将所有不属于最长非降子序列的数据改成最靠近的阶梯层。所以答案为 &lt;span class="math"&gt;\(n-\text{len}(LNDS)\)&lt;/span&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明可以从最优解必须保留最长非降子序列，和不能改动更少的数使得满足条件两个角度出发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于求解最长非降子序列，将求解 LIS 的算法 的状态转移稍作改动即可：
&lt;span class="math"&gt;\(d_i=1+\max_{j&amp;lt; i\wedge a_j\le a_i} d_j\)&lt;/span&gt;
回到原题：一种比较自然的思路是保留最长上升子序列，即求 &lt;span class="math"&gt;\(n-len(LIS)\)&lt;/span&gt;。
但这是 &lt;strong&gt;错&lt;/strong&gt; 的，比如这组数据：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1 2 2 3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有 &lt;span class="math"&gt;\(\text{len}(LIS)=3\)&lt;/span&gt;，但显然只改一个值并不能将其变成严格递增的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;样例数据并不能反映这一点，但有所暗示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以原序列的 LIS 并不一定能完全被保留。那么什么样的子序列才是可以被完全保留的？其实仅在这种情况下，保留 LIS 可能会出现错误：&lt;span class="math"&gt;\(x-1,x,x,\cdots,x,x+1\)&lt;/span&gt;，中间过多的 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 使得 &lt;span class="math"&gt;\(x+1\)&lt;/span&gt; 不能被保留。
所以我们需要考虑位置信息。可以发现 &lt;span class="math"&gt;\(a_i\)&lt;/span&gt; 至少要比 &lt;span class="math"&gt;\(a_0\)&lt;/span&gt; 大 &lt;span class="math"&gt;\(i\)&lt;/span&gt;。即要保证&lt;/p&gt;
&lt;div class="math"&gt;
\[
i &amp;lt; j \Rightarrow a_j&amp;gt;a_i \Leftrightarrow a_j-a_i\ge j-i \Leftrightarrow a_j-j\ge a_i-i
\]&lt;/div&gt;
&lt;p&gt;至此，我们完成了对原问题的转化。定义序列 &lt;span class="math"&gt;\(b:b_i=a_i-i\)&lt;/span&gt; 。可以发现：&lt;span class="math"&gt;\(a\)&lt;/span&gt; 的可完全保留单调递增序列和 &lt;span class="math"&gt;\(b\)&lt;/span&gt; 的不降子序列是一一对应的。
所以原问题的答案就是 &lt;span class="math"&gt;\(n-\text{len}(LNDS_b)\)&lt;/span&gt;。
求解的时间复杂度集中在求解 &lt;span class="math"&gt;\(\text{len}(LNDS_b)\)&lt;/span&gt;，而这一步可以在 &lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt; 内完成。故总时间复杂度为 &lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;.
而求解 LIS，LNDS 的长度可以在 &lt;span class="math"&gt;\(O(n\lg n)\)&lt;/span&gt; 内完成。故我们可以使用解法 3 在更短的时间内解决。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;看起来算法 3 完美地解决了这个问题，而算法 1 没有任何优势，但其实不然，在 &lt;a href="#%E9%97%AE%E9%A2%98%E6%89%A9%E5%B1%95"&gt;问题扩展&lt;/a&gt; 部分，我们会利用算法 3 推导过程中的思路来扩展算法 1，并用其解决一个更复杂的问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id="section-15"&gt;数据构造&lt;/h1&gt;
&lt;p&gt;此题要求卡掉 &lt;span class="math"&gt;\(n-len(LIS)\)&lt;/span&gt; 的做法，所以构造形如 &lt;code&gt;1 2 2 3&lt;/code&gt; 的数据即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import random
import os

maxN = 3000
maxA = 100000

def nextN():
    return random.randint(1, maxN)

def randArr(n,l,r):
    ret = []
    for i in range(n):
        ret.append(random.randint(l, r))
    return ret

def outputData(a):
    print(len(a), end = '\n')
    print(&amp;quot; &amp;quot;.join(str(i) for i in a), end = '\n')

def randData(n):
    return randArr(n,1,maxA)

def waLISData(n):
    while n &amp;lt; 1000:
        n = nextN()
    a = randArr(n//3, 1, n//3)
    a.sort()
    b = []
    for i in a:
        num=random.randint(2,5)
        for x in range(num):
            b.append(i)
    while len(b) &amp;gt; n:
        b.pop()
    return b

T = random.randint(3,5)
print(T, end = '\n')
for i in range(T):
    n = nextN()
    tp = random.randint(1, 4)
    if tp==1:
        outputData(randData(n))
    else:
        outputData(waLISData(n))
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-16"&gt;标准程序&lt;/h1&gt;
&lt;pre&gt;&lt;code class="language-c++"&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
const int MAXN = 3000;
namespace LNDS
{
int d[MAXN + 5];
int solve(int *a, int n)
{
    d[0] = 1;
    int ans = 1;
    for (int i = 1; i &amp;lt; n; i++)
    {
        int &amp;amp;c = d[i];
        c = 1;
        for (int j = 0; j &amp;lt; i; j++)
        {
            if (a[j] &amp;lt;= a[i])
                c = max(c, d[j] + 1);
        }
        ans = max(ans, c);
    }
    return ans;
}
} // namespace LNDS
int T, n;
int a[MAXN + 5];
int main()
{
    cin &amp;gt;&amp;gt; T;
    while (T--)
    {
        cin &amp;gt;&amp;gt; n;
        for (int i = 0; i &amp;lt; n; i++)
        {
            cin &amp;gt;&amp;gt; a[i];
            a[i] -= i;
        }
        cout &amp;lt;&amp;lt; n - LNDS::solve(a, n) &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-17"&gt;问题扩展&lt;/h1&gt;
&lt;h2 id="section-18"&gt;更复杂的修改费用&lt;/h2&gt;
&lt;p&gt;原问题中，每次修改的费用恒为 $1$，如果将修改费用定义为 &lt;span class="math"&gt;\(|a_i'-a_i|\)&lt;/span&gt;，该如何求解呢？
此时解法 3 不那么奏效：保留最长可行子序列，但可能有多种最长可行子序列，而且保留后相邻段之间的值该如何更改，解法 3 难以给出足够的信息。
但可以发现，解法 3 思路中的推导仍然成立，我们依旧将问题转化，求序列 &lt;span class="math"&gt;\(b:b_i=a_i-i\)&lt;/span&gt; 满足不降的最优解。两个问题的最优解值是相等的。
首先一个结论，在修改后的序列中出现的所有数，都是原序列中出现过的。其证明可用反证法。
进而我们只在处理中只关注某个数的位次（排名），仅在计算费用时使用原值，所以我们可对序列的值离散化，将 &lt;span class="math"&gt;\(m\)&lt;/span&gt; 降到 &lt;span class="math"&gt;\(n\)&lt;/span&gt; 同阶。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于在转化后的问题中，我们可以让一段值相等，不再存在“严格递增”条件，离散化可能错解的问题被解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来，我们使用解法 1：设 &lt;span class="math"&gt;\(c_i\)&lt;/span&gt; 表示 &lt;span class="math"&gt;\(\{b\}\)&lt;/span&gt; 中第 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 小的数。
&lt;strong&gt;状态&lt;/strong&gt;： &lt;span class="math"&gt;\(d_{i,j}\)&lt;/span&gt; 表示前 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 个数，将 &lt;span class="math"&gt;\(b_i\)&lt;/span&gt; 修改为 &lt;span class="math"&gt;\(c_j\)&lt;/span&gt; ，使序列不降时，修改费用的最小值。
&lt;strong&gt;转移&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="math"&gt;
\[
d_{i,j}=|c_j-b_i|+\min_{k \le j}d_{i-1,k}
\]&lt;/div&gt;
&lt;p&gt;而问题的答案即 &lt;span class="math"&gt;\(d_{n,x}\)&lt;/span&gt; 中的最小值。
此解法状态数 &lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;，状态转移 &lt;span class="math"&gt;\(O(n)\)&lt;/span&gt;，故时间复杂度为 &lt;span class="math"&gt;\(O(n^3)\)&lt;/span&gt;。
通过维护 &lt;span class="math"&gt;\(d_i\)&lt;/span&gt; 的前缀最小值可将状态转移降至 &lt;span class="math"&gt;\(O(1)\)&lt;/span&gt;，故时间复杂度可优化为 &lt;span class="math"&gt;\(O(n^2)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id="section-19"&gt;相关题目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;{% post_link problem/hdu/hdu-5256 %}&lt;/li&gt;
&lt;li&gt;{% post_link problem/poj/poj-3666 %}&lt;/li&gt;
&lt;li&gt;{% post_link problem/codeforces/cf-713C %}&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Learning/nju-icspa-analytics-nexus-am</id><title type="text">NJU ICS Programming Assignment 代码分析 - NEXUS-AM</title><summary type="text">概述
框架代码库
CPU 架构：x64
操作系统: GNU/Linux
编译器: GCC
编程语言：C 语言
一方面, 应用程序的运行都需要运行时环境的支持; 另一方面, 只进行纯粹计算任务的程序在T</summary><published>2018-10-23T17:30:22+08:00</published><updated>2018-10-23T17:30:22+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Learning%2Fnju-icspa-analytics-nexus-am" /><category term="Learning" /><content type="html">&lt;h1 id="section"&gt;概述&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/NJU-ProjectN/nexus-am"&gt;框架代码库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CPU 架构：x64&lt;/li&gt;
&lt;li&gt;操作系统: GNU/Linux&lt;/li&gt;
&lt;li&gt;编译器: GCC&lt;/li&gt;
&lt;li&gt;编程语言：C 语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一方面, 应用程序的运行都需要运行时环境的支持; 另一方面, 只进行纯粹计算任务的程序在TRM上就可以运行, 更复杂的应用程序对运行时环境必定还有其它的需求。将这些需求收集起来，抽象成统一的API提供给程序, 这样我们就得到了一个可以支撑各种程序运行在各种机器上的库。具体地, 每个机器都按照它们的特性实现这组API; 应用程序只需要直接调用这组API即可, 无需关心自己将来运行在哪个机器上. 由于这组统一抽象的API代表了程序运行对机器的需求, 所以我们把这组API称为抽象计算机.&lt;/p&gt;
&lt;p&gt;NEXUS-AM(Abstract machine) 把程序和机器解耦。作为一个向程序提供运行时环境的库, AM根据程序的需求把库划分成以下模块&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;AM = TRM + IOE + CTE + VME + MPE
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力&lt;/li&gt;
&lt;li&gt;IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力&lt;/li&gt;
&lt;li&gt;CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力&lt;/li&gt;
&lt;li&gt;VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力&lt;/li&gt;
&lt;li&gt;MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;框架代码结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;nanos-lite/
navy-apps/
nemu/
nexus-am/                   # NEXUS-AM 项目
    am/                     # AM 相关
        arch/               # 不同机器的 AM 实现
            native/
            x86-nemu/
        build/              # AM 构建输出文件夹
    apps/                   # 直接运行在AM上的应用
        hello/              # Hello World 程序
        dhrystone/          # 性能测试程序 1
        coremark/           # 性能测试程序 2
        microbench/         # 性能测试程序 3
        slider/             # 幻灯片播放程序
        typing/             # 打字小游戏
        litenes/            # 超级玛丽
    libs/                   # 可以直接运行在AM上的库
        compiler-rt/
        fixmath/
        imgui/
        klib/               # kernel library, 提供一些兼容 libc 的基础功能
    tests/                  # 直接运行在AM上的测试
        cputest/            # CPU 实现测试（指令译码与执行）
        timetest/           # 时钟设备测试
        keytest/            # 键盘设备测试
        videotest/          # VGA 设备测试
        ...
    Makefile                # AM 构建命令
    Makefile.check          # AM 上项目的构建命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="makefile.check"&gt;Makefile.check&lt;/h1&gt;
&lt;p&gt;通过设置 &lt;code&gt;ARCH&lt;/code&gt; 变量，指定默认 AM：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;native&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x86-nemu&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="am"&gt;am/&lt;/h1&gt;
&lt;h2 id="am-1"&gt;特定 AM 实现代码结构&lt;/h2&gt;
&lt;p&gt;{% note warning %}
此为大致结构，不一定完全按照此结构。
{% endnote %}&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;img/
    build
    run
include/            # 头文件
    arch.h          # 基础头文件
src/                # 源码文件
    devices/        # 设备接口实现
        input.c     # 输入设备（键盘）
        timer.c     # 时钟设备
        video.c     # VGA 设备
    cte.c           # 对 CTE API 部分的实现。
    ioe.c           # 对 IOE API 部分的实现。
    trm.c           # 对 TRM API 部分的实现。
    vme.c           # 对 VME API 部分的实现。
    trap.S
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;input.c&lt;/code&gt; 中需要实现对寄存器 &lt;code&gt;_DEVREG_INPUT_KBD&lt;/code&gt; 的支持&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="am.h"&gt;am.h&lt;/h2&gt;
&lt;p&gt;定义了 AM 基础 API。&lt;/p&gt;
&lt;h3 id="section-2"&gt;枚举&lt;/h3&gt;
&lt;p&gt;定义了事件类型枚举，指示事件类型。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;enum {
  _EVENT_NULL = 0,
  _EVENT_ERROR,
  _EVENT_IRQ_TIMER,
  _EVENT_IRQ_IODEV,
  _EVENT_PAGEFAULT,
  _EVENT_YIELD,     // 自陷
  _EVENT_SYSCALL,   // 系统调用
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-3"&gt;结构体&lt;/h3&gt;
&lt;h4 id="context"&gt;_Context&lt;/h4&gt;
&lt;p&gt;规定了上下文结构体 &lt;code&gt;_Context&lt;/code&gt;。
因为不同机器之间上下文信息的差异过大，所以在AM中, &lt;code&gt;_Context&lt;/code&gt; 的具体成员也是由不同的机器自己定义的。因此, 在操作系统中, 对 &lt;code&gt;_Context&lt;/code&gt; 成员的直接引用, 都属于机器相关的行为, 会损坏操作系统的可移植性. 不过大多数情况下, 操作系统并不需要单独访问 &lt;code&gt;_Context&lt;/code&gt; 结构中的成员. 必要的时候, CTE也可以提供一些统一的接口, 来让操作系统通过这些接口来访问, 从而保证操作系统的相关代码与机器无关.&lt;/p&gt;
&lt;h4 id="area"&gt;_Area&lt;/h4&gt;
&lt;p&gt;一段内存区域。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;start&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;起点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;end&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;终点（不包含）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="device"&gt;_Device&lt;/h4&gt;
&lt;p&gt;设备。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;id&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;唯一ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;名字(非必须)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;read&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;读操作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;write&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;写操作&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;size_t (*read) (uintptr_t reg, void *buf, size_t size);
size_t (*write)(uintptr_t reg, void *buf, size_t size);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;read()/write()&lt;/code&gt; 分别是设备读/写操作的实现, 用于从设备的 &lt;code&gt;reg&lt;/code&gt; 寄存器中读出 &lt;code&gt;size&lt;/code&gt; 字节的内容到缓冲区 &lt;code&gt;buf&lt;/code&gt; 中, 或者往设备的 &lt;code&gt;reg&lt;/code&gt; 寄存器中写入缓冲区 &lt;code&gt;buf&lt;/code&gt; 中的 &lt;code&gt;size&lt;/code&gt; 字节的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% note info %}
需要注意的是, 这里的reg寄存器并不是设备寄存器, 因为设备寄存器的编号是机器相关的. 在IOE中, 我们希望采用一种机器无关的&amp;quot;抽象寄存器&amp;quot;, 这个reg其实是一个功能编号, 我们约定在不同的机器中, 同一个功能编号的含义也是相同的, 这样就实现了设备寄存器的抽象.
{% endnote %}&lt;/p&gt;
&lt;h4 id="event"&gt;_Event&lt;/h4&gt;
&lt;p&gt;事件，指示程序流切换的原因。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;event&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;事件类型编号，使用上述枚举&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cause&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;描述信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ref&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;msg&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;事件信息字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="trm"&gt;TRM&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void _trm_init()&lt;/code&gt; 初始化 TRM&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_Area _heap&lt;/code&gt; 结构用于指示堆区的起始和末尾&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void _putc(char ch)&lt;/code&gt; 输出一个字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void _halt(int code)&lt;/code&gt; 结束程序的运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="ioe"&gt;IOE&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int _ioe_init()&lt;/code&gt; 初始化 IOE&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_Device *_device(int n)&lt;/code&gt; 返回编号为 &lt;code&gt;n&lt;/code&gt; 的设备的数据结构. 机器中的可用设备从 &lt;code&gt;1&lt;/code&gt; 开始按顺序编号, 若不存在编号为 &lt;code&gt;n&lt;/code&gt; 的设备, 则返回 &lt;code&gt;NULL&lt;/code&gt;。
&lt;ul&gt;
&lt;li&gt;可以使用这个 API 枚举机器中的每一个设备。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="cte"&gt;CTE&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int _cte_init(_Context* (*handler)(_Event ev, _Context *ctx))&lt;/code&gt; 用于进行CTE相关的初始化操作. 其中它还接受一个来自操作系统的事件处理回调函数的指针, 当发生事件时, CTE将会把事件和相关的上下文作为参数, 来调用这个回调函数, 交由操作系统进行后续处理.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void _yield()&lt;/code&gt; 用于进行自陷操作, 会触发一个编号为 &lt;code&gt;_EVENT_YIELD&lt;/code&gt; 事件.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vme"&gt;VME&lt;/h3&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h3 id="mpe"&gt;MPE&lt;/h3&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h2 id="amdev.h"&gt;amdev.h&lt;/h2&gt;
&lt;p&gt;使用宏定义常见设备 ID ：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_DEV_INPUT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;输入设备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_DEV_TIMER&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;时钟设备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_DEV_VIDEO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;VGA 设备&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用宏定义了一些用于设备访问的抽象寄存器并定义了相关结构体：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;_DEVREG_INPUT_KBD&lt;/code&gt; 键盘控制器
&lt;ul&gt;
&lt;li&gt;从中读出 &lt;code&gt;_KbdReg&lt;/code&gt; 结构体, &lt;code&gt;keydown = 1&lt;/code&gt; 为按下按键, &lt;code&gt;keydown = 0&lt;/code&gt; 为释放按键. &lt;code&gt;keycode&lt;/code&gt; 为按键的&lt;strong&gt;断码&lt;/strong&gt;, 没有按键时, &lt;code&gt;keycode&lt;/code&gt; 为 &lt;code&gt;_KEY_NONE&lt;/code&gt; .&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_DEVREG_TIMER_UPTIME&lt;/code&gt; 系统启动时间
&lt;ul&gt;
&lt;li&gt;从中读出 &lt;code&gt;_UptimeReg&lt;/code&gt; 结构体, &lt;code&gt;(hi &amp;lt;&amp;lt; 32LL) | lo&lt;/code&gt; 是系统启动的毫秒数.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_DEVREG_TIMER_DATE&lt;/code&gt; 实时时钟(RTC)
&lt;ul&gt;
&lt;li&gt;从中读出 &lt;code&gt;_DateReg&lt;/code&gt; 结构体, 包含年月日时分秒&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_DEVREG_VIDEO_INFO&lt;/code&gt; 显示控制器信息
&lt;ul&gt;
&lt;li&gt;从中读出 &lt;code&gt;_VideoInfoReg&lt;/code&gt; 结构体, 其中 &lt;code&gt;width&lt;/code&gt; 为屏幕宽度, &lt;code&gt;height&lt;/code&gt; 为屏幕高度. 另外假设AM运行过程中, 屏幕大小不会发生变化.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_DEVREG_VIDEO_FBCTL&lt;/code&gt; 帧缓冲控制器
&lt;ul&gt;
&lt;li&gt;向其写入 &lt;code&gt;_FBCtlReg&lt;/code&gt; 结构体, 向屏幕 &lt;code&gt;(x, y)&lt;/code&gt; 坐标处绘制 &lt;code&gt;w*h&lt;/code&gt; 的矩形图像. 图像像素按行优先方式存储在 &lt;code&gt;pixels&lt;/code&gt; 中, 每个像素用32位整数以 &lt;code&gt;00RRGGBB&lt;/code&gt; 的方式描述颜色.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#define _DEVREG_INPUT_KBD     1
  ...
  enum {
    _KEY_NONE = 0,
    _KEYS(_KEY_NAME)
  };
  typedef struct {
    int keydown; // is keydown ? 1 : 0
    int keycode; // key code _KEY_XXX
  } _KbdReg;

// ----------- _DEV_TIMER: AM Real Time Clock (0000ac03) -------------
#define _DEVREG_TIMER_UPTIME  1
  typedef struct {
    uint32_t hi; // high 32bit of uptime (ms)
    uint32_t lo; //  low 32bit of uptime (ms)
  } _UptimeReg;

#define _DEVREG_TIMER_DATE    2
  typedef struct {
    int year, month, day;     // date
    int hour, minute, second; // time
  } _RTCReg;

// ----------- _DEV_VIDEO: AM Video Controller (0000ac04) ------------
#define _DEVREG_VIDEO_INFO    1
  typedef struct {
    int32_t width, height; // screen size: @width * @height
  } _VideoInfoReg;

#define _DEVREG_VIDEO_FBCTL   2
  typedef struct {
    int x, y;         // draw to (@x, @y)
    uint32_t *pixels; // @pixels: @w*@h pixels to draw
    int w, h;         //   @pixels[i * w + j] is 00RRGGBB 
    int sync;         // @sync ? sync screen : do nothing
  } _FBCtlReg;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="amtrace.h"&gt;amtrace.h&lt;/h2&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h2 id="x86-nemu"&gt;x86-nemu/&lt;/h2&gt;
&lt;h3 id="x86-nemu-1"&gt;x86-NEMU 编译与运行流程&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在让NEMU运行客户程序之前, 我们需要将客户程序的代码编译成可执行文件. 需要说明的是, 我们不能使用gcc的默认选项直接编译, 因为默认选项会根据GNU/Linux的运行时环境将代码编译成运行在GNU/Linux下的可执行文件. 但此时的NEMU并不能为客户程序提供GNU/Linux的运行时环境, 在NEMU中无法正确运行上述可执行文件, 因此我们不能使用gcc的默认选项来编译用户程序.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决这个问题的方法是&lt;strong&gt;交叉编译&lt;/strong&gt;, 我们需要在GNU/Linux下根据AM的运行时环境编译出能够在 &lt;code&gt;x86-nemu&lt;/code&gt; 这个新环境中运行的可执行文件. 为了不让链接器 &lt;code&gt;ld&lt;/code&gt; 使用默认的方式链接, 我们还需要提供描述 &lt;code&gt;x86-nemu&lt;/code&gt; 的运行时环境的链接脚本. AM的框架代码已经把相应的配置准备好了:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;gcc 将 &lt;code&gt;x86-nemu&lt;/code&gt; 的AM实现的源文件编译成目标文件, 然后通过 ar 将这些目标文件作为一个库, 打包成一个归档文件&lt;/li&gt;
&lt;li&gt;gcc 把应用程序源文件编译成目标文件&lt;/li&gt;
&lt;li&gt;必要的时候通过 gcc 和 ar 把程序依赖的运行库 (如 &lt;code&gt;nexus-am/libs/klib&lt;/code&gt;) 也打包成归档文件&lt;/li&gt;
&lt;li&gt;执行脚本文件 &lt;code&gt;nexus-am/am/arch/x86-nemu/img/build&lt;/code&gt;, 在脚本文件中
&lt;ol&gt;
&lt;li&gt;将程序入口 &lt;code&gt;nexus-am/am/arch/x86-nemu/img/boot/start.S&lt;/code&gt; 编译成目标文件&lt;/li&gt;
&lt;li&gt;最后让 ld 根据链接脚本 &lt;code&gt;nexus-am/am/arch/x86-nemu/img/loader.ld&lt;/code&gt;, 将上述目标文件和归档文件链接成可执行文件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据这一链接脚本的指示, 可执行程序重定位后的节从 &lt;code&gt;0x100000&lt;/code&gt; 开始, 首先是 &lt;code&gt;.text&lt;/code&gt; 节, 其中又以 &lt;code&gt;nexus-am/am/arch/x86-nemu/img/boot/start.o&lt;/code&gt; 中自定义的 &lt;code&gt;entry&lt;/code&gt; 节开始, 然后接下来是其它目标文件的 &lt;code&gt;.text&lt;/code&gt; 节. 这样, 可执行程序的 &lt;code&gt;0x100000&lt;/code&gt; 处总是放置 &lt;code&gt;nexus-am/am/arch/x86-nemu/img/boot/start.S&lt;/code&gt; 的代码, 而不是其它代码, 保证客户程序总能从 &lt;code&gt;0x100000&lt;/code&gt; 开始正确执行. 链接脚本也定义了其它节(包括 &lt;code&gt;.rodata, .data, .bss&lt;/code&gt; )的链接顺序, 还定义了一些关于位置信息的符号, 包括每个节的末尾, 栈顶位置, 堆区的起始和末尾.&lt;/p&gt;
&lt;p&gt;我们对编译得到的可执行文件的行为进行简单的梳理:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一条指令从 &lt;code&gt;nexus-am/am/arch/x86-nemu/img/boot/start.S&lt;/code&gt; 开始, 设置好栈顶之后就跳转到 &lt;code&gt;nexus-am/am/arch/x86-nemu/src/trm.c&lt;/code&gt; 的 &lt;code&gt;_trm_init()&lt;/code&gt; 函数处执行.&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;_trm_init()&lt;/code&gt; 中调用 &lt;code&gt;main()&lt;/code&gt; 函数执行程序的主体功能.&lt;/li&gt;
&lt;li&gt;从 &lt;code&gt;main()&lt;/code&gt; 函数返回后, 调用 &lt;code&gt;_halt()&lt;/code&gt; 结束运行.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="include"&gt;include/&lt;/h3&gt;
&lt;h4 id="arch.h"&gt;arch.h&lt;/h4&gt;
&lt;p&gt;定义了宏 &lt;code&gt;PMEM_SIZE&lt;/code&gt; 指定物理内存大小。&lt;/p&gt;
&lt;h5 id="context-1"&gt;结构体 _Context&lt;/h5&gt;
&lt;p&gt;x86-nemu 上的上下文结构体。其顺序根据上下文构造过程决定（需参考 &lt;code&gt;int pusha&lt;/code&gt; 指令以及 &lt;code&gt;trap.S&lt;/code&gt; 实现）。
上下文构造过程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt; 指令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;trap.S&lt;/code&gt; 中指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pusha&lt;/code&gt; 指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在还原上下文时，仍需要根据上述顺序还原。&lt;/p&gt;
&lt;p&gt;系统调用事件的参数被 CTE 保存到上下文中。为方便处理系统调用事件，定义以下宏对应系统调用参数（根据 &lt;code&gt;navy-apps/libs/libos/src/nanos.c&lt;/code&gt; 中的 &lt;code&gt;_syscall_&lt;/code&gt;）。系统调用类型参见 &lt;code&gt;nanos-lite/syscall.h&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GPR1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;系统调用 ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GPR2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第一个参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GPR3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第二个参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GPR4&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第三个参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;GPRx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;系统调用返回值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="x86-nemu.h"&gt;x86-nemu.h&lt;/h4&gt;
&lt;p&gt;包含了 &lt;code&gt;arch.h&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id="x86.h"&gt;x86.h&lt;/h4&gt;
&lt;p&gt;定义了大量宏常量。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;NR_IRQ&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;IDT 大小&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;定义了辅助函数（使用内联汇编实现）：
|函数|描述|
|-|-|
|&lt;code&gt;uint8_t inb(int port)&lt;/code&gt;|从端口读取一字节值|
|&lt;code&gt;uint16_t inw(int port)&lt;/code&gt;|从端口读取双字节值|
|&lt;code&gt;uint32_t inl(int port)&lt;/code&gt;|从端口读取四字节值|
|&lt;code&gt;void outb(int port, uint8_t data)&lt;/code&gt;|从端口写入一字节值|
|&lt;code&gt;void outw(int port, uint16_t data)&lt;/code&gt;|从端口写入双字节值|
|&lt;code&gt;void outl(int port, uint32_t data)&lt;/code&gt;|从端口写入四字节值|
|&lt;code&gt;void set_idt(GateDesc *idt, int size)&lt;/code&gt;|设置 IDTR 寄存器|&lt;/p&gt;
&lt;h4 id="gatedesc"&gt;结构体 GateDesc&lt;/h4&gt;
&lt;p&gt;指示中断操作的门描述符(Gate Descriptor)类型。与 NEMU 中定义的对应结构体结构相同。&lt;/p&gt;
&lt;p&gt;定义了宏 &lt;code&gt;GATE(type, cs, entry, dpl)&lt;/code&gt; 简化 GateDesc 构造。&lt;/p&gt;
&lt;h3 id="src"&gt;src/&lt;/h3&gt;
&lt;h4 id="devices"&gt;devices/&lt;/h4&gt;
&lt;p&gt;对应于 NEMU 中的设备实现设备访问接口。利用端口映射 I/O 和内存映射 I/O。参见 {% post_link solving/nju-icspa-analytics-nemu#device.c %}。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;键盘访问端口 &lt;code&gt;I8042_DATA_PORT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;时钟访问端口 &lt;code&gt;RTC_PORT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;VGA 访问端口 &lt;code&gt;SCREEN_PORT&lt;/code&gt; 和内存 &lt;code&gt;VMEM&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对每个设备，需要实现 &lt;code&gt;amdev.h&lt;/code&gt; 中特定抽象寄存器的操作。在设备初始化函数 &lt;code&gt;deviceName_init()&lt;/code&gt; 中，可以进行一些初始化操作。&lt;/p&gt;
&lt;h4 id="cte.c"&gt;cte.c&lt;/h4&gt;
&lt;p&gt;定义了 IDT 数组 &lt;code&gt;idt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;_yield()&lt;/code&gt; 实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 x86-nemu 中, 我们约定自陷操作通过 &lt;code&gt;0x81&lt;/code&gt; 号中断（&lt;code&gt;int $0x81&lt;/code&gt;）触发（在 &lt;code&gt;trap.S&lt;/code&gt; 中规定）.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;_cte_init&lt;/code&gt; 实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 IDT
&lt;ul&gt;
&lt;li&gt;设置 &lt;code&gt;vectrap&lt;/code&gt; 与 &lt;code&gt;vecsys&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;设置 IDTR 寄存器（使用 &lt;code&gt;set_idt&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;注册 &lt;code&gt;user_handler&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="irq_handle"&gt;函数 irq_handle&lt;/h5&gt;
&lt;p&gt;硬件级别（NEMU）中断处理函数。根据上下文生成 _Event，调用注册的用户回调函数。&lt;/p&gt;
&lt;h4 id="trap.s"&gt;trap.S&lt;/h4&gt;
&lt;p&gt;给出了 &lt;code&gt;vecsys vectrap irq0 vecnull&lt;/code&gt; 等调用 CTE 处理过程的函数。&lt;/p&gt;
&lt;h5 id="asm_trap"&gt;函数 asm_trap&lt;/h5&gt;
&lt;p&gt;构造上下文，调用函数 &lt;code&gt;irq_handle&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id="libs"&gt;libs/&lt;/h1&gt;
&lt;h2 id="klib"&gt;klib/&lt;/h2&gt;
&lt;p&gt;Kernal Library. 提供一些兼容 libc 的基础功能。&lt;/p&gt;
&lt;h3 id="includeklib.h"&gt;include/klib.h&lt;/h3&gt;
&lt;p&gt;定义了 klib 中定义的的函数。&lt;/p&gt;
&lt;p&gt;框架代码编译到 native 的时候默认链接到 glibc，可以使用宏 &lt;code&gt;__NATIVE_USE_KLIB__&lt;/code&gt; 使这些调用链接到这里实现的 klib.&lt;/p&gt;
&lt;h3 id="src-1"&gt;src/&lt;/h3&gt;
&lt;h4 id="stdio.c"&gt;stdio.c&lt;/h4&gt;
&lt;p&gt;标准输入输出。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vsnprintf&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;变长参数列表输出到字符串，限制最大字符数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vsprintf&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;变长参数列表输出到字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;snprintf&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;输出到字符串，限制最大字符数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sprintf&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;输出到字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;输出到串口设备&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="string.c"&gt;string.c&lt;/h4&gt;
&lt;p&gt;字符串操作。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;strlen&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;strcpy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;strncpy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;strcat&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;strcmp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;strncmp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;memset&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;memcpy&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;memcmp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="stdlib.c"&gt;stdlib.c&lt;/h4&gt;
&lt;p&gt;标准库函数。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="io.c"&gt;io.c&lt;/h4&gt;
&lt;p&gt;常用的输入输出功能。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;// 返回系统启动后经过的毫秒数
uint32_t uptime();
// 在 rtc 结构中返回当前时间, PA中不会用到
void get_timeofday(void *rtc);
// 返回按键的键盘码, 若无按键, 则返回 _KEY_NONE 
int read_key();
// 将 pixels 指定的矩形像素绘制到屏幕中以 (x, y) 和 (x+w, y+h) 两点连线为对角线的矩形区域
void draw_rect(uint32_t *pixels, int x, int y, int w, int h);
// 将之前的绘制内容同步到屏幕上
void draw_sync();
// 返回屏幕的宽度
int screen_width();
// 返回屏幕的高度
int screen_height();
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="cpp.c"&gt;cpp.c&lt;/h4&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h1 id="apps"&gt;apps/&lt;/h1&gt;
&lt;p&gt;直接运行在AM上的应用。&lt;/p&gt;
&lt;h2 id="microbench"&gt;microbench/&lt;/h2&gt;
&lt;p&gt;性能测试程序 3。microbench提供了两个不同规模的测试集test和ref. 其中ref测试集规模较大, 用于跑分测试, 默认会编译ref测试集; test测试集规模较小, 用于正确性测试, 需要在运行make时显式指定编译test测试集:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;make INPUT=TEST
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="tests"&gt;tests/&lt;/h1&gt;
&lt;p&gt;直接运行在AM上的测试。&lt;/p&gt;
&lt;p&gt;使用测试方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进入测试项目目录&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;make run&lt;/code&gt; 运行测试
&lt;ul&gt;
&lt;li&gt;可使用 &lt;code&gt;ARCH=native&lt;/code&gt; 指定 AM&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="cputest"&gt;cputest/&lt;/h2&gt;
&lt;p&gt;包含一些测试 CPU 指令实现的测试。
使用 &lt;code&gt;make ALL=testname run&lt;/code&gt; 指定测试。&lt;/p&gt;
&lt;h1 id="section-4"&gt;引用资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://legacy.gitbook.com/book/nju-ics/ics2018-programming-assignment/details"&gt;ICS2018 PA 讲义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Learning/nju-icspa-analytics-nemu</id><title type="text">NJU ICS Programming Assignment 代码分析 - NEMU</title><summary type="text">概述
框架代码库
CPU 架构：x64
操作系统: GNU/Linux
编译器: GCC
编程语言：C 语言
由于 NJU ICS PA 框架代码较多且缺少足够说明，讲义多为基础引入内容，为方便后续程</summary><published>2018-10-05T19:30:22+08:00</published><updated>2018-10-05T19:30:22+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Learning%2Fnju-icspa-analytics-nemu" /><category term="Learning" /><content type="html">&lt;h1 id="section"&gt;概述&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/NJU-ProjectN/nemu"&gt;框架代码库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CPU 架构：x64&lt;/li&gt;
&lt;li&gt;操作系统: GNU/Linux&lt;/li&gt;
&lt;li&gt;编译器: GCC&lt;/li&gt;
&lt;li&gt;编程语言：C 语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 NJU ICS PA 框架代码较多且缺少足够说明，讲义多为基础引入内容，为方便后续程序编写，根据实际作业过程中的理解整理出此文。
本文主要包含对 NJU ICS 课程编程作业的框架代码中 NEMU 部分的理解和分析，跟随课程及讲义进度更新，以个人使用为主，可能存在错误。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;部分内容框架代码并不包含（如扩展的 Debug 宏），均为我为编码而添加的内容。采用 &lt;code&gt;a_b&lt;/code&gt; 方式命名的多为原内容，采用 &lt;code&gt;aB&lt;/code&gt; 方式命名的多为补充内容。由于此项目是 NJU ICS PA 的一部分，其中会包含与相关项目的互操作内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;NEMU (NJU EMUlator) 是在 Linux 上的一个 n86（x86 子集）模拟器，模拟了基本计算机系统的功能（内存，CPU等）。包含了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存&lt;/li&gt;
&lt;li&gt;CPU，寄存器&lt;/li&gt;
&lt;li&gt;调试器（监视器）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;框架代码结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;nanos-lite/
navy-apps/
nexus-am/
nemu/               # NEMU 项目
    build/          # 构建输出文件夹
        nemu        # NEMU 主程序（可执行文件）
    include/        # 头文件
    src/            # 源码文件
    tools/          # 工具文件
    runall.sh       # 测试 AM cputest 测试集 （nexus-am/tests/cputest）
    Makefile        # NEMU 构建命令
    Makefile.git    # NEMU Git 记录命令
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="include"&gt;include/&lt;/h1&gt;
&lt;h2 id="nemu.h"&gt;nemu.h&lt;/h2&gt;
&lt;p&gt;基础头文件。包含了 &lt;code&gt;commom.h&lt;/code&gt;，&lt;code&gt;memory/memory.h&lt;/code&gt;，&lt;code&gt;cpu/reg.h&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="macro.h"&gt;macro.h&lt;/h2&gt;
&lt;p&gt;定义了一些字符串连接宏 &lt;code&gt;concat&lt;/code&gt; 等。&lt;/p&gt;
&lt;h2 id="common.h"&gt;common.h&lt;/h2&gt;
&lt;p&gt;定义了一些类型别名。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型别名&lt;/th&gt;
&lt;th&gt;原类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;rtlreg_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;uint32_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;RTL寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;vaddr_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;uint32_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;虚拟地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;paddr_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;uint32_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;物理地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ioaddr_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;uint16_t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;I/O 端口地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;relreg_t&lt;/code&gt; 多用于寄存器访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vaddr_t&lt;/code&gt; &lt;code&gt;paddr_t&lt;/code&gt; 多用于内存访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ioaddr_t&lt;/code&gt; 多用于设备 I/O 端口访问&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义了一些控制编译方式的宏。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DEBUG&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;启用调试&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DIFF_TEST&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;启用 diff-test&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;HAS_IOE&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;启用输入输出扩展&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DIFF_TEST&lt;/code&gt; 可启用一个差异测试工具，参见 &lt;code&gt;tools/qemu-diff&lt;/code&gt; 部分。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HAS_IOE&lt;/code&gt; 启用输入输出设备，参见设备部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="debug.h"&gt;debug.h&lt;/h2&gt;
&lt;p&gt;定义了便于调试的宏。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Log_write(format, ...)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;仅记录日志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;printflog(format, ...)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示文本并记录日志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Log(format, ...)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对 &lt;code&gt;printflog&lt;/code&gt; 的扩展，包含当前文件，行，函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Info(format, ...)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对 &lt;code&gt;Log&lt;/code&gt; 的扩展，日志级别：提示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Warning(format, ...)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对 &lt;code&gt;Log&lt;/code&gt; 的扩展，日志级别：警告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Error(format, ...)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对 &lt;code&gt;Log&lt;/code&gt; 的扩展，日志级别：错误&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;panic(format, ...)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;强制退出，显示文本并记录日志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Assert(cond [, format, ...])&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置断言，失败时强制退出，显示文本并记录日志&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;TODO()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标识待完成项，执行时会触发 &lt;code&gt;panic&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="cpu"&gt;cpu/&lt;/h2&gt;
&lt;h3 id="reg.h"&gt;reg.h&lt;/h3&gt;
&lt;p&gt;定义了寄存器结构，和辅助寄存器的一些宏和函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;外部数组 &lt;code&gt;regsl, regsw, regsb&lt;/code&gt; 不同寄存器名。实现在 &lt;code&gt;src/cpu/reg.c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;extern const char* regsl[];
extern const char* regsw[];
extern const char* regsb[];
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="cpu_state"&gt;结构体 CPU_state&lt;/h4&gt;
&lt;p&gt;寄存器结构，包含了所有寄存器，均为无符号整数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 8 个通用寄存器，内部以 &lt;code&gt;gpr&lt;/code&gt; 数组为基础结构，提供 &lt;code&gt;eax&lt;/code&gt; 等别名方便访问。寄存器按照 i386 指令中寄存器标号顺序排列。可使用 &lt;code&gt;_16,_8[0],_8[1]&lt;/code&gt; 访问寄存器低位部分。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eip&lt;/code&gt; 当前执行指令位置寄存器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eflags&lt;/code&gt; 标志位寄存器（使用匿名结构体，可直接访问 &lt;code&gt;CF,OF,ZF,SF&lt;/code&gt;）
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;eflags&lt;/code&gt; 初始化为 &lt;code&gt;0x2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cs,ss,ds,es,fs,gs&lt;/code&gt; 程序段寄存器（仅为支持 diff-test）
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cs&lt;/code&gt; 初始化为 &lt;code&gt;8&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;idtr&lt;/code&gt; 48 位寄存器，存放 IDT (Interrupt Descriptor Table, 中断描述符表)的首地址和长度
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;limit&lt;/code&gt; 16位，长度，单位：字节&lt;/li&gt;
&lt;li&gt;&lt;code&gt;base&lt;/code&gt; 32位，IDT 基地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数/宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;reg_l(index)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取指定下标处寄存器32位值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;reg_w(index)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取指定下标处寄存器低16位值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;reg_b(index)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取指定下标处寄存器低8位值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;reg_name(index,width)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据下标和位宽获得寄存器名&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;{% note info %}
寄存器存储在变量 &lt;code&gt;cpu&lt;/code&gt; 中。
{% endnote %}&lt;/p&gt;
&lt;h4 id="section-2"&gt;枚举&lt;/h4&gt;
&lt;p&gt;定义了形如 &lt;code&gt;R_NAME&lt;/code&gt; 的寄存器枚举，其顺序与寄存器结构中的顺序一致。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;enum { R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI };
enum { R_AX, R_CX, R_DX, R_BX, R_SP, R_BP, R_SI, R_DI };
enum { R_AL, R_CL, R_DL, R_BL, R_AH, R_CH, R_DH, R_BH };
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="decode.h"&gt;decode.h&lt;/h3&gt;
&lt;p&gt;定义了用于指令译码的结构和函数。&lt;/p&gt;
&lt;h4 id="operand"&gt;结构体 Operand&lt;/h4&gt;
&lt;p&gt;操作数。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;类型（见下方枚举）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;width&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;位宽&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;val&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;实际值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;str&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;原串（用于调试输出）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;reg&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;寄存器下标&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;addr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内存地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;imm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;立即数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;simm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;带符号立即数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="decodeinfo"&gt;结构体 DecodeInfo&lt;/h4&gt;
&lt;p&gt;单条命令译码结果。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;对应x86指令部分&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;opcode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指令码&lt;/td&gt;
&lt;td&gt;opcode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;seq_eip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;序列 EIP 位置&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;is_operand_size_16&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标识操作数是否为 16 位&lt;/td&gt;
&lt;td&gt;operand-size prefix&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ext_opcode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;额外指令码&lt;/td&gt;
&lt;td&gt;ModR/M 中 opcode&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;is_jmp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标识是否为跳转语句&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;jmp_eip&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;跳转目标（绝对地址），仅对于跳转语句&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;src&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;源操作数&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;src2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;第二个源操作数&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dest&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;目标操作数&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;assembly&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;asm_buf&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;p&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;seq_eip&lt;/code&gt; 随译码过程改变，最终停留在需要译码的下一个位置，可根据这一值实现 eip 更新。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_operand_size_16&lt;/code&gt; 多用于实现单命令存在 16 位，32 位两个版本的情况&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ext_opcode&lt;/code&gt; 用于实现 &lt;code&gt;sub /5&lt;/code&gt; 这种根据第二个指令码 &lt;code&gt;/5&lt;/code&gt; 区分不同指令的情况，在译码中使用 &lt;code&gt;make_group&lt;/code&gt; 实现。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_jmp&lt;/code&gt; 多在运行时指定（如 &lt;code&gt;rtl_j&lt;/code&gt; 函数），如果标记，则不会再根据 &lt;code&gt;seq_eip&lt;/code&gt; 更新 eip&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数/宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;id_src&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(&amp;amp;decoding.src)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;id_src2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(&amp;amp;decoding.src2)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;id_dest&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(&amp;amp;decoding.dest)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;operand_write(Operand *, rtlreg_t *)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据第一个参数中记录的类型的不同进行相应的写操作，包括写寄存器和写内存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;load_addr(vaddr_t *, ModR_M *, Operand *)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;read_ModR_M(vaddr_t *, Operand *, bool, Operand *, bool)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;{% note info %}
译码内容存储在变量 &lt;code&gt;decoding&lt;/code&gt; 中。
{% endnote %}&lt;/p&gt;
&lt;h4 id="modr_m"&gt;结构体 ModR_M&lt;/h4&gt;
&lt;p&gt;指令中的 ModR/M。&lt;/p&gt;
&lt;h4 id="sib"&gt;结构体 SIB&lt;/h4&gt;
&lt;p&gt;指令中的 SIB。&lt;/p&gt;
&lt;h4 id="section-3"&gt;枚举&lt;/h4&gt;
&lt;p&gt;定义了操作数的类型 &lt;code&gt;OP_TYPE_REG&lt;/code&gt;，&lt;code&gt;OP_TYPE_MEM&lt;/code&gt;，&lt;code&gt;OP_TYPE_IMM&lt;/code&gt;，分别为寄存器，内存，立即数。&lt;/p&gt;
&lt;h4 id="make_dhelper-decode_name"&gt;宏 make_DHelper 与函数族 decode_name&lt;/h4&gt;
&lt;p&gt;由宏 &lt;code&gt;make_DHelper&lt;/code&gt; 定义了一族函数（参数相同），用于指令译码，并定义了这些函数的指针类型 &lt;code&gt;DHelper&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计目的：由于大量指令的操作数模式相似，将这一点提取出来，实现解耦。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#define make_DHelper(name) void concat(decode_, name) (vaddr_t *eip)
typedef void (*DHelper) (vaddr_t *);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数族中部分函数命名规则（&lt;strong&gt;不全&lt;/strong&gt;）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;I&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;立即数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SI&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;有符号立即数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;E&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内存或寄存器（对应指令描述中的 r/m）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;通用寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单一寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指定寄存器为 &lt;code&gt;eax,ax,al&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;I2G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;立即数到通用寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;I_E2G&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;立即数与内存或寄存器到通用寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;O&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;未知&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 一般用于寄存器信息存储在 &lt;code&gt;opcode&lt;/code&gt; 中的情况&lt;/li&gt;
&lt;li&gt;还有一些专用于特定指令的译码函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% note info %}
建议结合 i386 手册附录 C 理解。
{% endnote %}&lt;/p&gt;
&lt;p&gt;函数族中特殊函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;J&lt;/code&gt; 跳转指令解码。单操作数，存储到 &lt;code&gt;jmp_eip&lt;/code&gt; 中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="exec.h"&gt;exec.h&lt;/h3&gt;
&lt;p&gt;定义了一些用于调试的指令打印宏：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;print_asm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打印指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;suffix_char&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据宽度获取指令宽度后缀&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;print_asm_template1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;单操作数指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;print_asm_template2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;双操作数指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;print_asm_template3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;三操作数指令&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="instr_fetch"&gt;函数 instr_fetch&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;uint32_t instr_fetch(vaddr_t *eip, int len)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从 &lt;code&gt;eip&lt;/code&gt; 开始，读取 &lt;code&gt;len&lt;/code&gt; 个字节，返回值，并自动增加 &lt;code&gt;eip&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设计目的：与机器的大端小端解耦。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="make_ehelper-exec_name"&gt;宏 make_EHelper 与 函数族 exec_name&lt;/h4&gt;
&lt;p&gt;用于定义一族函数（参数相同），用于指令执行，并定义了这些函数的指针类型 &lt;code&gt;EHelper&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#define make_EHelper(name) void concat(exec_, name) (vaddr_t *eip)
typedef void (*EHelper) (vaddr_t *);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="relop.h"&gt;relop.h&lt;/h3&gt;
&lt;p&gt;定义了形如 &lt;code&gt;RELOP_NAME&lt;/code&gt; 的枚举，标识不同类型的关系运算。对应了 &lt;code&gt;setcc,jcc&lt;/code&gt; 命令的相应编码。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;enum {
  //            +-- unsign
  //            |   +-- sign
  //            |   |   +-- equal
  //            |   |   |   +-- invert
  //            |   |   |   |
  RELOP_FALSE = 0 | 0 | 0 | 0,
  RELOP_TRUE  = 0 | 0 | 0 | 1,
  RELOP_EQ    = 0 | 0 | 2 | 0,
  RELOP_NE    = 0 | 0 | 2 | 1,

  RELOP_LT    = 0 | 4 | 0 | 0,
  RELOP_LE    = 0 | 4 | 2 | 0,
  RELOP_GT    = 0 | 4 | 2 | 1,
  RELOP_GE    = 0 | 4 | 0 | 1,

  RELOP_LTU   = 8 | 0 | 0 | 0,
  RELOP_LEU   = 8 | 0 | 2 | 0,
  RELOP_GTU   = 8 | 0 | 2 | 1,
  RELOP_GEU   = 8 | 0 | 0 | 1,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="cc.h"&gt;cc.h&lt;/h3&gt;
&lt;p&gt;定义了函数 &lt;code&gt;get_cc_name&lt;/code&gt; 根据编码获取指定关系运算字符串。&lt;/p&gt;
&lt;p&gt;定义了 RTL 基本指令 &lt;code&gt;rtl_setcc&lt;/code&gt; 用于根据当前关系运算和 eflags 寄存器标志位设置 dest。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void rtl_setcc(rtlreg_t*, uint8_t);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="rtl.h"&gt;rtl.h&lt;/h3&gt;
&lt;p&gt;定义和实现了一些 RTL 指令，用于提供对指令执行的底层建模。可使用这些操作将复杂指令分解成更简单的操作。&lt;/p&gt;
&lt;p&gt;NEMU 中的 RTL 寄存器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x86的八个通用寄存器(在 &lt;code&gt;include/cpu/reg.h&lt;/code&gt; 中定义)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;id_src&lt;/code&gt;, &lt;code&gt;id_src2&lt;/code&gt; 和 &lt;code&gt;id_dest&lt;/code&gt; 中的访存地址 &lt;code&gt;addr&lt;/code&gt; 和操作数内容 &lt;code&gt;val&lt;/code&gt; (在 &lt;code&gt;include/cpu/decode.h&lt;/code&gt; 中定义). 从概念上看, 它们分别与MAR和 MDR有异曲同工之妙&lt;/li&gt;
&lt;li&gt;临时寄存器 &lt;code&gt;t0~t3&lt;/code&gt; 和 &lt;code&gt;at&lt;/code&gt; (在 &lt;code&gt;src/cpu/decode/decode.c&lt;/code&gt; 中定义)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;extern rtlreg_t t0, t1, t2, t3, at;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;宏 &lt;code&gt;make_rtl_arith_logic&lt;/code&gt; 根据算术运算符名创建对应 RTL 基本指令和 RTL 指令，使用了 &lt;code&gt;include/util/c_op.h&lt;/code&gt; 中的运算。
&lt;ul&gt;
&lt;li&gt;32位寄存器-寄存器类型的算术/逻辑运算&lt;/li&gt;
&lt;li&gt;32位寄存器-立即数类型的算术/逻辑运算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;定义函数 &lt;code&gt;decoding_set_jmp(bool is_jmp)&lt;/code&gt; ：将 当前指令标记为跳转（标记 &lt;code&gt;decoing.is_jmp&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;定义函数 &lt;code&gt;interpret_relop&lt;/code&gt; ：实现两个值的关系运算，返回结果（实现在 &lt;code&gt;src/cpu/exec/relop.c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="rtl"&gt;RTL 基本指令&lt;/h4&gt;
&lt;p&gt;特点：不需要使用临时寄存器, 可以看做是最基本的x86指令中的最基本的操作。
实现时添加了 &lt;code&gt;interpret_&lt;/code&gt; 前缀，但在 &lt;code&gt;include/cpu/rtl-wrapper.h&lt;/code&gt; 作用下，其它代码中使用到这些RTL基本指令时会自动添加 &lt;code&gt;interpret_&lt;/code&gt; 前缀。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;立即数读入 &lt;code&gt;rtl_li&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;寄存器传输 &lt;code&gt;rtl_mv&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;32位寄存器-寄存器类型的算术/逻辑运算, 包括 &lt;code&gt;rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])&lt;/code&gt; , 这些运算的定义用到  &lt;code&gt;include/util/c_op.h&lt;/code&gt; 中的C语言运算&lt;/li&gt;
&lt;li&gt;被除数为64位的除法运算 &lt;code&gt;rtl_i?div64_[q|r]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;guest内存访问 &lt;code&gt;rtl_lm&lt;/code&gt; 和 &lt;code&gt;rtl_sm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;host内存访问 &lt;code&gt;rtl_host_lm&lt;/code&gt; 和 &lt;code&gt;rtl_host_sm&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关系运算 &lt;code&gt;rtl_setrelop&lt;/code&gt;, 具体可参考 &lt;code&gt;src/cpu/exec/relop.c&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;跳转, 包括直接跳转 &lt;code&gt;rtl_j&lt;/code&gt; , 间接跳转 &lt;code&gt;rtl_jr&lt;/code&gt; 和条件跳转 &lt;code&gt;rtl_jrelop&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;终止程序 &lt;code&gt;rtl_exit&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体声明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未标明则函数修饰符均为 &lt;code&gt;static inline&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;// 立即数读入
void interpret_rtl_li(rtlreg_t* dest, uint32_t imm);

// 寄存器传输
void interpret_rtl_mv(rtlreg_t* dest, const rtlreg_t *src1);

// 32位寄存器-寄存器类型的算术/逻辑运算
void interpret_rtl_add (rtlreg_t* dest, const rtlreg_t* src1, const rtlreg_t* src2);

// 被除数为64位的除法运算
void interpret_rtl_div64_q(rtlreg_t* dest,
    const rtlreg_t* src1_hi, const rtlreg_t* src1_lo, const rtlreg_t* src2);

// guest内存访问
void interpret_rtl_lm(rtlreg_t *dest, const rtlreg_t* addr, int len);
void interpret_rtl_sm(const rtlreg_t* addr, const rtlreg_t* src1, int len);

// host内存访问
void interpret_rtl_host_lm(rtlreg_t* dest, const void *addr, int len);
void interpret_rtl_host_sm(void *addr, const rtlreg_t *src1, int len);

// 关系运算
void interpret_rtl_setrelop(uint32_t relop, rtlreg_t *dest, const rtlreg_t *src1, const rtlreg_t *src2);

// 跳转
void interpret_rtl_j(vaddr_t target);
void interpret_rtl_jr(rtlreg_t *target);
void interpret_rtl_jrelop(uint32_t relop, const rtlreg_t *src1, const rtlreg_t *src2, vaddr_t target);

// 终止程序
void interpret_rtl_exit(int state);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="rtl-1"&gt;RTL 伪指令&lt;/h4&gt;
&lt;p&gt;通过RTL基本指令或者已经实现的RTL伪指令来实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32位寄存器-立即数类型的算术/逻辑运算, 包括 &lt;code&gt;rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])_i&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通用寄存器访问 &lt;code&gt;rtl_lr&lt;/code&gt; 和 &lt;code&gt;rtl_sr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;EFLAGS标志位的读写 &lt;code&gt;rtl_set_(CF|OF|ZF|SF)&lt;/code&gt; 和 &lt;code&gt;rtl_get_(CF|OF|ZF|SF)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其它常用功能, 如按位取反 &lt;code&gt;rtl_not&lt;/code&gt; ，符号扩展 &lt;code&gt;rtl_sext&lt;/code&gt; 等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体声明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未标明则函数修饰符均为 &lt;code&gt;static inline&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;宏 &lt;code&gt;make_rtl_setget_eflags&lt;/code&gt; 声明了需要实现的 EFLAGS标志位的读写 指令
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;rtl_set_name&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rtl_get_name&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;// 32位寄存器-立即数类型的算术/逻辑运算
void rtl_addi (rtlreg_t* dest, const rtlreg_t* src1, int imm)

// 通用寄存器访问
void rtl_lr(rtlreg_t* dest, int r, int width);
void rtl_sr(int r, const rtlreg_t* src1, int width);

// EFLAGS标志位的读写
void rtl_set_CF (const rtlreg_t* src);
void rtl_get_CF (rtlreg_t* dest);
void rtl_set_OF (const rtlreg_t* src);
void rtl_get_OF (rtlreg_t* dest);
void rtl_set_ZF (const rtlreg_t* src);
void rtl_get_ZF (rtlreg_t* dest);
void rtl_set_SF (const rtlreg_t* src);
void rtl_get_SF (rtlreg_t* dest);

// 根据运算结构更新 ZF, SF 标志位
void rtl_update_ZF(const rtlreg_t* result, int width);
void rtl_update_SF(const rtlreg_t* result, int width);
void rtl_update_ZFSF(const rtlreg_t* result, int width);

// 按位取反
void rtl_not(rtlreg_t *dest, const rtlreg_t* src1);

// 符号扩展
void rtl_sext(rtlreg_t* dest, const rtlreg_t* src1, int width);

// 压栈
void rtl_push(const rtlreg_t* src1);

// 弹栈
void rtl_pop(rtlreg_t* dest);

// 32位寄存器-立即数类型 关系运算
void rtl_setrelopi(uint32_t relop, rtlreg_t *dest, const rtlreg_t *src1, int imm);

// 取符号位（最高位）
void rtl_msb(rtlreg_t* dest, const rtlreg_t* src1, int width);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;{% note warning %}
我们定义RTL基本指令的时候, 约定了RTL基本指令不需要使用RTL临时寄存器. 但某些RTL伪指令需要使用临时寄存器存放中间结果, 才能实现其完整功能. 这样可能会带来寄存器覆盖的问题, 例如如下RTL指令序列:
&lt;code&gt;
(1) rtl_mv(&amp;amp;t0, &amp;amp;t1);
(2) rtl_sext(&amp;amp;t1, &amp;amp;t2, 1);  // use t0 temporarily
(3) rtl_add(&amp;amp;t2, &amp;amp;t0, &amp;amp;t1);
&lt;/code&gt;
如果实现(2)的时候恰好使用到了t0作为临时寄存器, 在(3)中使用的t0就不再是(1)的结果了, 从而产生非预期的结果.&lt;/p&gt;
&lt;p&gt;为了尽可能避免上述问题, 我们有两条约定:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现RTL伪指令的时候, 尽可能不使用 &lt;code&gt;dest&lt;/code&gt; 之外的寄存器存放中间结果. 由于 &lt;code&gt;dest&lt;/code&gt; 最后会被写入新值, 其旧值肯定要被覆盖, 自然也可以安全地作为RTL伪指令的临时寄存器.&lt;/li&gt;
&lt;li&gt;实在需要使用临时寄存器的时候, 使用 &lt;code&gt;at&lt;/code&gt; . &lt;code&gt;at&lt;/code&gt; 全称是assembly temporary, 是MIPS ABI中定义的一个特殊寄存器: 编译器并不会使用它, 它可以在编写汇编代码的时候安全地作为可使用的临时寄存器. 在这里， 我们借鉴它的功能来作如下约定: 不要在RTL伪指令的内部实现之外使用 &lt;code&gt;at&lt;/code&gt; . 这样， &lt;code&gt;at&lt;/code&gt; 就可以安全地作为RTL伪指令的临时寄存器了.
{% endnote %}&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rtl-wrapper.h"&gt;rtl-wrapper.h&lt;/h3&gt;
&lt;p&gt;为 rtl.h 中定义的 RTL 基本指令的调用省去 &lt;code&gt;interpret_&lt;/code&gt; 前缀。&lt;/p&gt;
&lt;h2 id="memory"&gt;memory/&lt;/h2&gt;
&lt;h3 id="memory.h"&gt;memory.h&lt;/h3&gt;
&lt;p&gt;定义了访问内存的函数。使用数组 &lt;code&gt;pmem&lt;/code&gt; 模拟内存。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;extern uint8_t pmem[];
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数/宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;uint32_t vaddr_read(vaddr_t, int)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从虚拟内存指定位置读取指定数目个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void vaddr_write(vaddr_t, uint32_t, int)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向虚拟内存指定位置写入指定数目个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;uint32_t paddr_read(paddr_t, int)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从物理内存指定位置读取指定数目个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void paddr_write(paddr_t, uint32_t, int)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;向物理内存指定位置写入指定数目个字节&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;guest_to_host(p)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;((void *)(pmem + (unsigned)p))&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;host_to_guest(p)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;((paddr_t)((void *)p - (void *)pmem))&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="mmu.h"&gt;mmu.h&lt;/h3&gt;
&lt;p&gt;(TODO)&lt;/p&gt;
&lt;h4 id="gatedesc"&gt;结构体 GateDesc&lt;/h4&gt;
&lt;p&gt;指示中断操作的门描述符(Gate Descriptor)类型。门描述符是一个8字节的结构体, 里面包含着不少细节的信息, 在NEMU中简化了门描述符的结构, 只保留存在位P和偏移量OFFSET。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   31                23                15                7                0
  +-----------------+-----------------+---+-------------------------------+
  |           OFFSET 31..16           | P |          Don't care           |4
  +-----------------------------------+---+-------------------------------+
  |             Don't care            |           OFFSET 15..0            |0
  +-----------------+-----------------+-----------------+-----------------+
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;raise_intr&lt;/code&gt;（定义在 &lt;code&gt;intr.c&lt;/code&gt; 中）中使用。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;offset_15_0&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Offset 低位部分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;offset_31_16&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Offset 高位部分&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;present&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标识是否有效&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;为方便从内存中读取，使用 union 结构以及 &lt;code&gt;val0 val1&lt;/code&gt; 域简化读写。&lt;/li&gt;
&lt;li&gt;此结构体与 AM 中定义的 &lt;code&gt;GateDesc&lt;/code&gt; （在 &lt;code&gt;arch/x86-nemu/include/x86.h&lt;/code&gt; 中）结构相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="device"&gt;device/&lt;/h2&gt;
&lt;h3 id="mmio.h"&gt;mmio.h&lt;/h3&gt;
&lt;p&gt;对内存映射 I/O 编址方式的支持。注意，内存映射 I/O 的读写并不是面向 CPU 的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;端口映射I/O把端口号作为I/O指令的一部分, 这种方法很简单, 但同时也是它最大的缺点. 指令集为了兼容已经开发的程序, 是只能添加但不能修改的. 这意味着, 端口映射I/O所能访问的I/O地址空间的大小, 在设计I/O指令的那一刻就已经决定下来了. 所谓I/O地址空间, 其实就是所有能访问的设备的地址的集合. 随着设备越来越多, 功能也越来越复杂, I/O地址空间有限的端口映射I/O已经逐渐不能满足需求了. 有的设备需要让CPU访问一段较大的连续存储空间, 如VGA的显存, 24色加上Alpha通道的1024x768分辨率的显存就需要3MB的编址范围. 于是内存映射I/O(memory-mapped I/O)应运而生.
内存映射I/O这种编址方式非常巧妙, 它是通过不同的物理内存地址给设备编址的. 这种编址方式将一部分物理内存&amp;quot;重定向&amp;quot;到I/O地址空间中, CPU尝试访问这部分物理内存的时候, 实际上最终是访问了相应的I/O设备, CPU却浑然不知. 这样以后, CPU就可以通过普通的访存指令来访问设备. 这也是内存映射I/O得天独厚的好处: 物理内存的地址空间和CPU的位宽都会不断增长, 内存映射I/O从来不需要担心I/O地址空间耗尽的问题. 从原理上来说, 内存映射I/O唯一的缺点就是, CPU无法通过正常渠道直接访问那些被映射到I/O地址空间的物理内存了. 但随着计算机的发展, 内存映射I/O的唯一缺点已经越来越不明显了: 现代计算机都已经是64位计算机, 物理地址线都有48根, 这意味着物理地址空间有256TB这么大, 从里面划出3MB的地址空间给显存, 根本就是不痛不痒. 正因为如此, 内存映射I/O成为了现代计算机主流的I/O编址方式: RISC架构只提供内存映射I/O的编址方式, 而PCI-e, 网卡, x86的APIC等主流设备, 都支持通过内存映射I/O来访问.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;{% note info %}
在 NEMU 中， video memory是唯一使用内存映射 I/O 方式访问的 I/O 空间。
{% endnote %}&lt;/p&gt;
&lt;p&gt;定义了类型 &lt;code&gt;mmio_callback_t&lt;/code&gt; ，设备定义的回调函数，用以更新设备状态。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;typedef void(*mmio_callback_t)(paddr_t, int, bool);
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void* add_mmio_map(paddr_t, int, mmio_callback_t)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;注册一个内存映射 I/O 映射关系，返回该映射关系的 I/O 空间首地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int is_mmio(paddr_t)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;判断一个物理地址是否被映射到 I/O 空间，如果是，返回映射号, 否则返回 -1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;uint32_t mmio_read(paddr_t, int, int)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据端口号和地址读取&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void mmio_write(paddr_t, int, uint32_t, int)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据端口号和地址写入&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="port-io.h"&gt;port-io.h&lt;/h3&gt;
&lt;p&gt;对端口映射 I/O 编址方式的支持。端口映射I/O(port-mapped I/O)， CPU使用专门的I/O指令对设备进行访问， 并把设备的地址称作端口号。 有了端口号以后， 在I/O指令中给出端口号， 就知道要访问哪一个设备寄存器了。&lt;/p&gt;
&lt;p&gt;定义了类型 &lt;code&gt;pio_callback_t&lt;/code&gt; ，设备定义的回调函数，用以更新设备状态。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;typedef void(*pio_callback_t)(ioaddr_t, int, bool);
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void* add_pio_map(paddr_t, int, mmio_callback_t)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;注册一个端口映射 I/O 映射关系，返回该映射关系的 I/O 空间首地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;uint32_t pio_read_[l,w,b](ioaddr_t)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;面向 CPU 的端口 I/O 读接口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;void pio_write_[l,w,b](ioaddr_t, uint32_t)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;面向 CPU 的端口 I/O 写接口&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="monitor"&gt;monitor/&lt;/h2&gt;
&lt;p&gt;监视器部分（也包含 NEMU 执行主循环）。&lt;/p&gt;
&lt;h3 id="expr.h"&gt;expr.h&lt;/h3&gt;
&lt;p&gt;定义了计算表达式的值的函数 &lt;code&gt;expr&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;uint32_t expr(char *, bool *);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="monitor.h"&gt;monitor.h&lt;/h3&gt;
&lt;p&gt;定义了 NEMU 状态 变量 &lt;code&gt;nemu_state&lt;/code&gt;，和枚举值 &lt;code&gt;NEMU_STOP, NEMU_RUNNING, NEMU_END, NEMU_ABORT&lt;/code&gt;。
定义了 应用程序入口点 &lt;code&gt;ENTRY_START&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#define ENTRY_START 0x100000
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="watchpoint.h"&gt;watchpoint.h&lt;/h3&gt;
&lt;h4 id="wp"&gt;结构体 WP&lt;/h4&gt;
&lt;p&gt;监视点结构。采用链表结构存储。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;NO&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;序号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;next&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;下一监视点指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;expr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;监视的表达式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;lastVal&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表达式最近一次的值&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="util"&gt;util/&lt;/h2&gt;
&lt;h3 id="c_op.h"&gt;c_op.h&lt;/h3&gt;
&lt;p&gt;定义了一些形如 &lt;code&gt;c_opname_type&lt;/code&gt; 的宏，用于表示基础 C 运算。在 RTL基本指令中的寄存器运算指令中使用。&lt;/p&gt;
&lt;h1 id="src"&gt;src/&lt;/h1&gt;
&lt;h2 id="main.c"&gt;main.c&lt;/h2&gt;
&lt;p&gt;NEMU 主程序。&lt;/p&gt;
&lt;p&gt;调用 &lt;code&gt;init_monitor&lt;/code&gt; （实现在 &lt;code&gt;/src/monitor/monitor.c&lt;/code&gt;）初始化监视器，并获取当前是否为批处理模式。
调用 &lt;code&gt;ui_mainloop&lt;/code&gt; （实现在 &lt;code&gt;/src/monitor/debug/ui.c&lt;/code&gt;）进行指令执行模拟。&lt;/p&gt;
&lt;h2 id="cpu-1"&gt;cpu/&lt;/h2&gt;
&lt;h3 id="reg.c"&gt;reg.c&lt;/h3&gt;
&lt;p&gt;实现了 &lt;code&gt;include/cpu/reg.h&lt;/code&gt; 中的 &lt;code&gt;regsl,regsw,regsb&lt;/code&gt;，同时实现寄存器实际定义：变量 &lt;code&gt;cpu&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数 &lt;code&gt;reg_test&lt;/code&gt;：测试寄存器结构定义（&lt;code&gt;CPU_state&lt;/code&gt;）是否正确。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="intr.c"&gt;intr.c&lt;/h3&gt;
&lt;p&gt;函数 &lt;code&gt;void raise_intr(uint8_t NO, vaddr_t ret_addr)&lt;/code&gt; 为 &lt;code&gt;int&lt;/code&gt; 指令（在 &lt;code&gt;system.c&lt;/code&gt; 中实现）的内部实现。
实现了触发中断或异常后的硬件处理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;依次将EFLAGS, CS(代码段寄存器), EIP寄存器（返回地址）的值压入堆栈&lt;/li&gt;
&lt;li&gt;根据中断码，从IDTR中读出IDT的首地址&lt;/li&gt;
&lt;li&gt;根据异常号在IDT中进行索引, 找到一个门描述符&lt;/li&gt;
&lt;li&gt;将门描述符中的offset域组合成目标地址&lt;/li&gt;
&lt;li&gt;跳转到目标地址&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="decode"&gt;decode/&lt;/h3&gt;
&lt;p&gt;指令译码相关。&lt;/p&gt;
&lt;h4 id="decode.c"&gt;decode.c&lt;/h4&gt;
&lt;p&gt;实现了 &lt;code&gt;include/cpu/decode.h&lt;/code&gt; 中的译码函数族，函数 &lt;code&gt;operand_write&lt;/code&gt; 以及译码信息变量 &lt;code&gt;decoding&lt;/code&gt;。
实现了 &lt;code&gt;include/cpu/rtl.h&lt;/code&gt; 中的临时寄存器 &lt;code&gt;t0,t1,t2,t3,at&lt;/code&gt; 和函数 &lt;code&gt;decoding_set_jmp&lt;/code&gt;。&lt;/p&gt;
&lt;h5 id="make_dophelper-decode_op_name"&gt;宏 make_DopHelper 与函数族 decode_op_name&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#define make_DopHelper(name) void concat(decode_op_, name) (vaddr_t *eip, Operand *op, bool load_val)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;译码函数会进一步分解成各种不同操作数的译码的组合，以实现操作数译码的解耦. 操作数译码函数统一通过宏 &lt;code&gt;make_DopHelper&lt;/code&gt; 来定义 （&lt;code&gt;decode_op_rm&lt;/code&gt; 除外）。
操作数译码函数会把操作数的信息记录在结构体 &lt;code&gt;op&lt;/code&gt; 中, 如果操作数在指令中， 就会通过 &lt;code&gt;instr_fetch()&lt;/code&gt; 将它们从 &lt;code&gt;eip&lt;/code&gt; 所指向的内存位置取出. 为了使操作数译码函数更易于复用， 函数中的 &lt;code&gt;load_val&lt;/code&gt; 参数会控制 是否需要将该操作数读出到全局译码信息 &lt;code&gt;decoding&lt;/code&gt; 供后续使用. 例如如果一个内存操作数是源操作数, 就需要将这个操作数从内存中读出来供后续执行阶段来使用； 如果它仅仅是一个目的操作数， 就不需要从内存读出它的值了，因为执行这条指令并不需要这个值， 而是将新数据写入相应的内存位置.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;decode_op_name&lt;/code&gt; 函数族命名规则可参见 &lt;code&gt;decode_name&lt;/code&gt; 函数族命名规则。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;decode_op_a&lt;/code&gt; 是一个特例，其用于将操作数标记为寄存器 &lt;code&gt;ax&lt;/code&gt; 或 &lt;code&gt;eax&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="modrm.c"&gt;modrm.c&lt;/h4&gt;
&lt;p&gt;实现了 &lt;code&gt;include/cpu/decode.h&lt;/code&gt; 中的函数 &lt;code&gt;load_addr&lt;/code&gt; 和 &lt;code&gt;read_ModR_M&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id="exec"&gt;exec/&lt;/h3&gt;
&lt;p&gt;指令执行相关。&lt;/p&gt;
&lt;h4 id="cc.c"&gt;cc.c&lt;/h4&gt;
&lt;p&gt;实现了 &lt;code&gt;include/cpu/cc.h&lt;/code&gt; 中的函数 &lt;code&gt;rtl_setcc&lt;/code&gt;。根据指定关系运算以及条件标志位设置 dest。&lt;/p&gt;
&lt;h4 id="relop.c"&gt;relop.c&lt;/h4&gt;
&lt;p&gt;实现了 &lt;code&gt;include/cpu/relop.h&lt;/code&gt; 中的函数 &lt;code&gt;interpret_relop&lt;/code&gt;，使用 C语言关系运算符实现关系运算。&lt;/p&gt;
&lt;h4 id="all-instr.h"&gt;all-instr.h&lt;/h4&gt;
&lt;p&gt;定义了已经实现的指令执行函数（在 &lt;code&gt;exec.c&lt;/code&gt; 中使用）。&lt;/p&gt;
&lt;h4 id="arith.c"&gt;arith.c&lt;/h4&gt;
&lt;p&gt;算术运算指令执行函数实现。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;add&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sub&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;inc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dec&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;neg&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;adc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sbb&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mul&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;imul1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;imul 单操作数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;imul2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;imul 双操作数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;imul3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;imul 三操作数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;div&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;idiv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="control.c"&gt;control.c&lt;/h4&gt;
&lt;p&gt;控制指令执行函数实现。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;jmp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;直接跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;jmp_rm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;间接跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;jcc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;条件跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;call&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;直接调用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;call_rm&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;间接调用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ret&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="data-mov.c"&gt;data-mov.c&lt;/h4&gt;
&lt;p&gt;数据移动指令执行函数实现。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mov&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;movsx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;movzx&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;lea&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;push&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pop&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;pusha&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;popa&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;leave&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cltd&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cwtl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="logic.c"&gt;logic.c&lt;/h4&gt;
&lt;p&gt;逻辑运算指令执行函数实现。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;test&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;and&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;xor&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;or&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;sar&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;shl&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;shr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;setcc&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;not&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;rol&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;ror&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="special.c"&gt;special.c&lt;/h4&gt;
&lt;p&gt;特殊指令执行函数实现。&lt;/p&gt;
&lt;p&gt;实现了 &lt;code&gt;include/cpu/rtl.h&lt;/code&gt; 中的函数 &lt;code&gt;interpret_rtl_exit&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;nop&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;inv&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;非法指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;nemu_trap&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;结束执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="prefix.c"&gt;prefix.c&lt;/h4&gt;
&lt;p&gt;定义了执行函数 &lt;code&gt;exec_real&lt;/code&gt;。
定义并实现了执行函数 &lt;code&gt;exec_operand_size&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exec_operand_size&lt;/code&gt; 以 16 位操作数执行指令（标记 &lt;code&gt;decoding.is_operand_size_16&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="system.c"&gt;system.c&lt;/h4&gt;
&lt;p&gt;系统相关指令实现。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;lidt&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;设置 IDTR 寄存器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mov_r2cr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;mov_cr2r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;int&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据中断码进行中断跳转&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;iret&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;从中断跳转返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;in&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;读取端口映射 I/O&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;out&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;写入端口映射 I/O&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;x86 提供了 in 和 out 指令用于访问设备，其中 in 指令用于将设备寄存器中的数据传输到 CPU 寄存器中，out 指令用于将 CPU 寄存器中的数据传送到设备寄存器中&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="exec.c"&gt;exec.c&lt;/h4&gt;
&lt;p&gt;指令执行过程核心实现。&lt;/p&gt;
&lt;h5 id="opcode_entry"&gt;结构体 opcode_entry&lt;/h5&gt;
&lt;p&gt;译码查找表中元素。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;DHelper decode&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;译码函数指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EHelper execute&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行函数指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;width&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;指令宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id="opcode_table"&gt;数组 opcode_table&lt;/h5&gt;
&lt;p&gt;译码表。按指令第一个字节索引存放。分两段：单字节指令码和双字节指令码。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;opcode_entry opcode_table [512] = {
  /* 0x00 */	EMPTY, EMPTY, EMPTY, EMPTY,
  /* 0x04 */	EMPTY, EMPTY, EMPTY, EMPTY,
  /* 0x08 */	EMPTY, EMPTY, EMPTY, EMPTY,
  ...
};
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;IDEXW(id, ex, w)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据译码函数名，执行函数名，宽度生成 &lt;code&gt;opcode_entry&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;IDEX(id, ex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据译码函数名，执行函数名，以宽度 0 生成 &lt;code&gt;opcode_entry&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EXW(ex, w)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据执行函数名，宽度，生成无译码函数的 &lt;code&gt;opcode_entry&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EX(ex)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;根据执行函数名，生成宽度为 0 且无译码函数的 &lt;code&gt;opcode_entry&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;EMPTY&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;未实现的命令，使用 &lt;code&gt;exec_inv&lt;/code&gt;（定义在 &lt;code&gt;special.c&lt;/code&gt; 中） 构造 &lt;code&gt;opcode_entry&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;make_group(name, item0, item1, item2, item3, item4, item5, item6, item7)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于实现 &lt;code&gt;sub /5&lt;/code&gt; 这种根据第二个指令码 &lt;code&gt;/5&lt;/code&gt; 区分不同指令的情况。会自动生成一个 &lt;code&gt;exec_name&lt;/code&gt; 的统一执行函数，并根据 &lt;code&gt;decoding.ext_opcode&lt;/code&gt; 分配到指定执行函数。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#define IDEXW(id, ex, w)   {concat(decode_, id), concat(exec_, ex), w}
#define IDEX(id, ex)       IDEXW(id, ex, 0)
#define EXW(ex, w)         {NULL, concat(exec_, ex), w}
#define EX(ex)             EXW(ex, 0)
#define EMPTY              EX(inv)

#define make_group(name, item0, item1, item2, item3, item4, item5, item6, item7) \
  static opcode_entry concat(opcode_table_, name) [8] = { \
    /* 0x00 */	item0, item1, item2, item3, \
    /* 0x04 */	item4, item5, item6, item7  \
  }; \
static make_EHelper(name) { \
  idex(eip, &amp;amp;concat(opcode_table_, name)[decoding.ext_opcode]); \
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;make_group&lt;/code&gt; 宏定义了一些组 &lt;code&gt;gp1&lt;/code&gt; - &lt;code&gt;gp7&lt;/code&gt;。对应于 80386 手册附录中组的划分。&lt;/p&gt;
&lt;h5 id="exec_wrapper"&gt;函数 exec_wrapper&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void exec_wrapper(bool print_flag);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;执行下一条指令。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先将当前的 &lt;code&gt;%eip&lt;/code&gt; 保存到全局译码信息 &lt;code&gt;decoding&lt;/code&gt; 的成员 &lt;code&gt;seq_eip&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;然后将其地址被作为参数送进 &lt;code&gt;exec_real()&lt;/code&gt; 函数中
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;seq&lt;/code&gt; 代表顺序的意思, 当代码从 &lt;code&gt;exec_real()&lt;/code&gt; 返回时，&lt;code&gt;decoding.seq_eip&lt;/code&gt; 将会指向下一条指令的地址.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;update_eip&lt;/code&gt; 更新 &lt;code&gt;%eip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;调试模式下
&lt;ul&gt;
&lt;li&gt;记录日志（指令内容以及相关信息）&lt;/li&gt;
&lt;li&gt;若 &lt;code&gt;print_flag&lt;/code&gt; 为真，则显示 &lt;code&gt;decoding.asm_buf&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="exec_real"&gt;函数 exec_real&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;首先通过 &lt;code&gt;instr_fetch()&lt;/code&gt; 函数(在 &lt;code&gt;include/cpu/exec.h&lt;/code&gt; 中定义)进行取指， 得到指令的第一个字节, 将其解释成 &lt;code&gt;opcode&lt;/code&gt; 并记录在全局译码信息 &lt;code&gt;decoding&lt;/code&gt; 中.&lt;/li&gt;
&lt;li&gt;根据 &lt;code&gt;opcode&lt;/code&gt; 查阅译码查找表，得到操作数的宽度信息，并通过调用 &lt;code&gt;set_width()&lt;/code&gt; 函数将其记录在全局译码信息 &lt;code&gt;decoding&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;idex()&lt;/code&gt; 对指令进行进一步的译码和执行&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="set_width"&gt;函数 set_width&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;static inline void set_width(int width);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据指令定义宽度（&lt;code&gt;opcode_entry.width&lt;/code&gt;）指定所有操作数宽度（&lt;code&gt;decoding.src.width&lt;/code&gt;）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果定义宽度为 0，则采用译码结果（&lt;code&gt;decoding.is_operand_size_16&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="idex"&gt;函数 idex&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;/* Instruction Decode and EXecute */
static inline void idex(vaddr_t *eip, opcode_entry *e);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用译码查找表中的相应的译码函数（若存在）进行操作数的译码，译码过程结束之后, 会调用译码查找表中的相应的执行函数来进行真正的执行操作。&lt;/p&gt;
&lt;h5 id="update_eip"&gt;函数 update_eip&lt;/h5&gt;
&lt;p&gt;根据当前指令是否为跳转指令，更新 &lt;code&gt;%eip&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;static inline void update_eip(void) {
    if (decoding.is_jmp) { decoding.is_jmp = 0; }
    else { cpu.eip = decoding.seq_eip; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="memory-1"&gt;memory/&lt;/h2&gt;
&lt;h3 id="memory.c"&gt;memory.c&lt;/h3&gt;
&lt;p&gt;定义了宏 &lt;code&gt;PMEM_SIZE&lt;/code&gt; 指定物理内存大小。
实现了 &lt;code&gt;include/memory/memory.h&lt;/code&gt; 中的函数 &lt;code&gt;paddr_read&lt;/code&gt;，&lt;code&gt;paddr_write&lt;/code&gt;，&lt;code&gt;vaddr_read&lt;/code&gt;，&lt;code&gt;vaddr_write&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vaddr_read, vaddr_write&lt;/code&gt; 的实现调用了 &lt;code&gt;paddr_read&lt;/code&gt; 和 &lt;code&gt;paddr_write&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;为支持内存映射 I/O，&lt;code&gt;paddr_read, paddr_write&lt;/code&gt; 的实现加入了对内存映射 I/O 的判断。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="device-1"&gt;device/&lt;/h2&gt;
&lt;h3 id="io"&gt;io/&lt;/h3&gt;
&lt;h4 id="mmio.c"&gt;mmio.c&lt;/h4&gt;
&lt;p&gt;定义了宏 &lt;code&gt;MMIO_SPACE_MAX&lt;/code&gt; 指定内存映射空间大小。
定义了结构体 &lt;code&gt;MMIO_t&lt;/code&gt; 保存 MMIO 信息。&lt;/p&gt;
&lt;p&gt;实现了 &lt;code&gt;include/device/mmio.h&lt;/code&gt; 中的函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;mmio_read&lt;/code&gt; 和 &lt;code&gt;mmio_write&lt;/code&gt; 中，调用了回调函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="port-io.c"&gt;port-io.c&lt;/h4&gt;
&lt;p&gt;定义了宏 &lt;code&gt;PORT_IO_SPACE_MAX&lt;/code&gt; 指定内存映射空间大小。
定义了结构体 &lt;code&gt;PIO_t&lt;/code&gt; 保存 MMIO 信息。&lt;/p&gt;
&lt;p&gt;实现了 &lt;code&gt;include/device/port-io.h&lt;/code&gt; 中的函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;code&gt;pio_read_common&lt;/code&gt; 和 &lt;code&gt;pio_write_common&lt;/code&gt; 中，调用了回调函数。&lt;/li&gt;
&lt;li&gt;基于 &lt;code&gt;pio_read_common&lt;/code&gt; 和 &lt;code&gt;pio_write_common&lt;/code&gt; 实现了不同的端口读写函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="device.c"&gt;device.c&lt;/h3&gt;
&lt;p&gt;提供初始化和控制设备的一些函数。含有和SDL库相关的代码，NEMU使用SDL库来实现设备的模拟。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;TIMER_HZ&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;时钟频率&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VGA_HZ&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;VGA 刷新频率&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="init_device"&gt;函数 init_device&lt;/h4&gt;
&lt;p&gt;用于初始化设备：串口， 时钟， 键盘， VGA四种设备。
其中在初始化 VGA 时还会进行一些和SDL相关的初始化工作， 包括创建窗口， 设置显示模式等. 最后还会注册一个100Hz的定时器， 每隔0.01秒就会调用一次 &lt;code&gt;device_update()&lt;/code&gt; 函数。&lt;/p&gt;
&lt;h4 id="device_update"&gt;函数 device_update&lt;/h4&gt;
&lt;p&gt;主要进行一些设备的模拟操作, 包括以50Hz的频率刷新屏幕, 以及检测是否有按键按下/释放.&lt;/p&gt;
&lt;p&gt;{% note warning %}
需要说明的是， 代码中注册的定时器是虚拟定时器， 它只会在 NEMU 处于用户态的时候进行计时： 如果 NEMU 在 &lt;code&gt;ui_mainloop()&lt;/code&gt; 中等待用户输入， 定时器将不会计时; 如果 NEMU 进行大量的输出， 定时器的计时将会变得缓慢. 因此除非你在进行调试， 否则尽量避免大量输出的情况， 从而影响定时器的工作。
{% endnote %}&lt;/p&gt;
&lt;h3 id="serial.c"&gt;serial.c&lt;/h3&gt;
&lt;p&gt;串口设备。
模拟了串口的功能。 其大部分功能也被简化，只保留了数据寄存器和状态寄存器。串口初始化时会分别注册 &lt;code&gt;0x3F8&lt;/code&gt; 和 &lt;code&gt;0x3FC&lt;/code&gt; 处长度为1个字节的端口，分别作为数据寄存器和状态寄存器。由于NEMU串行模拟计算机系统的工作，串口的状态寄存器可以一直处于空闲状态; 每当CPU往数据寄存器中写入数据时，串口会将数据传送到主机的标准输出。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数/宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;init_serial()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;初始化设备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SERIAL_PORT=0x3F8&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;端口 I/O 地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="timer.c"&gt;timer.c&lt;/h3&gt;
&lt;p&gt;时钟设备。
模拟了i8253计时器的功能. 计时器的大部分功能都被简化, 只保留了&amp;quot;发起时钟中断&amp;quot;的功能. 同时添加了一个自定义的RTC(Real Time Clock), 初始化时将会注册0x48处的端口作为RTC寄存器, CPU可以通过I/O指令访问这一寄存器, 获得当前时间(单位是ms).&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数/宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;init_timer()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;初始化设备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;RTC_PORT=0x48&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;端口 I/O 地址&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="keyboard.c"&gt;keyboard.c&lt;/h3&gt;
&lt;p&gt;键盘设备。
模拟了i8042通用设备接口芯片的功能. 其大部分功能也被简化, 只保留了键盘接口. i8042初始化时会注册 &lt;code&gt;0x60&lt;/code&gt; 处的端口（长度为 4）作为数据寄存器. 每当用户敲下/释放按键时, 将会把相应的键盘码放入数据寄存器, CPU可以通过端口I/O访问数据寄存器, 获得键盘码; 当无按键可获取时, 将会返回 &lt;code&gt;_KEY_NONE&lt;/code&gt; . 在AM中, 我们约定通码的值为 &lt;code&gt;断码 | KEYDOWN_MASK&lt;/code&gt;.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数/宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;init_i8042()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;初始化设备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;I8042_DATA_PORT=0x60&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;端口 I/O 地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;KEYDOWN_MASK=0x8000&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;通码 MASK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;KEY_QUEUE_LEN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;键队列长度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="vga.c"&gt;vga.c&lt;/h3&gt;
&lt;p&gt;VGA 设备。
模拟了VGA的功能. VGA初始化时注册了从 &lt;code&gt;0x40000&lt;/code&gt; 开始的一段用于映射到video memory的物理内存. 在NEMU中, video memory是唯一使用内存映射I/O方式访问的I/O空间. 代码只模拟了400x300x32的图形模式, 一个像素占32个bit的存储空间, R(red), G(green), B(blue), A(alpha)各占8 bit, 其中VGA不使用alpha的信息。VGA 设备同时注册了位于 &lt;code&gt;0x100&lt;/code&gt; 的长度为 4 的端口存储屏幕大小信息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数/宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;init_vga()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;初始化设备&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SCREEN_PORT=0x100&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;端口 I/O 地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;VMEM=0x40000&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;内存映射 I/O 地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SCREEN_H&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;屏幕高度&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SCREEN_W&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;屏幕宽度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="monitor-1"&gt;monitor/&lt;/h2&gt;
&lt;p&gt;监视器部分实现（也包含 NEMU 执行主循环）。&lt;/p&gt;
&lt;h3 id="monitor.c"&gt;monitor.c&lt;/h3&gt;
&lt;h4 id="init_monitor"&gt;函数 init_monitor&lt;/h4&gt;
&lt;p&gt;初始化监视器并启动（用于 &lt;code&gt;main.c/main&lt;/code&gt; 中）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解析并处理命令行参数&lt;/li&gt;
&lt;li&gt;初始化日志文件&lt;/li&gt;
&lt;li&gt;寄存器测试（调用 &lt;code&gt;reg_test()&lt;/code&gt;，实现在 &lt;code&gt;src/cpu/reg.c&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;加载程序镜像（根据命令行参数，如果为空，则调用 &lt;code&gt;load_default_img()&lt;/code&gt; 加载默认镜像）&lt;/li&gt;
&lt;li&gt;启动环境（调用 &lt;code&gt;restart()&lt;/code&gt;，初始化应用程序入口点，寄存器值）&lt;/li&gt;
&lt;li&gt;编译正则表达式（调用 &lt;code&gt;init_regex()&lt;/code&gt;，实现在 &lt;code&gt;src/monitor/debug/expr.c&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;初始化监视点池（调用 &lt;code&gt;init_wp_pool()&lt;/code&gt;，实现在 &lt;code&gt;src/monitor/debug/watchpoint.c&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;初始化设备（调用 &lt;code&gt;init_device()&lt;/code&gt;，实现在 &lt;code&gt;src/device/device.c&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;初始化差异测试（调用 &lt;code&gt;init_difftest()&lt;/code&gt;，实现在 &lt;code&gt;src/monitor/diff-test.c&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;显示欢迎界面&lt;/li&gt;
&lt;li&gt;返回是否为批处理模式（根据命令行参数）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令行参数
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;[img_file]&lt;/code&gt; 指定应用程序镜像文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-b&lt;/code&gt; 批处理模式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-l log_file&lt;/code&gt; 指定日志文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-d&lt;/code&gt; 指定 Diff-Test 镜像文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="cpu-exec.c"&gt;cpu-exec.c&lt;/h3&gt;
&lt;h4 id="cpu_exec"&gt;函数 cpu_exec&lt;/h4&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void cpu_exec(uint64_t n);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模拟 CPU 工作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断 NEMU 状态（查看 &lt;code&gt;nemu_state&lt;/code&gt;，定义在 &lt;code&gt;include/monitor/monitor.h&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;若指令数 &lt;code&gt;n&lt;/code&gt; 小于 &lt;code&gt;MAX_INSTR_TO_PRINT&lt;/code&gt; （默认为 10），则打印每条指令。&lt;/li&gt;
&lt;li&gt;开始执行指令
&lt;ul&gt;
&lt;li&gt;调用 &lt;code&gt;exec_wrapper&lt;/code&gt; 执行下一条指令（传入是否打印指令标记）&lt;/li&gt;
&lt;li&gt;检查监视点状态是否有更新&lt;/li&gt;
&lt;li&gt;更新设备信息&lt;/li&gt;
&lt;li&gt;判断 NEMU 状态（查看 &lt;code&gt;nemu_state&lt;/code&gt;），决定是否退出&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;执行完 &lt;code&gt;n&lt;/code&gt; 条指令后，将 NEMU 状态置为结束（&lt;code&gt;NEMU_END&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行某条命令后
&lt;ul&gt;
&lt;li&gt;若 NEMU 状态为结束（&lt;code&gt;NEMU_END&lt;/code&gt;），则检查程序返回值（&lt;code&gt;cpu.eax&lt;/code&gt;）是否为 0（是否正常退出）。并输出 &lt;code&gt;HIT GOOD TRAP&lt;/code&gt;（正常退出） 或 &lt;code&gt;HIT BAD TRAP&lt;/code&gt;（非正常退出）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="debug"&gt;debug/&lt;/h3&gt;
&lt;h4 id="watchpoint.c"&gt;watchpoint.c&lt;/h4&gt;
&lt;p&gt;定义了监视点内存池及其相关的函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;wp_pool&lt;/code&gt; 监视点池&lt;/li&gt;
&lt;li&gt;&lt;code&gt;head&lt;/code&gt; 使用中的监视点链表头指针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;free_&lt;/code&gt; 监视点池中未使用的监视点链表头指针&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;init_wp_pool()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;初始化监视点内存池&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;clearWP(wp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;清空某监视点的下一项指针&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WP *getHeadWP()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取 &lt;code&gt;head&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WP *createWP()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;申请使用一个新监视点（内部调用 &lt;code&gt;new_wp()&lt;/code&gt; 并更新链表信息）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;removeWP(no)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除指定编号的监视点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;WP *new_wp()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;（私有）从内存池中获取下一个能使用的监视点，并作一定预处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;free_wp(wp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;（私有）释放一个监视点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id="expr.c"&gt;expr.c&lt;/h4&gt;
&lt;p&gt;实现了 &lt;code&gt;expr.h/expr&lt;/code&gt; 函数，实现表达式解析和求值。&lt;/p&gt;
&lt;h5 id="section-4"&gt;常量&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;PRI_NEG&lt;/code&gt; 取负运算优先级&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PRI_POINT&lt;/code&gt; 解引用运算优先级&lt;/li&gt;
&lt;li&gt;形如 &lt;code&gt;TK_TYPE&lt;/code&gt; 的 Token 类型枚举&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="rules"&gt;数组 rules&lt;/h5&gt;
&lt;p&gt;规定了使用正则表达式解析 Token 的规则。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;regex&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;正则表达式字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;token_type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对应 Token 类型，可用 &lt;code&gt;TK_TYPE&lt;/code&gt; 枚举或字符（如 &lt;code&gt;+&lt;/code&gt;）表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;opPri&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;运算符 Token 的优先级&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id="re"&gt;数组 re&lt;/h5&gt;
&lt;p&gt;根据 &lt;code&gt;rules&lt;/code&gt; 编译后的正则表达式。&lt;/p&gt;
&lt;h5 id="init_regex"&gt;函数 &lt;code&gt;init_regex&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;根据 &lt;code&gt;rules&lt;/code&gt; 编译到 &lt;code&gt;re&lt;/code&gt;&lt;/p&gt;
&lt;h5 id="token"&gt;结构体 Token&lt;/h5&gt;
&lt;p&gt;识别后的 Token.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;type&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Token 类型，可用 &lt;code&gt;TK_TYPE&lt;/code&gt; 枚举或字符（如 &lt;code&gt;+&lt;/code&gt;）表示&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;isOp&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标记此 Token 是否是运算符&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;isValue&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标记此 Token 是否是值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;str&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Token 的原始字符串&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;data&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;值类型的实际数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;priority&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;运算符的优先级&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;isOp&lt;/code&gt; 和 &lt;code&gt;isValue&lt;/code&gt; 多用于区分特殊单目运算符，如解引用和取负&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data&lt;/code&gt; 多存储经过预处理的数据，如转换后的整数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% note info %}
解析后的 Token 列表存储在数组 &lt;code&gt;tokens&lt;/code&gt; 中。
&lt;code&gt;nr_token&lt;/code&gt; 指示 &lt;code&gt;token&lt;/code&gt; 有效长度。
{% endnote %}&lt;/p&gt;
&lt;h5 id="make_token"&gt;函数 make_token&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;static bool make_token(char *e)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据字符串解析 Token 列表，返回是否解析成功。&lt;/p&gt;
&lt;p&gt;实现思路：使用 &lt;code&gt;re&lt;/code&gt; 依次尝试每一种匹配，直到遇到第一个成功匹配，根据其规则的 &lt;code&gt;token_type&lt;/code&gt; 生成 Token，存入 &lt;code&gt;token&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数 &lt;code&gt;toInteger&lt;/code&gt; ：以指定进制完成字符串到数的转换，用于 十进制，二进制，八进制，十六进制 数的解析。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;static uint32_t toInteger(char *s, uint32_t base)
&lt;/code&gt;&lt;/pre&gt;
&lt;h5 id="evalwithtoken"&gt;函数 evalWithToken&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;uint32_t evalWithToken(int l, int r, bool * success)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;求解 &lt;code&gt;tokens[l..r]&lt;/code&gt; 中的表达式的值。&lt;/p&gt;
&lt;p&gt;实现思路：单 Token 特殊处理，然后处理外围括号情况，然后确定最后计算的运算符，分割成 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 两部分，然后递归解决，最后合并，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数 &lt;code&gt;checkExtraP&lt;/code&gt; 判断 &lt;code&gt;tokens[l..r]&lt;/code&gt; 是否外围为括号且括号匹配正常。&lt;/li&gt;
&lt;li&gt;函数 &lt;code&gt;getReg&lt;/code&gt; 根据寄存器名获取寄存器值，使用了 &lt;code&gt;regMap&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数组 &lt;code&gt;regMap&lt;/code&gt; 标识寄存器名与对应的偏移量（&lt;code&gt;cpu.gpr&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="expr"&gt;函数 expr&lt;/h5&gt;
&lt;p&gt;对 &lt;code&gt;expr.h/expr&lt;/code&gt; 的实现，调用了 &lt;code&gt;make_token&lt;/code&gt; 和 &lt;code&gt;evalWithToken&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;{% note warning %}
待更新
{% endnote %}&lt;/p&gt;
&lt;h4 id="ui.c"&gt;ui.c&lt;/h4&gt;
&lt;p&gt;监视器 CUI 部分。&lt;/p&gt;
&lt;h5 id="fc2color"&gt;函数族 fc2color&lt;/h5&gt;
&lt;p&gt;控制台字体颜色控制。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fc2red&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前景色设为红色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fc2green&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前景色设为绿色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fc2yellow&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前景色设为黄色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fc2blue&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前景色设为蓝色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fc2purple&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;前景色设为紫色&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;csClear&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;清除所有控制台设置&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id="cmd_item"&gt;函数族 cmd_item&lt;/h5&gt;
&lt;p&gt;不同命令的实现。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd_help&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取帮助&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd_q&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;退出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd_c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;继续执行（调用 &lt;code&gt;cpu_exec(-1)&lt;/code&gt;，实现在 &lt;code&gt;src/monitor/cpu-exec.c&lt;/code&gt;）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd_si&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;执行单步指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd_info name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查看信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd_x N expr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示地址从 &lt;code&gt;expr&lt;/code&gt; 的值开始的 &lt;code&gt;N&lt;/code&gt; 个字节值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd_p expr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;计算表达式的值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd_w expr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;新建监视点，监视表达式为 &lt;code&gt;expr&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;cmd_d no&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;删除指定编号的监视点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cmd_info&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;r&lt;/code&gt; 打印所有寄存器信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;w&lt;/code&gt; 打印所有监视点信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="cmd_table"&gt;数组 cmd_table&lt;/h5&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;命令名（用于识别命令）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;description&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;命令描述（用于帮助列表）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;handler&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;命令实现函数指针&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5 id="ui_mainloop"&gt;函数 ui_mainloop&lt;/h5&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void ui_mainloop(int is_batch_mode);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;NEMU 以及其 CUI 主循环，不断读取命令，并执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是批处理模式（&lt;code&gt;is_batch_mode&lt;/code&gt; 为真），则直接执行应用程序，不监听用户命令。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="diff-test"&gt;diff-test/&lt;/h3&gt;
&lt;p&gt;差异测试实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果有一种方法能够表达指令的正确行为, 我们就可以基于这种方法来进行类似assert()的检查了。那么, 究竟什么地方表达了指令的正确行为呢? 最直接的, 当然就是i386手册了, 但是我们恰恰就是根据i386手册中的指令行为来在NEMU中实现指令的, 同一套方法不能既用于实现也用于检查. 如果有一个i386手册的参考实现就好了. 嘿! 我们用的真机不就是根据i386手册实现出来的吗? 我们让在NEMU中执行的每条指令也在真机中执行一次, 然后对比NEMU和真机的状态, 如果NEMU和真机的状态不一致, 我们就捕捉到error了!
这实际上是一种非常奏效的测试方法, 在软件测试领域称为differential testing(后续简称DiffTest). 我们刚才提到了&amp;quot;状态&amp;quot;, 那&amp;quot;状态&amp;quot;具体指的是什么呢? 我们在PA1中已经认识到, 计算机就是一个数字电路. 那么, &amp;quot;计算机的状态&amp;quot;就恰恰是那些时序逻辑部件的状态, 也就是寄存器和内存的值. 其实仔细思考一下, 计算机执行指令, 就是修改这些时序逻辑部件的状态的过程. 要检查指令的实现是否正确, 只要检查这些时序逻辑部件中的值是否一致就可以了! DiffTest可以非常及时地捕捉到error, 第一次发现NEMU的寄存器或内存的值与真机不一样的时候, 就是因为当时执行的指令实现有误导致的. 这时候其实离error非常接近, 防止了error进一步传播的同时, 要回溯找到fault也容易得多.
多么美妙的功能啊! 背后还蕴含着计算机本质的深刻原理! 但很遗憾, 不要忘记了, 真机上是运行了操作系统GNU/Linux的, 而NEMU中的测试程序是运行在x86-nemu上的, 我们无法在native中运行编译到x86-nemu的AM程序. 所以, 我们需要的不仅是一个i386手册的正确实现, 而且需要在上面能正确运行x86-nemu的AM程序.
事实上, QEMU就是一个不错的参考实现. 它是一个虚拟出来的完整的x86计算机系统, 而NEMU的目标只是虚拟出x86的一个子集, 能在NEMU上运行的程序, 自然也能在QEMU上运行. 因此, 为了通过DiffTest的方法测试NEMU实现的正确性, 我们让NEMU和QEMU逐条指令地执行同一个客户程序. 双方每执行完一条指令, 就检查各自的寄存器和内存的状态, 如果发现状态不一致, 就马上报告错误, 停止客户程序的执行.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="diff-test.h"&gt;diff-test.h&lt;/h4&gt;
&lt;p&gt;定义了宏 &lt;code&gt;DIFFTEST_REG_SIZE&lt;/code&gt; 规定访问的寄存器大小。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#define DIFFTEST_REG_SIZE (sizeof(uint32_t) * 9) // GRPs + EIP
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id="ref.c"&gt;ref.c&lt;/h4&gt;
&lt;p&gt;在 DUT(Design Under Test, 测试对象)和 REF(Reference, 参考实现) 之间定义了一组 API。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;// 从DUT host memory的 src 处拷贝 n 字节到REF guest memory的 dest 处
void difftest_memcpy_from_dut(paddr_t dest, void *src, size_t n);
// 获取REF的寄存器状态到 r 
void difftest_getregs(void *r);
// 设置REF的寄存器状态为 r 
void difftest_setregs(const void *r);
// 让REF执行 n 条指令
void difftest_exec(uint64_t n);
// 初始化REF的DiffTest功能
void difftest_init();
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;其中寄存器状态 &lt;code&gt;r&lt;/code&gt; 要求寄存器的值按照某种顺序排列，若未按要求顺序排列， &lt;code&gt;difftest_getregs()&lt;/code&gt; 和 &lt;code&gt;difftest_setregs()&lt;/code&gt; 的行为是未定义的. REF 需要实现这些 API，DUT会使用这些 API 来进行 DiffTest 。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="diff-test.c"&gt;diff-test.c&lt;/h4&gt;
&lt;p&gt;定义了变量 &lt;code&gt;is_skip_ref&lt;/code&gt;，&lt;code&gt;is_skip_dut&lt;/code&gt; 用于标记忽视一些指令处的比对。（可结合 &lt;code&gt;difftest_step&lt;/code&gt; 实现）
定义了函数 &lt;code&gt;difftest_skip_ref&lt;/code&gt;，&lt;code&gt;difftest_skip_dut&lt;/code&gt; 标记上述变量。&lt;/p&gt;
&lt;h5 id="init_difftest"&gt;函数 init_difftest&lt;/h5&gt;
&lt;p&gt;初始化 Diff-Test。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开动态库文件 &lt;code&gt;ref_so_file&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;从动态库中分别读取上述 API 的符号&lt;/li&gt;
&lt;li&gt;对 REF 的 DIffTest功能进行初始化，此时会启动 REF，代码还会对 REF 的状态进行一些初始化工作，REF 运行在后台，因此将看不到 REF 的任何输出&lt;/li&gt;
&lt;li&gt;将 DUT 的 guest memory 拷贝到 REF 中&lt;/li&gt;
&lt;li&gt;将 DUT 的寄存器状态拷贝到 REF 中&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id="difftest_step"&gt;函数 difftest_step&lt;/h5&gt;
&lt;p&gt;用于逐条指令执行后的状态对比。它会在 &lt;code&gt;exec_wrapper()&lt;/code&gt; 的最后被调用。在这里读取 REF 的寄存器并与 NEMU 寄存器状态比对。&lt;/p&gt;
&lt;h2 id="misc"&gt;misc/&lt;/h2&gt;
&lt;h3 id="logo.c"&gt;logo.c&lt;/h3&gt;
&lt;p&gt;定义了字符数组 &lt;code&gt;logo&lt;/code&gt; 存储 i386 Manual Logo。用于 &lt;code&gt;inv&lt;/code&gt; 指令（位于 &lt;code&gt;special.c&lt;/code&gt; 中）。&lt;/p&gt;
&lt;h1 id="tools"&gt;tools/&lt;/h1&gt;
&lt;h2 id="gen-expr.c"&gt;gen-expr.c&lt;/h2&gt;
&lt;p&gt;生成 C 表达式，用于测试表达式求值功能。&lt;/p&gt;
&lt;h2 id="qemu-diff"&gt;qemu-diff&lt;/h2&gt;
&lt;p&gt;QEMU 实现，用于 Diff-Test。编译成动态库 &lt;code&gt;qemu-so&lt;/code&gt;，传入 nemu 的 &lt;code&gt;-d&lt;/code&gt; 参数中。&lt;/p&gt;
&lt;h1 id="section-5"&gt;引用资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://legacy.gitbook.com/book/nju-ics/ics2018-programming-assignment/details"&gt;ICS2018 PA 讲义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Learning/nju-icspa-analytics-nanos-lite</id><title type="text">NJU ICS Programming Assignment 代码分析 - NANOS-LITE</title><summary type="text">概述
框架代码库
CPU 架构：x64
操作系统: GNU/Linux
编译器: GCC
编程语言：C 语言
Nanos-lite是南京大学操作系统Nanos的裁剪版。可运行在 x86-nemu 的 </summary><published>2018-11-05T17:30:22+08:00</published><updated>2018-11-05T17:30:22+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Learning%2Fnju-icspa-analytics-nanos-lite" /><category term="Learning" /><content type="html">&lt;h1 id="section"&gt;概述&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/NJU-ProjectN/nanos-lite"&gt;框架代码库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CPU 架构：x64&lt;/li&gt;
&lt;li&gt;操作系统: GNU/Linux&lt;/li&gt;
&lt;li&gt;编译器: GCC&lt;/li&gt;
&lt;li&gt;编程语言：C 语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Nanos-lite是南京大学操作系统Nanos的裁剪版。可运行在 x86-nemu 的 AM 上。&lt;/p&gt;
&lt;h2 id="section-1"&gt;框架代码结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;nanos-lite/                 # NANOS-LITE 项目
    include/                # 头文件
    src/                    # 源文件
        device.c            # 设备抽象
        fs.c                # 文件系统
        files.h             # ramdisk 中的文件描述
        initrd.S            # ramdisk设备
        irq.c               # 中断异常处理
        loader.c            # 加载器
        main.c              # 主程序
        mm.c                # 存储管理
        proc.c              # 进程调度
        ramdisk.c           # ramdisk驱动程序
        syscall.c           # 系统调用处理
        syscall.h           # 系统调用相关宏
    Makefile
navy-apps/
nemu/
nexus-am/
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="include"&gt;include/&lt;/h1&gt;
&lt;h2 id="common.h"&gt;common.h&lt;/h2&gt;
&lt;p&gt;引用 AM 中的 &lt;code&gt;am.h klib.h&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="debug.h"&gt;debug.h&lt;/h2&gt;
&lt;p&gt;简化调试输出的宏，可类比 &lt;code&gt;nemu/debug.h&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="fs.h"&gt;fs.h&lt;/h2&gt;
&lt;p&gt;文件系统的相关内容。&lt;/p&gt;
&lt;p&gt;LSEEK 类型枚举：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;枚举&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SEEK_SET&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将文件流位置设置为指定值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SEEK_CUR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将文件流位置设置为当前位置向后偏移指定值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SEEK_END&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;将文件流位置设置文件末尾&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;文件系统操作函数：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fs_open&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打开文件，返回 ID&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fs_read&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;读取文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fs_write&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;写入文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fs_lseek&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;改变文件流位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fs_close&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;关闭文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fs_filesz&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;获取文件大小&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id="src"&gt;src/&lt;/h1&gt;
&lt;h2 id="main.c"&gt;main.c&lt;/h2&gt;
&lt;p&gt;NANOS-LITE 主程序。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化存储 （&lt;code&gt;init_mm&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;初始化镜像文件 （&lt;code&gt;init_ramdisk&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;初始化设备 （&lt;code&gt;init_device&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;初始化中断处理 （&lt;code&gt;init_irq&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;初始化文件系统 （&lt;code&gt;init_fs&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;初始化进程 （&lt;code&gt;init_proc&lt;/code&gt;）
&lt;ul&gt;
&lt;li&gt;从 &lt;code&gt;ramdist&lt;/code&gt; 中加载程序镜像到指定位置&lt;/li&gt;
&lt;li&gt;启动进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;测试自陷事件（&lt;code&gt;_yield&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="ramdisk.c"&gt;ramdisk.c&lt;/h2&gt;
&lt;p&gt;变量 &lt;code&gt;ramdisk_start,ramdisk_end&lt;/code&gt; 指示 ramdisk 所在的内存区间。
宏 &lt;code&gt;RAMDISK_SIZE&lt;/code&gt; 指示 ramdisk 对应内存大小。&lt;/p&gt;
&lt;p&gt;ramdisk 相关操作函数。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;// 初始化 ramdisk
void init_ramdisk();

// 从ramdisk中 offset 偏移处的 len 字节读入到 buf 中
size_t ramdisk_read(void *buf, size_t offset, size_t len);

// 把 buf 中的 len 字节写入到ramdisk中 offset 偏移处
size_t ramdisk_write(const void *buf, size_t offset, size_t len);

// 返回ramdisk的大小, 单位为字节
size_t get_ramdisk_size();
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="fs.c"&gt;fs.c&lt;/h2&gt;
&lt;p&gt;文件系统相关。实现了 &lt;code&gt;fs.h&lt;/code&gt; 中定义的函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;init_fs&lt;/code&gt; 初始化文件系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化 &lt;code&gt;FD_FB&lt;/code&gt; 文件的大小（根据 VGA 屏幕大小）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;ReadFn&lt;/code&gt; 类型：VFS 通用文件读取函数类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;WriteFn&lt;/code&gt; 类型：VFS 通用文件写入函数类型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;typedef size_t (*ReadFn) (void *buf, size_t offset, size_t len);
typedef size_t (*WriteFn) (const void *buf, size_t offset, size_t len);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用于禁用文件读写的函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;invalid_read&lt;/code&gt; 非法读取&lt;/li&gt;
&lt;li&gt;&lt;code&gt;invalid_write&lt;/code&gt; 非法写入&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="section-2"&gt;枚举&lt;/h3&gt;
&lt;p&gt;特殊文件类型枚举。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;枚举&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FD_STDIN&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标准输入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FD_STDOUT&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标准输出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FD_STDERR&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标准错误输出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;FD_FB&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显存&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="finfo"&gt;结构体 Finfo&lt;/h3&gt;
&lt;p&gt;文件描述信息。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;name&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文件名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;size&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文件大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dist_offset&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;在 ramdisk 中的地址偏移&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;open_offset&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;文件流位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;read&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;读取函数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;write&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;写入函数&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;file_table&lt;/code&gt; 保存了所有文件信息
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;files.h&lt;/code&gt; 定义了在 ramdisk 中的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NR_FILES&lt;/code&gt; 文件总数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;特殊文件：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;文件名&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;stdin&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标准输入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;stdout&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标准输出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;stderr&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;标准错误输出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/dev/fb&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显存&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/proc/dispinfo&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;显示器信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;/dev/events&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;事件，包含时钟和键盘信号&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="device.c"&gt;device.c&lt;/h2&gt;
&lt;p&gt;将设备抽象成文件的实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;init_device&lt;/code&gt; 初始化设备
&lt;ul&gt;
&lt;li&gt;调用 &lt;code&gt;_ioe_init()&lt;/code&gt; 初始化硬件&lt;/li&gt;
&lt;li&gt;获取屏幕大小，写入到 &lt;code&gt;dispinfo&lt;/code&gt; 缓冲区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;serial_write&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;串口写入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;events_read&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;读取事件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;dispinfo_read&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;读取屏幕信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;fb_write&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;写入显存&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="loader.c"&gt;loader.c&lt;/h2&gt;
&lt;p&gt;加载器。&lt;/p&gt;
&lt;p&gt;宏 &lt;code&gt;DEFAULT_ENTRY&lt;/code&gt; 用户程序默认入口点。&lt;/p&gt;
&lt;h3 id="loader"&gt;函数 loader&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;static uintptr_t loader(PCB *pcb, const char *filename);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;把指定名称的用户程序加载到正确的内存位置。
使用了 &lt;code&gt;fs_read&lt;/code&gt; 操作函数（定义在 &lt;code&gt;fs.h&lt;/code&gt; 中）&lt;/p&gt;
&lt;h3 id="naive_uload"&gt;函数 naive_uload&lt;/h3&gt;
&lt;p&gt;调用 &lt;code&gt;loader&lt;/code&gt; 加载程序，并执行（在 &lt;code&gt;proc.c/init_proc()&lt;/code&gt; 中使用）。&lt;/p&gt;
&lt;h2 id="proc.c"&gt;proc.c&lt;/h2&gt;
&lt;p&gt;进程相关。&lt;/p&gt;
&lt;h3 id="init_proc"&gt;函数 init_proc&lt;/h3&gt;
&lt;p&gt;初始化进程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用 &lt;code&gt;naive_uload()&lt;/code&gt; （在 &lt;code&gt;loader.c&lt;/code&gt; 中定义），加载并执行指定程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="irq.c"&gt;irq.c&lt;/h2&gt;
&lt;p&gt;定义了中断处理相关函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;do_event()&lt;/code&gt; 根据上下文和事件进行处理
&lt;ul&gt;
&lt;li&gt;将系统调用事件分发给 &lt;code&gt;syscall.c&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;init_irq()&lt;/code&gt; 初始化中断处理
&lt;ul&gt;
&lt;li&gt;调用 &lt;code&gt;_cte_init()&lt;/code&gt; 注册 &lt;code&gt;do_event&lt;/code&gt; 作为处理函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="syscall.h"&gt;syscall.h&lt;/h2&gt;
&lt;p&gt;定义了各种系统调用类型的编号。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;enum {
  SYS_exit,     // 以指定结束码退出
  SYS_yield,    // 自陷
  SYS_open,     // 打开文件
  SYS_read,     // 读取文件
  SYS_write,    // 写入文件
  SYS_kill,
  SYS_getpid,
  SYS_close,    // 关闭文件
  SYS_lseek,    // 改变文件流位置
  SYS_brk,      // 设置 program break，用于堆内存管理
  SYS_fstat,
  SYS_time,
  SYS_signal,
  SYS_execve,
  SYS_fork,
  SYS_link,
  SYS_unlink,
  SYS_wait,
  SYS_times,
  SYS_gettimeofday
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="syscall.c"&gt;syscall.c&lt;/h2&gt;
&lt;h3 id="do_syscall"&gt;函数 do_syscall&lt;/h3&gt;
&lt;p&gt;根据上下文（在栈中保存），执行系统调用。
使用 &lt;code&gt;nexus-am/am.h&lt;/code&gt; 中的 GRP? 宏访问系统调用参数。根据调用类型执行对应函数并处理返回值。&lt;/p&gt;
&lt;h1 id="section-3"&gt;引用资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://legacy.gitbook.com/book/nju-ics/ics2018-programming-assignment/details"&gt;ICS2018 PA 讲义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Learning/nju-icspa-analytics-navy-apps</id><title type="text">NJU ICS Programming Assignment 代码分析 - NAVY-APPS</title><summary type="text">概述
框架代码库
CPU 架构：x64
操作系统: GNU/Linux
编译器: GCC
编程语言：C 语言
Navy-Apps 提供一系列运行在 Nanos-lite 上的用户程序，也包含了 New</summary><published>2018-11-05T17:30:22+08:00</published><updated>2018-11-05T17:30:22+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Learning%2Fnju-icspa-analytics-navy-apps" /><category term="Learning" /><content type="html">&lt;h1 id="section"&gt;概述&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/NJU-ProjectN/navy-apps"&gt;框架代码库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;CPU 架构：x64&lt;/li&gt;
&lt;li&gt;操作系统: GNU/Linux&lt;/li&gt;
&lt;li&gt;编译器: GCC&lt;/li&gt;
&lt;li&gt;编程语言：C 语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Navy-Apps 提供一系列运行在 Nanos-lite 上的用户程序，也包含了 Newlib 库。&lt;/p&gt;
&lt;h2 id="section-1"&gt;框架代码结构&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;nanos-lite/
navy-apps/
    apps/               # 用户程序
        am-apps/
            Makefile
        init/
        litenes/
        lua/
        nterm/
        nwm/
        pal/            # 仙剑奇侠传
        slider/
    fsimg/              # 根文件系统
    libs/               # 库
        libc/           # Newlib C库
        libos/          # 系统调用的用户层封装
            syscall.h   # 系统调用类型
    tests/              # 一些测试
nemu/
nexus-am/
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;libs/libos/syscall.h&lt;/code&gt; 与 &lt;code&gt;nanos-lite/syscall.h&lt;/code&gt; 相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="libs"&gt;libs/&lt;/h1&gt;
&lt;h2 id="libc"&gt;libc/&lt;/h2&gt;
&lt;p&gt;Newlib 项目, 它是一个专门为嵌入式系统提供的 C 库, 库中的函数对运行时环境的要求极低. 这对Nanos-lite来说是非常友好的, 我们不需要为了配合C库而在Nanos-lite中实现额外的功能. 用户程序的入口位于 &lt;code&gt;navy-apps/libs/libc/start.c&lt;/code&gt; 中的 &lt;code&gt;_start()&lt;/code&gt; 函数, 它会调用用户程序的 &lt;code&gt;main()&lt;/code&gt; 函数, 从 &lt;code&gt;main()&lt;/code&gt; 函数返回后会调用 &lt;code&gt;exit()&lt;/code&gt; 结束运行.&lt;/p&gt;
&lt;h2 id="libossrcnanos.c"&gt;libos/src/nanos.c&lt;/h2&gt;
&lt;p&gt;系统调用的用户层封装。&lt;/p&gt;
&lt;h3 id="syscall"&gt;函数 &lt;em&gt;syscall&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;进行系统调用的接口。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;intptr_t _syscall_(int type, intptr_t a0, intptr_t a1, intptr_t a2) {
  int ret;
  asm volatile(&amp;quot;int $0x80&amp;quot;: &amp;quot;=a&amp;quot;(ret): &amp;quot;a&amp;quot;(type), &amp;quot;b&amp;quot;(a0), &amp;quot;c&amp;quot;(a1), &amp;quot;d&amp;quot;(a2));
  return ret;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-2"&gt;一系列系统调用函数&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;函数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_exit&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;退出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_open&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;打开文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_write&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;写入文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_sbrk&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;增长堆区大小&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_read&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;读取文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_close&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;关闭文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_lseek&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;改变文件流位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;_execve&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;(TODO)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id="section-3"&gt;引用资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://legacy.gitbook.com/book/nju-ics/ics2018-programming-assignment/details"&gt;ICS2018 PA 讲义&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Learning/multimod-64bit-method</id><title type="text">64位有符号数乘法取模问题</title><summary type="text">问题引入
给定 $64$ 位有符号整数 &lt;span class="math"&gt;\(a,b,m\)&lt;/span&gt; （类型为 int64_t），希望求出 &lt;span class="math"&gt;\(a\ti</summary><published>2018-10-25T17:30:22+08:00</published><updated>2018-10-25T17:30:22+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Learning%2Fmultimod-64bit-method" /><category term="Learning" /><content type="html">&lt;h1 id="section"&gt;问题引入&lt;/h1&gt;
&lt;p&gt;给定 $64$ 位有符号整数 &lt;span class="math"&gt;\(a,b,m\)&lt;/span&gt; （类型为 &lt;code&gt;int64_t&lt;/code&gt;），希望求出 &lt;span class="math"&gt;\(a\times b \bmod m\)&lt;/span&gt; 的数值。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int64_t multimod(int64_t a, int64_t b, int64_t m);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;给出一个尽可能高效的正确 &lt;code&gt;multimod&lt;/code&gt; 实现。使得它对于任意在 &lt;span class="math"&gt;\([0,2^{63}-1]\)&lt;/span&gt; 范围内的 &lt;span class="math"&gt;\(a,b,m\)&lt;/span&gt; 均能正确求出 &lt;span class="math"&gt;\(a\times b \bmod m\)&lt;/span&gt; 的数值，且在任何时候不触发有符号整数溢出。&lt;/p&gt;
&lt;h1 id="section-1"&gt;解决方法&lt;/h1&gt;
&lt;h2 id="section-2"&gt;运行环境&lt;/h2&gt;
&lt;p&gt;Windows 10 （64 位） 上 Hyper-V 平台，Debian 9 虚拟机 （64 位）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 型号：Intel(R) Core(TM) i7-7700HQ&lt;/li&gt;
&lt;li&gt;CPU 主频：2.80 GHz&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;基础设施&lt;/h2&gt;
&lt;p&gt;为使实验顺利，实验前先准备了测试程序和时间测量程序。&lt;/p&gt;
&lt;h3 id="section-4"&gt;测试程序&lt;/h3&gt;
&lt;p&gt;使用 Python 自动生成测试用例，运行程序，检查输出。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os
import random
import sys

def getNum():
    return random.randint(0,2**63-1)

if __name__==&amp;quot;__main__&amp;quot;:
    cnt = 10**4;
    passed = 0
    failed = 0
    if len(sys.argv)&amp;gt;1:
        cnt = int(sys.argv[1])
    print(&amp;quot;Running&amp;quot;)
    for i in range(cnt):
        a,b,m = getNum(),getNum(),getNum()
        ans = a*b%m
        _ans = int(os.popen(&amp;quot; &amp;quot;.join([&amp;quot;./runner&amp;quot;,str(a),str(b),str(m)])).read())
        if ans != _ans:
            if failed &amp;lt;= 5:
                print(&amp;quot;Error for a =&amp;quot;,a,&amp;quot;b =&amp;quot;,b,&amp;quot;m =&amp;quot;,m,&amp;quot;:&amp;quot;)
                print(&amp;quot;expected&amp;quot;,ans,&amp;quot;but real&amp;quot;,_ans)
            failed+=1
        else:
            passed+=1
    print(&amp;quot;Test&amp;quot;,cnt,&amp;quot;cases&amp;quot;);
    print(&amp;quot;Passed&amp;quot;,passed);
    print(&amp;quot;Failed&amp;quot;,failed);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;runner&lt;/code&gt; 程序调用 &lt;code&gt;multimod&lt;/code&gt; 并将结果输出。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;p.c&amp;quot;

typedef int64_t (*func)(int64_t, int64_t, int64_t);

int main(int argc, char *argv[]){
    assert(argc == 4);
    int64_t a, b, m;
    sscanf(argv[1], &amp;quot;%lld&amp;quot;, &amp;amp;a);
    sscanf(argv[2], &amp;quot;%lld&amp;quot;, &amp;amp;b);
    sscanf(argv[3], &amp;quot;%lld&amp;quot;, &amp;amp;m);
    func f = multimod;
    int64_t ans = f(a, b, m);
    printf(&amp;quot;%lld\n&amp;quot;,ans);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-5"&gt;计时程序&lt;/h3&gt;
&lt;p&gt;使用 Python 随机生成测试用例，调用计时程序得到单次运行时间，统计后取平均值，会输出总耗时，平均耗时，和最大耗时，最小耗时。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;import os
import random
import sys
import time

def getNum():
    return random.randint(0,2**63-1)

if __name__==&amp;quot;__main__&amp;quot;:
    cnt = 10**4;
    passed = 0
    failed = 0
    if len(sys.argv)&amp;gt;1:
        cnt = int(sys.argv[1])
    print(&amp;quot;Running&amp;quot;)
    start = time.time()
    l = []
    for i in range(cnt):
        a,b,m = getNum(),getNum(),getNum()
        ans = int(os.popen(&amp;quot; &amp;quot;.join([&amp;quot;./timer&amp;quot;,str(a),str(b),str(m)])).read())
        l.append((a,b,m,ans))
    end = time.time()
    print(&amp;quot;Test&amp;quot;,cnt,&amp;quot;cases use&amp;quot;,end-start,&amp;quot;seconds&amp;quot;);
    _l = list(map(lambda x: x[3],l))
    sumC = sum(_l)
    print(&amp;quot;Sum CPU cycles:&amp;quot;,sumC)
    print(&amp;quot;Average CPU cycles:&amp;quot;,sumC / len(l))
    mx,mn = max(_l),min(_l)
    idmx,idmn = _l.index(mx),_l.index(mn)
    print(&amp;quot;Maximum:&amp;quot;, mx, &amp;quot;@&amp;quot;, l[idmx])
    print(&amp;quot;Minimum:&amp;quot;, mn, &amp;quot;@&amp;quot;, l[idmn])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;timer&lt;/code&gt; 程序调用 &lt;code&gt;multimod&lt;/code&gt; 进行运算并使用 Linux 中的 &lt;code&gt;clock_gettime&lt;/code&gt; 函数获取执行时间（纳秒级，CPU 时钟数）。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdint.h&amp;gt;
#include &amp;lt;assert.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;time.h&amp;gt;

#include &amp;quot;p.c&amp;quot;

typedef int64_t (*func)(int64_t, int64_t, int64_t);
volatile int64_t a, b, m;
uint64_t measure(func f){
    struct timespec st;
    clock_gettime(CLOCK_MONOTONIC,&amp;amp;st);
    int64_t before = st.tv_nsec;
    f(a, b, m);
    clock_gettime(CLOCK_MONOTONIC,&amp;amp;st);
    int64_t after = st.tv_nsec;
    return after - before;
}

int main(int argc, char *argv[]){
    assert(argc == 4);
    sscanf(argv[1], &amp;quot;%lld&amp;quot;, &amp;amp;a);
    sscanf(argv[2], &amp;quot;%lld&amp;quot;, &amp;amp;b);
    sscanf(argv[3], &amp;quot;%lld&amp;quot;, &amp;amp;m);
    func f = multimod;
    uint64_t ans = measure(f);
    printf(&amp;quot;%llu\n&amp;quot;,ans);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="makefile"&gt;Makefile&lt;/h3&gt;
&lt;p&gt;Makefile 文件指定依赖关系，使用 &lt;code&gt;make check&lt;/code&gt; 和 &lt;code&gt;make time&lt;/code&gt; 调用上述程序。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-makefile"&gt;.PHONY : clean time check all

all : timer runner
	@echo &amp;quot;Builded&amp;quot;

# p.o : p.c
	# $(CC) p.c -c $(CFLAGS) -o p.o

timer: timer.o p.c
	$(CC) -o timer timer.o $(CFLAGS) $(LDFLAGS) -O2

runner: runner.o p.c
	$(CC) -o runner runner.o $(CFLAGS) $(LDFLAGS) -O2

time: timer
	@python3 ./measure.py

check: runner
	@python3 ./checker.py

clean:
	-rm -f *.o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了上述基础设施后，下面开始编写 &lt;code&gt;multimod&lt;/code&gt; 函数。&lt;/p&gt;
&lt;h2 id="section-6"&gt;基准实现&lt;/h2&gt;
&lt;p&gt;使用朴素二进制乘法，设输入 &lt;span class="math"&gt;\(A,B\)&lt;/span&gt;，则结果 &lt;span class="math"&gt;\(C\)&lt;/span&gt; 有&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(C_{i+j} = \sum_{0\le i,j &amp;lt; 64} A_iB_j\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则有&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Ans=(\sum_{0\le i &amp;lt; 128} (C_i\times 2^i)\bmod m)\bmod m\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意到 $0\le m &amp;lt; 2^{63}$，两个 &lt;span class="math"&gt;\(m\)&lt;/span&gt; 以内的数相加不会发生无符号溢出。故转成无符号数，将乘 $2^i$，转化为 &lt;span class="math"&gt;\(i\)&lt;/span&gt; 次翻倍迭代取模就可以避免溢出。&lt;/p&gt;
&lt;p&gt;最终程序为：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdint.h&amp;gt;
int64_t multimod(int64_t a, int64_t b, int64_t m){
    const int L = 128;
    uint64_t c[L];
    for(int i = 0; i &amp;lt; L; i++)
        c[i] = 0;
    for(int i = 0; i &amp;lt; 64; i++)
        for(int j = 0; j &amp;lt; 64; j++)
            c[i+j]+=((a&amp;gt;&amp;gt;i&amp;amp;1)&amp;amp;(b&amp;gt;&amp;gt;j&amp;amp;1));
    uint64_t ans = 0;
    for(int i=0;i&amp;lt;L;i++){
        uint64_t t = c[i];
        for(int j=0;j&amp;lt;i;j++)
            t=(t&amp;lt;&amp;lt;1)%m;
        ans=(ans+t)%m;
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;make check&lt;/code&gt; 测试，输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Running
Test 10000 cases
Passed 10000
Failed 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过测试。&lt;/p&gt;
&lt;h2 id="section-7"&gt;性能优化&lt;/h2&gt;
&lt;h3 id="section-8"&gt;优化1：二进制拆分&lt;/h3&gt;
&lt;p&gt;使用 ACM/ICPC 圈子中常用的一种计算 &lt;span class="math"&gt;\(ab \bmod m\)&lt;/span&gt; 的算法。将 &lt;span class="math"&gt;\(b\)&lt;/span&gt; 二进制拆分，得到其二进制表示 &lt;span class="math"&gt;\((b_{63}\dots b_0)_2\)&lt;/span&gt;，则&lt;/p&gt;
&lt;div class="math"&gt;
\[
ab=\sum_{0\le i&amp;lt;64} b_i\times a2^i
\]&lt;/div&gt;
&lt;p&gt;&lt;span class="math"&gt;\(a2^i\)&lt;/span&gt; 可以递推得到，由此可得到 &lt;span class="math"&gt;\(O(\log b)\)&lt;/span&gt; 的算法。类似基准实现中讨论，转成无符号数后不会出现溢出问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdint.h&amp;gt;
int64_t multimod(int64_t a, int64_t b, int64_t m){
    uint64_t _a = a % m, _b = b % m;
    uint64_t ans = 0;
    while(_b){
        if(_b &amp;amp; 1){
            ans+=_a;
            ans%=m;
        }
        _a+=_a;
        _a%=m;
        _b&amp;gt;&amp;gt;=1;
    }
    return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;make check&lt;/code&gt; 测试，输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Running
Test 10000 cases
Passed 10000
Failed 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过测试。&lt;/p&gt;
&lt;h3 id="section-9"&gt;优化2：高低位分别处理&lt;/h3&gt;
&lt;p&gt;类比计算 32 位整数乘积时的算法。将 &lt;span class="math"&gt;\(a,b\)&lt;/span&gt; 的高32位，和低32位各自取出，得到&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(a=a_1\times 2^{32} + a_0\)&lt;/span&gt;
&lt;span class="math"&gt;\(b=b_1\times 2^{32} + b_0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;则&lt;/p&gt;
&lt;div class="math"&gt;
\[
\begin{aligned}
ab&amp;amp;=(a_1\times 2^{32} + a_0)(b_1\times 2^{32} + b_0)\\
&amp;amp;=a_1b_1\times 2^{64} + (a_0b_1+a_1b_0)\times 2^{32} + a_0b_0
\end{aligned}
\]&lt;/div&gt;
&lt;p&gt;由输入范围限制，可得 &lt;span class="math"&gt;\(a_1b_1&amp;lt;2^{64},a_0b_1+a_1b_0&amp;lt;2^{64}\)&lt;/span&gt;，但 &lt;span class="math"&gt;\(a_0b_0\)&lt;/span&gt; 可能发生一位溢出（因为 &lt;span class="math"&gt;\(a_0,b_0\)&lt;/span&gt; 可能等于 $2^{32}-1$。&lt;/p&gt;
&lt;p&gt;设 &lt;span class="math"&gt;\(ab=c=c_1\times 2^{64} + c_0\)&lt;/span&gt;，则有&lt;/p&gt;
&lt;p&gt;&lt;span class="math"&gt;\(c_1 = a_1b_1+(a_0b_1+a_1b_0)_ {h32} + \text{OF}(a_0b_0)\)&lt;/span&gt;
&lt;span class="math"&gt;\(c_0 = (a_0b_0)\bmod 2^{32}+(a_0b_1+a_1b_0)_{l32}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由此可计算得出 &lt;span class="math"&gt;\(c_1,c_0\)&lt;/span&gt;，由基准实现中讨论，将 &lt;span class="math"&gt;\(c_1\times 2^{64} \bmod m\)&lt;/span&gt; 转化成 $64$ 次翻倍迭代，避免溢出问题。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdint.h&amp;gt;
// #include &amp;lt;assert.h&amp;gt;
static uint32_t _32f = (~((uint32_t)0));
static uint64_t _64f = (~((uint64_t)0));
int64_t multimod(int64_t a, int64_t b, int64_t m){
    uint64_t a1 = a&amp;gt;&amp;gt;32, a0 = a&amp;amp;_32f;
    uint64_t b1 = b&amp;gt;&amp;gt;32, b0 = b&amp;amp;_32f;
    uint64_t t = a1*b0 + a0*b1;
    uint64_t t1 = t&amp;gt;&amp;gt;32, t0 = t&amp;amp;_32f, tc0 = a0*b0;
    uint64_t c1 = a1*b1 + t1, c0 = tc0 + (t0&amp;lt;&amp;lt;32);
    if(c0&amp;lt;tc0) // overflow
        c1++;
    // __int128 _cor = ((__int128)a)*((__int128)b);
    // assert((_cor&amp;gt;&amp;gt;64)==c1);
    // assert((_cor&amp;amp;_64f)==c0);
    for(int i=0;i&amp;lt;64;i++)
        c1 = (c1&amp;lt;&amp;lt;1)%m;
    return (c0%m + c1)%m;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;make check&lt;/code&gt; 测试，输出如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Running
Test 10000 cases
Passed 10000
Failed 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过测试。&lt;/p&gt;
&lt;h3 id="section-10"&gt;效率实测&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;make time&lt;/code&gt; 测试得到。以下表格中数值为测试 10000 组随机用例，得到的平均单次操作 CPU 时钟数。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;程序&lt;/th&gt;
&lt;th&gt;&lt;code&gt;O0&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;O1&lt;/code&gt;&lt;/th&gt;
&lt;th&gt;&lt;code&gt;O2&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;p1.c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$98554.87$&lt;/td&gt;
&lt;td&gt;$102880.89$&lt;/td&gt;
&lt;td&gt;$100160.11$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;p2.c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$1470.79$&lt;/td&gt;
&lt;td&gt;$1472.98$&lt;/td&gt;
&lt;td&gt;$1473.57$&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;p3.c&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;$1185.46$&lt;/td&gt;
&lt;td&gt;$1217.1$&lt;/td&gt;
&lt;td&gt;$1207.91$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;可见优化 1，2 较基准实现提高显著，不同编译优化级别对此程序运行效率影响不大。&lt;/p&gt;
&lt;p&gt;注：&lt;code&gt;make time&lt;/code&gt; 输出内容&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-sh"&gt;# -O0

# p1.c

Running
Test 10000 cases use 11.16751217842102 seconds
Sum CPU cycles: 985548700
Average CPU cycles: 98554.87
Maximum: 4802300 @ (2265130052289059763, 7783645480371944058, 3115603639858794422, 4802300)
Minimum: 87600 @ (20906801206135418, 1235445072834323451, 7495840395140955697, 87600)

# p2.c

Running
Test 10000 cases use 11.892813444137573 seconds
Sum CPU cycles: 14707900
Average CPU cycles: 1470.79
Maximum: 142700 @ (1598719057711499987, 8349967337302892367, 5320637895082198498, 142700)
Minimum: 1000 @ (7326329361318569666, 6606926909931228833, 6606926867070148477, 1000)

# p3.c

Running
Test 10000 cases use 12.87213659286499 seconds
Sum CPU cycles: 11854600
Average CPU cycles: 1185.46
Maximum: 58500 @ (957615596508775045, 4417329977803451093, 6085566768103491103, 58500)
Minimum: 900 @ (3868418006544775637, 3115279496994464447, 2343316703378067646, 900)

# -O1

# p1.c

Running
Test 10000 cases use 12.523572444915771 seconds
Sum CPU cycles: 1028808900
Average CPU cycles: 102880.89
Maximum: 1932400 @ (7242145147389599538, 1833121011939475515, 6206342766087253890, 1932400)
Minimum: 87500 @ (1822799065865324744, 2537174733001160, 158801504793342122, 87500)

# p2.c

Running
Test 10000 cases use 10.98656439781189 seconds
Sum CPU cycles: 14729800
Average CPU cycles: 1472.98
Maximum: 75600 @ (221577760594163762, 3833386045247446405, 2751795901368777150, 75600)
Minimum: 1100 @ (371764953656247878, 5957505246066178493, 661631939839983461, 1100)

# p3.c

Running
Test 10000 cases use 13.122157096862793 seconds
Sum CPU cycles: 12171000
Average CPU cycles: 1217.1
Maximum: 271900 @ (7398188815938423410, 8253708753758420468, 4659411386263076728, 271900)
Minimum: 900 @ (3809943949718199994, 3287343789103329664, 8650829315397374343, 900)

# -O2

# p1.c

Running
Test 10000 cases use 13.260606288909912 seconds
Sum CPU cycles: 1001601100
Average CPU cycles: 100160.11
Maximum: 926300 @ (339379419259308487, 3491644293891775690, 4785117665160931184, 926300)
Minimum: 87500 @ (5052948108270793981, 27482781138671, 7792928891817598563, 87500)

# p2.c

Running
Test 10000 cases use 12.278534412384033 seconds
Sum CPU cycles: 14735700
Average CPU cycles: 1473.57
Maximum: 132100 @ (7176780085212300945, 2291171313687225809, 7324459208582226040, 132100)
Minimum: 1000 @ (9203745517614844759, 6874714748664006916, 67857160092233, 1000)

# p3.c

Running
Test 10000 cases use 12.674974918365479 seconds
Sum CPU cycles: 12079100
Average CPU cycles: 1207.91
Maximum: 202400 @ (8532847693583176248, 6988877428537774137, 8782939934027677977, 202400)
Minimum: 900 @ (3971319143760212181, 2705697508146050036, 1115671950010882609, 900)
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><id>Reading/C-Traps-and-Pitfalls</id><title type="text">C Traps and Pitfalls</title><summary type="text">书籍名：C Traps and Pitfalls
作者：Andrew Koenig
出版时间：1989-1-11
基本介绍：Andrew Koenig 是AT&amp;T公司Shannon实验室大规模编程研究</summary><published>2018-08-26T10:30:40+08:00</published><updated>2018-08-26T10:30:40+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Reading%2FC-Traps-and-Pitfalls" /><category term="Reading" /><content type="html">&lt;ul&gt;
&lt;li&gt;书籍名：&lt;strong&gt;C Traps and Pitfalls&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;作者：Andrew Koenig&lt;/li&gt;
&lt;li&gt;出版时间：1989-1-11&lt;/li&gt;
&lt;li&gt;基本介绍：Andrew Koenig 是AT&amp;amp;T公司Shannon实验室大规模编程研究部门中的成员，同时也是C++标准委员会的项目编辑。作者以自己1985年在Bell实验室时发表的一篇论文为基础，结合自己的工作经验扩展成为这本对C程序员具有珍贵价值的经典著作。写作本书的出发点不是要批判C语言，而是要帮助C程序员绕过编程过程中的陷阱和障碍。&lt;strong&gt;本书写于 ANSI C 正式发布前。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id="section"&gt;第一章 词法陷阱&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt; 不同于 &lt;code&gt;==&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;,|&lt;/code&gt; 不同于 &lt;code&gt;&amp;amp;&amp;amp;,||&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;词法分析中的贪心法：每一个符号应包含尽可能多的字符&lt;/li&gt;
&lt;li&gt;如果整型常量以 &lt;code&gt;0&lt;/code&gt; 开头，则被视为八进制，以 &lt;code&gt;0x&lt;/code&gt; 开头，被视为十六进制。&lt;/li&gt;
&lt;li&gt;字符串末尾有 &lt;code&gt;\0&lt;/code&gt; 即 $0$&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;第二章 语法陷阱&lt;/h1&gt;
&lt;h2 id="section-2"&gt;函数声明&lt;/h2&gt;
&lt;p&gt;声明的形式：类型+一组类似表达式的声明符
表示对声明符求值应返回一个指定类型的结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int a;          //a         整型        a 整型
int *a;         //*a        整型        a 指向整型的指针
int *g();       //*(g())    整型        g 返回整形指针的函数
int (*h)();     //(*h)()    整型        h 指向返回整型的函数的指针
int (*f)(int);  //(*f)(int) 整型        f 指向有一个整型参数，返回整型的函数的指针
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;声明省去标识符，即得到对应的类型转化符。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;(int)
(int *)
(int *())
(int (*)())
(int (*)(int))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;typedef&lt;/code&gt; 简化类型表示&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;typedef int (*func)(int);
//func=(int (*)(int))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-3"&gt;运算符优先级&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;() [] -&amp;gt; .&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;单目&lt;/li&gt;
&lt;li&gt;双目&lt;/li&gt;
&lt;li&gt;算术 &lt;code&gt;* / %&lt;/code&gt; &amp;gt; &lt;code&gt;+ -&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;移位&lt;/li&gt;
&lt;li&gt;关系 &lt;code&gt;&amp;lt; &amp;lt;= &amp;gt; &amp;gt;=&lt;/code&gt; &amp;gt; &lt;code&gt;== !=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;位逻辑 &lt;code&gt;&amp;amp;&lt;/code&gt; &amp;gt; &lt;code&gt;^&lt;/code&gt; &amp;gt; &lt;code&gt;|&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;逻辑 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; &amp;gt; &lt;code&gt;||&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;三目（&lt;code&gt;?:&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;,&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="section-4"&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;语句结束的分号&lt;/li&gt;
&lt;li&gt;switch 结构中的 break&lt;/li&gt;
&lt;li&gt;函数调用：&lt;code&gt;f&lt;/code&gt; 为函数地址，&lt;code&gt;f()&lt;/code&gt; 为函数调用&lt;/li&gt;
&lt;li&gt;else 与同一对括号内最近的未匹配 if 匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-5"&gt;第三章 语义陷阱&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;C语言中只有一维数组，但数组中的元素的类型没有限制。&lt;/li&gt;
&lt;li&gt;数组名不用于 &lt;code&gt;sizeof&lt;/code&gt; 的操作数时，其都被转换成一个指向其起始元素的指针。&lt;/li&gt;
&lt;li&gt;C语言中会将参数中的数组声明转化为对应的指针声明&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-6"&gt;第四章 连接&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;如果一个声明语句出现在所有函数体之外，那么它就被称为外部对象 a 的定义。&lt;/li&gt;
&lt;li&gt;带 &lt;code&gt;extern&lt;/code&gt; 的声明语句，并不是对 a 的定义，其显式地说明了 a 的存储空间是在程序其他地方分配的。对于连接器，此为对外部变量的引用。对于这种语句，即使其出现在函数体内，含义仍相同。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; 将声明的变量或函数的作用域限制在当前源文件内&lt;/li&gt;
&lt;li&gt;旧的 C语言 要求变量定义必须在源文件头部。&lt;/li&gt;
&lt;li&gt;可用头文件定义一些对外部变量的引用，在某个源文件中给出定义，其他源文件使用头文件访问这些变量。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-7"&gt;第五章 库函数&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getchar&lt;/code&gt; 函数返回整数，EOF 往往不在 char 的表示范围内。&lt;/li&gt;
&lt;li&gt;输出缓冲：&lt;code&gt;setbuf(stdout,buf)&lt;/code&gt;，若 buf 使用局部变量，可能在缓冲清空前， buf 就已经被释放了。
&lt;ul&gt;
&lt;li&gt;可以使用 &lt;code&gt;setbuf(stdout,NULL)&lt;/code&gt; 取消缓冲&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-8"&gt;第六章 预处理器&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;宏只是对程序的文本起作用，支持对字符串进行变换，但不作用与程序中的对象。&lt;/li&gt;
&lt;li&gt;宏定义中空格有意义（宏调用中不存在此情况）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#define f (x) ((x)-1)
//f=(x)((x)-1) 不带参数
#define f(x) ((x)-1)
//f(x)=((x)-1) 带参数
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;宏不是函数，表达式可能被多次求值，若传入表达式存在副作用，则结果可能出乎意料。&lt;/li&gt;
&lt;li&gt;宏可能产生非常庞大的表达式&lt;/li&gt;
&lt;li&gt;宏不是语句&lt;/li&gt;
&lt;li&gt;宏不是类型定义&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-9"&gt;第七章 可移植性缺陷&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;内存位置 0：仅用于赋值或比较运算，其他操作都是非法的，不同编译器和机器对此位置的限制不同。&lt;/li&gt;
&lt;li&gt;除法截断 &lt;code&gt;q=a/b, r=a%b&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;C 语言定义只保证了 &lt;span class="math"&gt;\(qb+r=a\)&lt;/span&gt;，以及 &lt;span class="math"&gt;\(a\ge 0 \wedge b&amp;gt;0\)&lt;/span&gt; 时，&lt;span class="math"&gt;\(|r|&amp;lt;|b|\wedge r\ge 0\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;大部分编译器保证了，若改变 &lt;span class="math"&gt;\(a\)&lt;/span&gt; 的符号，这会改变 &lt;span class="math"&gt;\(q\)&lt;/span&gt; 的符号，但不会改变其绝对值&lt;/li&gt;
&lt;li&gt;除法运算结果是向 $0$ 取整（即绝对值向下取整），如 &lt;span class="math"&gt;\(-5/-2=\lfloor \frac{-5}{-2} \rfloor=2,-5/2=\lceil \frac{-5}{2} \rceil=-2\)&lt;/span&gt;，这保证了 &lt;code&gt;a%b&lt;/code&gt; 一定与 &lt;code&gt;a&lt;/code&gt; 同号&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-10"&gt;附录&lt;/h1&gt;
&lt;h2 id="printf"&gt;&lt;code&gt;printf&lt;/code&gt; 函数格式串&lt;/h2&gt;
&lt;p&gt;每个格式项以 &lt;code&gt;%&lt;/code&gt; 打头，后接一个格式码指明类型，其之间可能夹一些可选字符（修饰符）。顺序如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;%&amp;lt;标志&amp;gt;&amp;lt;宽度修饰符&amp;gt;.&amp;lt;精度修饰符&amp;gt;&amp;lt;长度修饰符&amp;gt;&amp;lt;格式码&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="section-11"&gt;格式码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt; 带符号整数，十进制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; 无符号整数，十进制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt; 整数，八进制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; 整数，十六进制（&lt;code&gt;abcdef&lt;/code&gt;）
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;X&lt;/code&gt; 整数，十六进制（&lt;code&gt;ABCDEF&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 字符串，直到 &lt;code&gt;\0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; 字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g&lt;/code&gt; 浮点数，去掉尾缀0，保留六位有效数字，可能采用科学计数法（&lt;code&gt;1e1&lt;/code&gt;）
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;G&lt;/code&gt; 浮点数，去掉尾缀0，保留六位有效数字，可能采用科学计数法（&lt;code&gt;1E1&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e&lt;/code&gt; 浮点数，指数形式（&lt;code&gt;1e1&lt;/code&gt;），小数点后六位有效数字
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;E&lt;/code&gt; 浮点数，指数形式（&lt;code&gt;1E1&lt;/code&gt;），小数点后六位有效数字&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; 浮点数，禁用指数形式，小数点后六位有效数字&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt; 一个 &lt;code&gt;%&lt;/code&gt; 字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; 指针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt; 指出已经打印的字符数，将被存储在传入的整型指针处
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;printf(&amp;quot;hello\n%n&amp;quot;,&amp;amp;n)&lt;/code&gt; 则 &lt;span class="math"&gt;\(n=6\)&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="section-12"&gt;修饰符&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;长度修饰符：&lt;code&gt;l&lt;/code&gt;。对应 long&lt;/li&gt;
&lt;li&gt;宽度修饰符：&lt;code&gt;&amp;lt;int&amp;gt;&lt;/code&gt;。指定最小输出宽度，默认右对齐&lt;/li&gt;
&lt;li&gt;精度修饰符：&lt;code&gt;.&amp;lt;int&amp;gt;&lt;/code&gt;。控制数值表示中将要出现的数字位数，或用于限制将要输出的字符串中应出现的字符数。在宽度修饰符后。
&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;d,o,x,u,X&lt;/code&gt; 指定打印数字最少位数（不包含符号），若不足，在前面补0&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;e,E,f&lt;/code&gt; 指定小数点后应出现的数字位数，除非标识符另有说明，仅当精度大于 0 时，打印的数值中才会实际出现小数点&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;g,G&lt;/code&gt; 指定打印数值中的有效数字位数，除非标识符另有说明，非有效数字的0将被去掉，如果小数点后不跟数字则小数点也会被删除&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;s&lt;/code&gt;，指定要打印的最大字符数&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;c,%&lt;/code&gt; 精度修饰符将被忽略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="section-13"&gt;标志&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;%&lt;/code&gt; 和宽度修饰符之间插入标志字符，微调效果。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; 改为左对齐&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt; 强制打印符号&lt;/li&gt;
&lt;li&gt;空白字符 若数值是非负数，则在其前插入一个空白字符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#&lt;/code&gt; 微调
&lt;ul&gt;
&lt;li&gt;对浮点数格式：要求小数点必须被打印，对于 &lt;code&gt;g,G&lt;/code&gt; 数值尾缀0不会被去掉&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="section-14"&gt;可变域宽&lt;/h3&gt;
&lt;p&gt;支持间接指定域宽和精度：使用 &lt;code&gt;*&lt;/code&gt; 替换宽度修饰符，精度修饰符，则参数列表中需添加指定的宽度，精度值。对于给定域宽为负数的情况，相当于把符号作为标志字符 &lt;code&gt;-&lt;/code&gt; 处理。&lt;/p&gt;
</content></entry><entry><id>Reading/The-C-Programming-Language</id><title type="text">The C Programming Language</title><summary type="text">书籍名：The C Programming Language (Second Edition)
作者：Brian W. Kernighan / Dennis M. Ritchie
出版时间：1988-</summary><published>2018-08-26T09:30:40+08:00</published><updated>2018-08-26T09:30:40+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Reading%2FThe-C-Programming-Language" /><category term="Reading" /><content type="html">&lt;ul&gt;
&lt;li&gt;书籍名：&lt;strong&gt;The C Programming Language (Second Edition)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;作者：Brian W. Kernighan / Dennis M. Ritchie&lt;/li&gt;
&lt;li&gt;出版时间：1988-4-1&lt;/li&gt;
&lt;li&gt;基本介绍：《C程序设计语言》原著 即为C语言的设计者Dennis M．Ritchie和著名的计算机科学家Brian W．Kernighan合著的 一本介绍C语言的权威经典著作。原著第1版中介绍的C语言成为后来广泛使用的C语言版本—— 标准C的基础。人们熟知的“Hello, World”程序就是由《C程序设计语言》首次引入的。原著第2版根据1987年制定的ANSIC标准做了适当的修订。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h1 id="section"&gt;第二章&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;枚举 &lt;code&gt;enum id{A=1,B=2,...}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串支持连接 &lt;code&gt;&amp;quot;abc&amp;quot; &amp;quot;def&amp;quot;=&amp;quot;abcdef&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ctype&lt;/code&gt; 中的函数与字符表无关&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;unsigned&lt;/code&gt; 的变量在隐式转换时和具体实现有关要十分注意，可能不是预期的。&lt;/li&gt;
&lt;li&gt;float 不会自动提升为 double&lt;/li&gt;
&lt;li&gt;伪随机数算法 &lt;span class="math"&gt;\([0,32767]\)&lt;/span&gt; 的伪随机整数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;unsigned long int _next=1;
int rand(){
    _next=_next*1103515245+12345;
    return (unsigned int)(_next/65536)%32768;
}
void srand(unsigned int seed){_next=seed;}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;逗号表达式从左到右求值，最右侧的表达式为其结果值。函数参数中的逗号不是逗号表达式，C语言没有定义其运算顺序&lt;/li&gt;
&lt;li&gt;对于一个运算，左右表达式的运算先后是不确定的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;第三章&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Shell-Sort&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void shellsort(int v[],int n){
    for(int gap=n&amp;gt;&amp;gt;1;gap;gap&amp;gt;&amp;gt;=1)
        for(int i=gap;i&amp;lt;n;i++)
            for(int j=i-gap;j&amp;gt;=0 &amp;amp;&amp;amp; v[j]&amp;gt;v[j+gap];j-=gap)
                swap(v[j],v[j+gap]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-2"&gt;第四章&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;external&lt;/code&gt;,&lt;code&gt;internal&lt;/code&gt; 关键字修饰变量&lt;/li&gt;
&lt;li&gt;&lt;code&gt;register&lt;/code&gt; 关键字，寄存器变量地址不可访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;static&lt;/code&gt; 关键字修饰全局变量，使变量限定在当前编译文件中&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;预处理&lt;/h2&gt;
&lt;h3 id="section-4"&gt;宏定义&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;行末使用 &lt;code&gt;\&lt;/code&gt; 使用多行定义&lt;/li&gt;
&lt;li&gt;&lt;code&gt;undef&lt;/code&gt; 取消宏定义&lt;/li&gt;
&lt;li&gt;替换文本中 &lt;code&gt;#&lt;/code&gt;加在参数名前，则将会生成和参数书写完全相同的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#define debug(expr) printf(#expr &amp;quot; = %g\n&amp;quot;,expr)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;##&lt;/code&gt; 运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#define paste(a,b) a ## b
paste(name,1) =&amp;gt; name1
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="section-5"&gt;条件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#if&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#endif&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#elif&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#else&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#ifdef = #if defined id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#ifndef = #if !defined id&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#line constval [&amp;quot;filename&amp;quot;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#error ...&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#praga ...&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-6"&gt;第五章&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void*&lt;/code&gt; 作为通用指针&lt;/li&gt;
&lt;li&gt;指针实现数组一般快于下标实现数组&lt;/li&gt;
&lt;li&gt;指针支持和整数加减，与指针相减和比较运算（位置比较）&lt;/li&gt;
&lt;li&gt;数组和指针不完全等价，数组本身不可变，但指针可以&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void strcpy(char* s,char *t){
    while(*s++=*t++);
}
*p++=val;//push
val=*--p;//pop
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;以下表达等价&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;f(int c[2][13])
f(int c[][13])
f(int (*c)[13])
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-7"&gt;第六章&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;union&lt;/code&gt; 类型：同一起点，不同类型变量，自动对齐，只能对第一个元素初始化&lt;/li&gt;
&lt;li&gt;位字段：二进制标志位集合，后面的数字指定位长，仅能使用 &lt;code&gt;int&lt;/code&gt;，不支持 &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;struct{
    unsigned int a:1;
    unsigned int b:1;
}flgs;
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-8"&gt;第七章&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;exit(exitcode)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;printf&lt;/code&gt; 函数格式化：&lt;code&gt;%?&lt;/code&gt; &lt;code&gt;?&lt;/code&gt; 表示转换说明
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-&lt;/code&gt; 左对齐&lt;/li&gt;
&lt;li&gt;数字 最小字段宽度或精度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.&lt;/code&gt; 用于区分最小字段宽度和精度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h/l&lt;/code&gt; 整数作为 &lt;code&gt;short/long&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d/i&lt;/code&gt; 十进制整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;o&lt;/code&gt; 无符号八进制整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x/X&lt;/code&gt; 无符号十六进制整数，指定大小写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;u&lt;/code&gt; 无符号十进制整数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;c&lt;/code&gt; 字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f&lt;/code&gt; double 十进制小数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;e/E&lt;/code&gt; double 十进制小数 科学记数法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g/G&lt;/code&gt; double 十进制小数 根据指数决定使用哪一种表示方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;p&lt;/code&gt; void* 类型&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;*&lt;/code&gt; 指定宽度或精度，将使用下一参数（int）得到&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;变长参数&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;#include &amp;lt;stdarg.h&amp;gt;
void f(char *a,...){
    va_list ap;
    va_start(ap,fmt);
    for(char* p=fmt;*p;p++){

    }
    va_end(ap);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;scanf&lt;/code&gt; 函数 返回成功赋值的个数，文件结尾返回 &lt;code&gt;EOF&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-9"&gt;文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;FILE* fp=fopen(name,mode=&amp;quot;r[+]&amp;quot;,&amp;quot;w[+]&amp;quot;,&amp;quot;a[+]&amp;quot;[,&amp;quot;b&amp;quot;])

//以下是宏而不是函数
int getc(FILE *fp);
int putc(int c,FILE* fp)=c;
fscanf(FILE* fp,...)
fprintf(FILE* fp,...)

//清空缓冲区并关闭文件
int fclose(FILE *fp)
int fflush(FILE *fp)
int ferror(FILE *fp)
int feof(FILE *fp)
char* fgets(char*line,int maxvalue,FILE *fp)=success? line:NULL;
char* fputs(char*line,FILE *fp)=success? line:EOF;
fgetc,fputc
int ungetc(int c,FILE *fp)=success?c:EOF; //写回一个字符，只能接受一个
int remove(const char* filename);//删除文件，成功返回0
int rename(const char* filename);//重命名文件，成功返回0
FILE* tmpfile();//wb+创建临时文件
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;size_t fread(void*ptr,size_t size,size_t nobj,FILE *stream)&lt;/code&gt; 读取最多nobj个长度为size的对象，并保存到ptr数组中，返回读取到的个数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;size_t fwrite(const void*ptr,size_t size,size_t nobj,FILE *stream)&lt;/code&gt; 从ptr数组读取nobj个长度为size的对象，并输出，返回输出的个数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int fseek(FILE* stream, long offset,int origin)&lt;/code&gt;
从origin偏移offset个位置。origin=SEEK_SET,SEEK_CUR,SEEK_END，文本流只能是offest只能是0或ftell得到的值。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long ftell(FILE *stream)&lt;/code&gt; 得到当前位置，错误返回-1L&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void rewind(FILE *stream)&lt;/code&gt; 回到起点，清除错误状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int fgetpos(FILE *stream,fpos_t *pos)&lt;/code&gt; 记录当前位置到pos&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int fsetpos(FILE *stream,const fpos_t *pos)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;标准文件指针 &lt;code&gt;stdin,stdout,stderr&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-10"&gt;字符串函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;strcat(s,t)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strncat(s,t,n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcmp(s,t)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strncmp(s,t,n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strcpy(s,t)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strncpy(s,t,n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strlen(s)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strchr(s,c)&lt;/code&gt; 正向查找，返回指针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strrchr(s,c)&lt;/code&gt; 反向查找，返回指针&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memcpy(s,t,n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memmove(s,t,n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memcmp(s,t,n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memchr(s,c,n)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memset(s,c,n)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-11"&gt;更多函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void* malloc(size_t n)&lt;/code&gt; n字节长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void* calloc(size_t n,size_t size)&lt;/code&gt; n个指定字节长度元素的空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;free(p)&lt;/code&gt; 仅限使用上面两个函数申请的空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ldexp(x,n)&lt;/code&gt; &lt;span class="math"&gt;\(=x\cdot 2^n\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;frexp(x,int* exp)&lt;/code&gt; &lt;span class="math"&gt;\(x=a\cdot 2^n\)&lt;/span&gt;，其中 &lt;span class="math"&gt;\(a \in [1/2,1]\)&lt;/span&gt;，返回$a$，&lt;span class="math"&gt;\(exp=n\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;modf(x,double *ip)&lt;/code&gt; 返回小数部分，&lt;span class="math"&gt;\(ip\)&lt;/span&gt;=整数部分，符号均和 &lt;span class="math"&gt;\(x\)&lt;/span&gt; 相同&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fmod(x,y)&lt;/code&gt; 浮点余数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;double atof(char*)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int atoi(char*)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;long atol(char*)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abort()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ateexit(void (*func)(void))&lt;/code&gt; 登记一个程序正常终止时调用的函数&lt;/li&gt;
&lt;/ul&gt;
</content></entry><entry><id>Problems/leetcode-5467</id><title type="text">LeetCode-5467 找到最接近目标值的函数值</title><summary type="text">区间取 AND 和，固定左端点，结果是递减的，从而目标函数 |ANDSUM(l, r) - target| 是一个单峰函数。
将每个数拆成二进制数位，维护每一位的前缀和，只要第 i 位的区间和 bit</summary><published>2020-07-19T12:30:28+08:00</published><updated>2020-07-19T12:30:28+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Problems%2Fleetcode-5467" /><category term="Problems" /><content type="html">&lt;p&gt;区间取 &lt;code&gt;AND&lt;/code&gt; 和，固定左端点，结果是递减的，从而目标函数 &lt;code&gt;|ANDSUM(l, r) - target|&lt;/code&gt; 是一个单峰函数。&lt;/p&gt;
&lt;p&gt;将每个数拆成二进制数位，维护每一位的前缀和，只要第 &lt;code&gt;i&lt;/code&gt; 位的区间和 &lt;code&gt;bit[r]-bit[l] &amp;lt; r-l&lt;/code&gt; 即可知此区间这一位上存在 0，进而 &lt;code&gt;AND&lt;/code&gt; 和的这一位为 0，否则为 1。&lt;/p&gt;
&lt;p&gt;预处理上述结果后，可以在 &lt;span class="math"&gt;\(O(32)\)&lt;/span&gt; 内得到区间 &lt;code&gt;AND&lt;/code&gt; 和。&lt;/p&gt;
&lt;p&gt;结合之前的单峰函数性质，枚举左端点，使用三分法计算固定左端点下的最优值即可。&lt;/p&gt;
&lt;p&gt;此实现遇到了常数问题，经过常数优化后通过。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cpp"&gt;class Solution
{
    vector&amp;lt;int&amp;gt; bit[30];
    inline int getValue(int l, int r)
    {
        int res = 0;
        for (int i = 0; i &amp;lt; 30; i++)
        {
            if (bit[i][r + 1] - bit[i][l] == r - l + 1)
            {
                res |= (1 &amp;lt;&amp;lt; i);
            }
        }
        return res;
    }
    inline int calc(int l, int r, int target)
    {
        return abs(getValue(l, r) - target);
    }

public:
    int closestToTarget(vector&amp;lt;int&amp;gt; &amp;amp;arr, int target)
    {
        int n = arr.size();
        for (int j = 0; j &amp;lt; 30; j++)
        {
            bit[j].clear();
            bit[j].push_back(0);
        }
        for (int i = 0; i &amp;lt; n; i++)
        {
            for (int j = 0; j &amp;lt; 30; j++)
            {
                bit[j].push_back(bit[j][i] + (arr[i] &amp;gt;&amp;gt; j &amp;amp; 1));
            }
        }
        int ans = 1 &amp;lt;&amp;lt; 30;
        for (int l = 0; l &amp;lt; n; l++)
        {
            int s = l, t = n - 1, tans = 1 &amp;lt;&amp;lt; 30;
            while (s + 2 &amp;lt;= t)
            {
                int len = t - s + 1;
                int ml = s + (len / 3);
                int mr = t - (len / 3);
                int vl = calc(l, ml, target), vr = calc(l, mr, target);
                tans = min(tans, min(vl, vr));
                if (vl &amp;lt;= vr)
                {
                    t = mr;
                }
                else
                {
                    s = ml;
                }
            }
            for (int i = s; i &amp;lt;= t; i++)
                tans = min(tans, calc(l, i, target));
            ans = min(ans, tans);
        }
        return ans;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><id>Problems/leetcode-5464</id><title type="text">LeetCode-5464 换酒问题</title><summary type="text">数据非常小，使用整除和取模迭代运算即可。
class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int</summary><published>2020-07-19T12:30:22+08:00</published><updated>2020-07-19T12:30:22+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Problems%2Fleetcode-5464" /><category term="Problems" /><content type="html">&lt;p&gt;数据非常小，使用整除和取模迭代运算即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -&amp;gt; int:
        result = numBottles
        bot = numBottles
        while bot &amp;gt;= numExchange:
            g = bot // numExchange
            bot = bot % numExchange
            bot += g
            result += g
        return result
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><id>Problems/leetcode-5466</id><title type="text">LeetCode-5466 最多的不重叠子字符串</title><summary type="text">子串的要求是不相交，且若一个子字符串包含字符 c ，那么 s 中所有 c 字符都应该在这个子字符串中。
先找出满足第二个条件的所有子串，由于串仅由小写字母组成，按照 s 中所有 c 字符都应该在这个子</summary><published>2020-07-19T12:30:25+08:00</published><updated>2020-07-19T12:30:25+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Problems%2Fleetcode-5466" /><category term="Problems" /><content type="html">&lt;p&gt;子串的要求是不相交，且若一个子字符串包含字符 &lt;code&gt;c&lt;/code&gt; ，那么 &lt;code&gt;s&lt;/code&gt; 中所有 &lt;code&gt;c&lt;/code&gt; 字符都应该在这个子字符串中。&lt;/p&gt;
&lt;p&gt;先找出满足第二个条件的所有子串，由于串仅由小写字母组成，按照 &lt;code&gt;s&lt;/code&gt; 中所有 &lt;code&gt;c&lt;/code&gt; 字符都应该在这个子字符串中这一要求，最多有 26 个子串。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;预处理出每种字符的第一次出现和最后一次出现&lt;/li&gt;
&lt;li&gt;迭代更新每种字符相关的子串区间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;问题转化为选择尽量多的不相交子串，且总长度最短。&lt;/p&gt;
&lt;p&gt;类似含价值的线段最大价值覆盖问题，使用动态规划解决。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;按线段右端点升序排序&lt;/li&gt;
&lt;li&gt;设 &lt;code&gt;j&lt;/code&gt; 是在 &lt;code&gt;i&lt;/code&gt; 前的与 &lt;code&gt;i&lt;/code&gt; 不相交的子串，&lt;span class="math"&gt;\(d_i\)&lt;/span&gt; 为 前 &lt;code&gt;i&lt;/code&gt; 个子串，且包含子串 &lt;code&gt;i&lt;/code&gt; 的最大价值和，&lt;span class="math"&gt;\(v_i\)&lt;/span&gt; 为子串 &lt;code&gt;i&lt;/code&gt; 的价值。则转移方程为&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="math"&gt;
\[
d_i = \max \{d_j + v_i\}
\]&lt;/div&gt;
&lt;p&gt;结果即为 &lt;span class="math"&gt;\(d\)&lt;/span&gt; 中的最大值。&lt;/p&gt;
&lt;p&gt;本题中价值包含两方面：数量最多，总长度最短，可以如下取价值函数：&lt;/p&gt;
&lt;div class="math"&gt;
\[
v_i = - \text{len}_i + 10\times\text{len}_S
\]&lt;/div&gt;
&lt;p&gt;其中 &lt;span class="math"&gt;\(\text{len}_S\)&lt;/span&gt; 是原串总长度。&lt;/p&gt;
&lt;p&gt;输出具体方案，维护最优转移中的上一个子串即可。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cpp"&gt;struct seg
{
    int s, t, v;
};
bool cmp(seg a, seg b)
{
    return a.t &amp;lt; b.t;
}

class Solution
{
public:
    vector&amp;lt;string&amp;gt; maxNumOfSubstrings(string s)
    {
        vector&amp;lt;seg&amp;gt; segs;
        vector&amp;lt;int&amp;gt; ans, mx;
        int l = s.size();
        int first[26], last[26];
        for (int i = 0; i &amp;lt; 26; i++)
        {
            first[i] = l + 1;
            last[i] = -1;
        }
        for (int i = 0; i &amp;lt; l; i++)
        {
            int ch = s[i] - 'a';
            first[ch] = min(first[ch], i);
            last[ch] = max(last[ch], i);
        }
        for (int i = 0; i &amp;lt; 26; i++)
        {
            if (last[i] == -1)
                continue;
            while (true)
            {
                int tf = first[i], tl = last[i];
                for (int j = tf; j &amp;lt;= tl; j++)
                {
                    int ch = s[j] - 'a';
                    first[i] = min(first[ch], first[i]);
                    last[i] = max(last[ch], last[i]);
                }
                if (first[i] == tf &amp;amp;&amp;amp; last[i] == tl)
                    break;
            }
        }
        for (int i = 0; i &amp;lt; 26; i++)
        {
            if (last[i] == -1)
                continue;
            segs.push_back((seg){first[i], last[i], 10000000 - (last[i] - first[i] + 1)});
            mx.push_back(0);
            ans.push_back(-1);
        }
        sort(segs.begin(), segs.end(), cmp);
        mx[0] = segs[0].v;
        for (int i = 1; i &amp;lt; segs.size(); i++)
        {
            printf(&amp;quot;%d %d\n&amp;quot;, segs[i].s, segs[i].t);
            mx[i] = segs[i].v;
            ans[i] = -1;
            for (int j = i - 1; j &amp;gt;= 0; j--)
            {
                if (segs[j].t &amp;lt; segs[i].s)
                {
                    if ((segs[i].v + mx[j]) &amp;gt; mx[i])
                    {
                        mx[i] = segs[i].v + mx[j];
                        ans[i] = j;
                    }
                }
            }
        }
        int val = -1, pos = -1;
        for (int i = 0; i &amp;lt; segs.size(); i++)
        {
            if (mx[i] &amp;gt; val)
            {
                val = mx[i];
                pos = i;
            }
        }
        vector&amp;lt;string&amp;gt; result;
        for (int i = pos; i != -1; i = ans[i])
        {
            seg &amp;amp;g = segs[i];
            result.push_back(s.substr(g.s, g.t - g.s + 1));
        }
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><id>Problems/leetcode-3</id><title type="text">LeetCode-3 无重复字符的最长子串</title><summary type="text">无重复字符的子串，维护每种字符的上次出现位置 &lt;span class="math"&gt;\(p_{s_i}\)&lt;/span&gt;，从左往右依次扫描，维护当前可行子串的起点 &lt;span class="math"</summary><published>2020-07-13T20:30:40+08:00</published><updated>2020-07-13T20:30:40+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Problems%2Fleetcode-3" /><category term="Problems" /><content type="html">&lt;p&gt;无重复字符的子串，维护每种字符的上次出现位置 &lt;span class="math"&gt;\(p_{s_i}\)&lt;/span&gt;，从左往右依次扫描，维护当前可行子串的起点 &lt;span class="math"&gt;\(b\)&lt;/span&gt;。对每个字符 &lt;span class="math"&gt;\(s_i\)&lt;/span&gt;，使用 &lt;span class="math"&gt;\(p_{s_i}\)&lt;/span&gt; 更新起点 &lt;span class="math"&gt;\(b\)&lt;/span&gt;，子串长度即为 &lt;span class="math"&gt;\(i-b+1\)&lt;/span&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
    def lengthOfLongestSubstring(self, s: str) -&amp;gt; int:
        bg = {}
        i, ans = 0, 0
        for j in range(len(s)):
            if s[j] in bg:
                i = max(i, bg[s[j]]+1)
            ans = max(ans, j-i+1)
            bg[s[j]]=j
        return ans
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><id>Problems/leetcode-2</id><title type="text">LeetCode-2 两数相加</title><summary type="text">由于数位是逆序存储，从低位到高位依次遍历相加即可。注意几个边界情况的判断。
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: </summary><published>2020-07-13T20:29:38+08:00</published><updated>2020-07-13T20:29:38+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Problems%2Fleetcode-2" /><category term="Problems" /><content type="html">&lt;p&gt;由于数位是逆序存储，从低位到高位依次遍历相加即可。注意几个边界情况的判断。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -&amp;gt; ListNode:
        res = None
        cur = res
        rem = 0
        while l1 or l2:
            val = (l1.val if l1 else 0) + (l2.val if l2 else 0) + rem
            rem = val // 10
            if cur == None:
                res = ListNode(val % 10)
                cur = res
            else:
                cur.next = ListNode(val % 10)
                cur = cur.next
            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None
        if res == None:
            return ListNode(0)
        if rem != 0:
            cur.next = ListNode(rem)
        return res
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><id>Problems/leetcode-1</id><title type="text">LeetCode-1 两数之和</title><summary type="text">使用哈希表维护每个数到下标的映射，遍历每个元素 &lt;span class="math"&gt;\(x\)&lt;/span&gt;，查表得到 &lt;span class="math"&gt;\(S-x\)&lt;/span&gt; 的下标，得</summary><published>2020-07-13T17:30:22+08:00</published><updated>2020-07-13T17:30:22+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Problems%2Fleetcode-1" /><category term="Problems" /><content type="html">&lt;p&gt;使用哈希表维护每个数到下标的映射，遍历每个元素 &lt;span class="math"&gt;\(x\)&lt;/span&gt;，查表得到 &lt;span class="math"&gt;\(S-x\)&lt;/span&gt; 的下标，得到结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-rust"&gt;use std::collections::HashMap;

impl Solution {
    pub fn two_sum(nums: Vec&amp;lt;i32&amp;gt;, target: i32) -&amp;gt; Vec&amp;lt;i32&amp;gt; {
        let mut map = HashMap::new();
        for (i, v) in nums.into_iter().enumerate() {
            let ex = target - v;
            if ex != v {
                if let Some(&amp;amp;oi) = map.get(&amp;amp;ex) {
                    return vec![oi as i32, i as i32];
                }
            }
            match map.insert(v, i) {
                Some(oi) =&amp;gt; {
                    if ex == v {
                        return vec![oi as i32, i as i32];
                    }
                },
                None =&amp;gt; (),
            }
        }
        panic!();
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><id>Problems/leetcode-5465</id><title type="text">LeetCode-5465 子树中标签相同的节点数</title><summary type="text">注意到结点标签是单小写字母，所以建树后，，使用 DFS 遍历一遍树即可得到以某种小写字母为标签结点的统计结果，遍历 26 遍即可得到全部结果。
vectorint g[100005];
int _co</summary><published>2020-07-19T12:30:23+08:00</published><updated>2020-07-19T12:30:23+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Problems%2Fleetcode-5465" /><category term="Problems" /><content type="html">&lt;p&gt;注意到结点标签是单小写字母，所以建树后，，使用 DFS 遍历一遍树即可得到以某种小写字母为标签结点的统计结果，遍历 26 遍即可得到全部结果。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-cpp"&gt;vector&amp;lt;int&amp;gt; g[100005];
int _count[26][100005];
int ch = 0;
string *l;
int *cur = NULL;
void dfs(int u, int pa)
{
    cur[u] = 0;
    if (l-&amp;gt;at(u) - 'a' == ch)
    {
        cur[u]++;
    }
    for (int v : g[u])
    {
        if (v == pa)
            continue;
        dfs(v, u);
        cur[u] += cur[v];
    }
}

class Solution
{
public:
    vector&amp;lt;int&amp;gt; countSubTrees(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;edges, string labels)
    {
        for (int i = 0; i &amp;lt; n; i++)
            g[i].clear();
        for (vector&amp;lt;int&amp;gt; &amp;amp;e : edges)
        {
            g[e[0]].push_back(e[1]);
            g[e[1]].push_back(e[0]);
        }
        l = &amp;amp;labels;
        for (ch = 0; ch &amp;lt; 26; ch++)
        {
            cur = _count[ch];
            dfs(0, -1);
        }
        vector&amp;lt;int&amp;gt; result;
        for (int i = 0; i &amp;lt; n; i++)
        {
            result.push_back(_count[labels.at(i) - 'a'][i]);
        }
        return result;
    }
};
&lt;/code&gt;&lt;/pre&gt;
</content></entry><entry><id>Development/AcBlog-staticgen</id><title type="text">AcBlog 静态博客生成器使用说明</title><summary type="text">AcBlog 是一个还在开发中的开源博客系统，支持纯静态部署。
AcBlog 前端使用 WebAssembly 实现，支持 SPA，纯静态部署，后端支持静态和动态部署。以下是静态生成器生成的网站示例。</summary><published>2020-07-15T08:23:46+08:00</published><updated>2020-07-15T08:23:46+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Development%2FAcBlog-staticgen" /><category term="Development" /><content type="html">&lt;p&gt;&lt;a href="https://github.com/acblog/acblog"&gt;AcBlog&lt;/a&gt; 是一个还在开发中的开源博客系统，支持纯静态部署。&lt;/p&gt;
&lt;p&gt;AcBlog 前端使用 WebAssembly 实现，支持 SPA，纯静态部署，后端支持静态和动态部署。以下是静态生成器生成的网站示例。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://acblog.github.io/"&gt;AcBlog GitHub Pages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://acblog.gitee.io/"&gt;AcBlog Gitee Pages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section"&gt;创建存储库&lt;/h1&gt;
&lt;p&gt;对于纯静态部署的博客，参照&lt;a href="https://github.com/acblog/acblog.github.io"&gt;项目主页&lt;/a&gt;的文件结构建立存储库：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;app&lt;/code&gt; 目录下的内容将被直接复制到网站根目录&lt;/li&gt;
&lt;li&gt;&lt;code&gt;posts&lt;/code&gt; 目录下的内容为所有的文章（以 &lt;code&gt;.md&lt;/code&gt; 为后缀），生成器将读取并用于生成静态后端&lt;/li&gt;
&lt;li&gt;&lt;code&gt;assets&lt;/code&gt; 目录下的内容将被直接复制到生成器输出目录，可用于存储文章中使用的图片等文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;acblog.json&lt;/code&gt; 包含了提供给生成器的相关配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blog.json&lt;/code&gt; 包含了博客的相关信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.github/workflows/deploy.yml&lt;/code&gt; 脚本用于自动构建并推送 GitHub Pages&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-1"&gt;编写说明&lt;/h1&gt;
&lt;h2 id="acblog.json"&gt;acblog.json 配置文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;acblog&amp;quot;: {
    &amp;quot;Properties&amp;quot;: {
      &amp;quot;Raw&amp;quot;: {
        &amp;quot;remote.origin.generator.baseAddress&amp;quot;: &amp;quot;博客网址&amp;quot;,
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一般情况下，只需要填写博客网址，以供站点地图和 ATOM feed (RSS) 的生成使用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生成的站点地图默认位于 &lt;code&gt;博客网址/data/Site/sitemap.xml&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;生成的 ATOM feed 默认位于 &lt;code&gt;博客网址/data/Site/atom.xml&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="blog.json"&gt;blog.json&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
   &amp;quot;Name&amp;quot;: &amp;quot;Blog name&amp;quot;,
   &amp;quot;Description&amp;quot;: &amp;quot;Blog description&amp;quot;,
   &amp;quot;StartYear&amp;quot;: 2020,
   &amp;quot;Onwer&amp;quot;: &amp;quot;onwer&amp;quot;,
    // 主页背景图地址，将图片放到 app 目录下，在这里填写文件名即可
   &amp;quot;Cover&amp;quot;: &amp;quot;cover.jpg&amp;quot;,
   &amp;quot;Properties&amp;quot;: {
      &amp;quot;Raw&amp;quot;: {}
   }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此文件提供了博客的描述信息，被用于网站的信息展示。&lt;/p&gt;
&lt;h2 id="section-2"&gt;文章结构&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-markdown"&gt;---
id: 文章id(生成网址)
author: ''
title: '标题'
creationTime: 2020/1/1 12:00:00 +08:00
modificationTime: 2020/1/1 12:00:00 +08:00
category: [一级分类, 二级分类]
keywords: [关键字]
type: 类型(article,slides,note)
password: 密码
---

Content (Markdown)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如不指定分类，将使用文件的目录结构自动生成分类：&lt;code&gt;/posts/A/B/article.md&lt;/code&gt; 分类为 &lt;code&gt;[A, B]&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="section-3"&gt;自动构建&lt;/h2&gt;
&lt;p&gt;AcBlog 实现了静态前端和静态后端自动生成的 GitHub Actions，通过它们可以很容易地进行自动构建。&lt;/p&gt;
&lt;p&gt;文件路径 &lt;code&gt;.github/workflows/deploy.yml&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yml"&gt;name: Deploy
on:
  push:
jobs:
  update:
    runs-on: ubuntu-latest
    continue-on-error: false
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          persist-credentials: false
      - # 静态前端生成器
        name: Generate Frontend
        uses: acblog/wasm-ghpages-generate-action@master
      - # 静态后端生成器
        name: Generate Backend
        uses: acblog/static-backend-generate-action@master
        with:
          # 生成器输出目录，对应网站根目录下的 /data 目录
          dist: &amp;quot;./dist/data&amp;quot;
      - # 如果使用了 assets 目录，则可以加上这一条
        # 将 assets 提升到项目根目录处，简化链接编写
        name: Copy out assets
        run: cp -r ./dist/data/assets ./dist/assets
      - name: Deploy
        uses: JamesIves/github-pages-deploy-action@releases/v3
        with:
          # GitHub Token 用于 push 到仓库
          ACCESS_TOKEN: ${{ secrets.PUSH_TOKEN }}
          BRANCH: master
          FOLDER: dist
          CLEAN: true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于项目前端依赖 WebAssembly，需手动在 GitHub Pages 分支的根目录下添加 &lt;code&gt;.nojekyll&lt;/code&gt; 文件（内容为空即可）以禁用 GitHub Pages 的 Jekyll 自动构建。&lt;/p&gt;
</content></entry><entry><id>Development/ImagingS-dev</id><title type="text">ImagingS 开发笔记</title><summary type="text">Project Source
Demo Video
来源
最初的想法来自 计算机图形学的课程项目作业，其要求基于 Python + Qt 实现一个支持简单图元绘制的 GUI+CLI 程序。
之前一般仅</summary><published>2020-07-14T17:30:22+08:00</published><updated>2020-07-14T17:30:22+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Development%2FImagingS-dev" /><category term="Development" /><content type="html">&lt;p&gt;&lt;img src="https://repository-images.githubusercontent.com/226446069/77831900-b856-11ea-95ef-6fd6c38a9edc" alt="" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/StardustDL/ImagingS"&gt;Project Source&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.bilibili.com/video/BV1Q54y1i7Lg/"&gt;Demo Video&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://www.bilibili.com/video/BV1Q54y1i7Lg/" alt="" /&gt;&lt;/p&gt;
&lt;h1 id="section"&gt;来源&lt;/h1&gt;
&lt;p&gt;最初的想法来自 &lt;a href="https://git.nju.edu.cn/songyc/cg2020a"&gt;计算机图形学的课程项目作业&lt;/a&gt;，其要求基于 Python + Qt 实现一个支持简单图元绘制的 GUI+CLI 程序。&lt;/p&gt;
&lt;p&gt;之前一般仅使用 Python 写一些简单的小型项目。曾写过一个&lt;a href="https://github.com/eXceediDeaL/edl-coderunner"&gt;较大项目&lt;/a&gt;，但即使使用了类型标注，也很快随着项目复杂度的提升，遇到了维护瓶颈，大大影响开发效率，遂中断了开发。&lt;/p&gt;
&lt;p&gt;这次是第一次使用 Python 开发图形用户界面的软件，也是第一次使用 Qt，考虑到这个项目的需求较为明确并且有足够的扩展可能，决定将此项目作为一个 Python 较大单人项目的练手，并规避以前 Python 项目遇到的一些问题。&lt;/p&gt;
&lt;h1 id="idea"&gt;Idea&lt;/h1&gt;
&lt;p&gt;根据课程项目的模板代码，发现此项目非常适合 OOP 模式设计。结合以前的 &lt;a href="https://github.com/dotnet/wpf"&gt;WPF&lt;/a&gt; 学习经历，决定依照 WPF 的设计思路，试图在 ImagingS 中复刻 WPF 的呈现模型。&lt;/p&gt;
&lt;p&gt;&lt;img src="/assets/posts/ImagingS-dev/design.png" alt="" /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;图元 Geometry 对象描述图元及其绘制算法&lt;/li&gt;
&lt;li&gt;绘图 Drawing 将各种图元绘制到 DrawingContext 上&lt;/li&gt;
&lt;li&gt;绘图上下文 DrawingContext 提供具体绘图的抽象，统一 GUI 绘图和图片文件绘图。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通过这三个层次，将呈现系统的两部分：定义与呈现分离。&lt;/p&gt;
&lt;h2 id="section-1"&gt;设计&lt;/h2&gt;
&lt;p&gt;核心的 API 集中在以下几个类中，其中与绘制抽象相关的大部分类均能在 WPF 绘制模型中找到对应。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;图元类：各种图元的基类，定义了绘制算法（strokePoints）和变换。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Geometry(PropertySerializable, ABC):
    def __init__(self) -&amp;gt; None: pass

    def transform(self) -&amp;gt; Optional[Transform]: pass

    def strokePoints(self, pen: Pen) -&amp;gt; Iterable[Point]: pass

    def fillPoints(self) -&amp;gt; Iterable[Point]: pass

    def inStroke(self, pen: Pen, point: Point) -&amp;gt; bool: pass

    def inFill(self, point: Point) -&amp;gt; bool: pass

    def transformed(self) -&amp;gt; Geometry: pass

    def bounds(self) -&amp;gt; Rect: pass
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="2"&gt;
&lt;li&gt;绘制类：所有可绘制元素的基类，定义了绘制函数（render）。对于图元对象，实现了 GeometryDrawing 来实际完成图元的绘制任务。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Drawing(PropertySerializable, IdObject, ABC):
    def __init__(self) -&amp;gt; None: pass

    @abstractmethod
    def render(self, context: RenderContext) -&amp;gt; None: pass

    @property
    @abstractmethod
    def bounds(self) -&amp;gt; Rect: pass
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="3"&gt;
&lt;li&gt;绘图上下文类：对实际绘制的目标的抽象&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class RenderContext(ABC):
    @abstractmethod
    def _point(self, position: Point, color: Color) -&amp;gt; None: pass

    @abstractmethod
    def bounds(self) -&amp;gt; Rect: pass

    def point(self, position: Point, color: Color) -&amp;gt; None: pass

    def points(self, positions: Iterable[Point], brush: Brush)
     -&amp;gt; None: pass
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="4"&gt;
&lt;li&gt;变换类：所有变换的基类，定义了如何将一个点变换到另一个点&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Transform(PropertySerializable, IdObject, ABC):
    def __init__(self) -&amp;gt; None: pass

    @abstractmethod
    def transform(self, origin: Point) -&amp;gt; Point: pass
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="5"&gt;
&lt;li&gt;文档类：定义了当前文档所包含的画刷，图元，画布大小等信息，实现了序列化操作&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Document(PropertySerializable, IdObject):
    def __init__(self) -&amp;gt; None: pass

    @property
    def brushes(self) -&amp;gt; IdObjectList[Brush]: pass

    @property
    def drawings(self) -&amp;gt; DrawingGroup: pass

    @property
    def size(self) -&amp;gt; Size: pass

    def save(self, file, format: DocumentFormat = DocumentFormat.ISD)
     -&amp;gt; None: pass

    @staticmethod
    def load(file, format: DocumentFormat = DocumentFormat.ISD)
     -&amp;gt; Document: pass
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="6"&gt;
&lt;li&gt;画布类：将抽象绘制对象包装成 Qt 中的绘制对象&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Canvas(QGraphicsView): pass

class DrawingItem(QGraphicsItem):
    def __init__(self, drawing: Drawing, 
        size: QSizeF, parent: Optional[QGraphicsItem] = None): pass
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="7"&gt;
&lt;li&gt;交互类：定义了 GUI 上与图元交互的所有操作，提供给画布一个统一的接口来处理用户交互&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-python"&gt;class Interactivity(QObject):
    started = pyqtSignal(QObject)
    ended = pyqtSignal(QObject)
    updated = pyqtSignal(QObject)

    def __init__(self) -&amp;gt; None: pass

    def start(self) -&amp;gt; None: pass

    def end(self, success: bool) -&amp;gt; None: pass

    def update(self) -&amp;gt; None: pass

    @property
    def viewItem(self) -&amp;gt; Optional[QGraphicsItem]: pass

    @property
    def state(self) -&amp;gt; InteractivityState: pass

    def onMousePress(self, point: QPointF) -&amp;gt; None: pass

    def onMouseMove(self, point: QPointF) -&amp;gt; None: pass

    def onMouseRelease(self, point: QPointF) -&amp;gt; None: pass

    def onMouseDoubleClick(self, point: QPointF) -&amp;gt; None: pass

    def onKeyPress(self, key: QKeyEvent) -&amp;gt; None: pass

    def onKeyRelease(self, key: QKeyEvent) -&amp;gt; None: pass
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-2"&gt;实现&lt;/h1&gt;
&lt;ul class="contains-task-list"&gt;
&lt;li class="task-list-item"&gt;&lt;input disabled="disabled" type="checkbox" /&gt; To be done&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="section-3"&gt;总结&lt;/h1&gt;
&lt;p&gt;这个项目借鉴了 WPF 呈现模型的设计，一个成熟的模型的确是富有扩展性和较易维护的。Python + Qt 的组合开发效率也是很高的，但是运行效率有一定损失。&lt;/p&gt;
&lt;p&gt;项目目前的主要不足，一是图形学相关算法实现较少；二是部分类的 API 设计不够准确，这部分可能来源于 Qt 绘图模型和 WPF 依赖的 DirectX 两者的不一致，复刻的过程中部分设计需要适配 Qt ，造成一定妥协（例如 PyQt 的绘制效率低下，导致部分功能不容易在此模型下高效实现）。&lt;/p&gt;
</content></entry><entry><id>Problems/Contests/linglong-acm-round23</id><title type="text">“玲珑杯” ACM比赛 Round 23</title><summary type="text">生是脂肪的人
给定一个整数 &lt;span class="math"&gt;\(n\)&lt;/span&gt; ，输出 $10^n/7$ 的个位数。其中 &lt;span class="math"&gt;\(|n| \leq 10^</summary><published>2018-08-08T16:06:25+08:00</published><updated>2018-08-08T16:06:25+08:00</updated><author><name>StardustDL</name><uri>https://stardustdl.gitee.io</uri></author><link rel="alternate" href="https://stardustdl.gitee.io/posts/Problems%2FContests%2Flinglong-acm-round23" /><category term="Problems/Contests" /><content type="html">&lt;h1 id="section"&gt;生是脂肪的人&lt;/h1&gt;
&lt;p&gt;给定一个整数 &lt;span class="math"&gt;\(n\)&lt;/span&gt; ，输出 $10^n/7$ 的个位数。其中 &lt;span class="math"&gt;\(|n| \leq 10^{18}\)&lt;/span&gt;&lt;/p&gt;
&lt;h2 id="section-1"&gt;分析&lt;/h2&gt;
&lt;p&gt;打表规律： $1,4,2,8,5,7$ 循环&lt;/p&gt;
&lt;h2 id="section-2"&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-c++"&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
const int a[] = {1, 4, 2, 8, 5, 7};
typedef long long LL;
int main()
{
    int T;LL n;
    cin &amp;gt;&amp;gt; T;
    while (T--)
    {
        cin &amp;gt;&amp;gt; n;
        if (n &amp;lt; 1)
        {
            cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; endl;
            continue;
        }
        n -= 1;
        cout &amp;lt;&amp;lt; a[n % 6] &amp;lt;&amp;lt; endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-3"&gt;死是脂肪的鬼&lt;/h1&gt;
&lt;p&gt;给定一个99的数独，判断该数独是否合法。如果合法输出Yes,否则输出No。数独当且仅当每行每列以及9个33的小方格都是1〜9的9个数才合法。&lt;/p&gt;
&lt;h2 id="section-4"&gt;分析&lt;/h2&gt;
&lt;p&gt;模拟数独判断。&lt;/p&gt;
&lt;h2 id="section-5"&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-c++"&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
int T;
int b[20][20];
bool check(){
    for(int i=1;i&amp;lt;=9;i++){
        int s1=0,s2=0;
        for(int j=1;j&amp;lt;=9;j++)s1+=b[i][j],s2+=b[j][i];
        if(s1!=45 || s2!=45){
            return false;
        }
    }
    for(int i=1;i&amp;lt;=9;i+=3)for(int j=1;j&amp;lt;=9;j+=3){
        int s=0;
        for(int k=0;k&amp;lt;3;k++)for(int l=0;l&amp;lt;3;l++)s+=b[i+k][j+l];
        if(s!=45)return false;
    }
    return true;
}
int cnt[13];
int main(){
    cin&amp;gt;&amp;gt;T;
    while(T--){
        for(int i=1;i&amp;lt;=9;i++)cnt[i]=0;
        for(int i=1;i&amp;lt;=9;i++){
            for(int j=1;j&amp;lt;=9;j++){
                cin&amp;gt;&amp;gt;b[i][j];
                cnt[b[i][j]]++;
            }
        }
        bool flg=true;
        for(int i=1;i&amp;lt;=9;i++)if(cnt[i]!=9){flg=false;break;}
        if(flg)flg&amp;amp;=check();
        puts(flg?&amp;quot;Yes&amp;quot;:&amp;quot;No&amp;quot;);
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-6"&gt;你居然不吃巧克力&lt;/h1&gt;
&lt;p&gt;给定一个正整数n，现在有n个石头，每个单独成一堆。现在可以每次合并两堆石头，产生的能量为两堆石头个数的min。你现在要将所有的石头合并成一堆，并且获得的能量最大。输出这个最大值。$1\leq n \leq 10^7$&lt;/p&gt;
&lt;h2 id="section-7"&gt;分析&lt;/h2&gt;
&lt;p&gt;最后一次尽量平均即可。复杂度 &lt;span class="math"&gt;\(O(\log_2 n)\)&lt;/span&gt;&lt;/p&gt;
&lt;div class="math"&gt;
\[
S(n)=\begin{cases}
0, &amp;amp; \text{if $ n&amp;lt;=1 $}\\
\lfloor n/2 \rfloor + 2S(\lfloor n/2 \rfloor), &amp;amp; \text{n is even}\\
\lfloor n/2 \rfloor + S(\lfloor n/2 \rfloor)+S(n-\lfloor n/2 \rfloor), &amp;amp; \text{n is odd}\\
\end{cases}
\]&lt;/div&gt;
&lt;h2 id="section-8"&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-c++"&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
int solve(int n){
    if(n&amp;lt;=1)return 0;
    if(n&amp;amp;1){
        return (n&amp;gt;&amp;gt;1)+solve(n&amp;gt;&amp;gt;1)+solve(n-(n&amp;gt;&amp;gt;1));
    }
    else{
        return (n&amp;gt;&amp;gt;1)+(solve(n&amp;gt;&amp;gt;1)&amp;lt;&amp;lt;1);
    }
}
int main(){
    int T;cin&amp;gt;&amp;gt;T;
    while(T--){
        int n;cin&amp;gt;&amp;gt;n;
        cout&amp;lt;&amp;lt;solve(n)&amp;lt;&amp;lt;endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="section-9"&gt;别不好意思，都是脂肪的人&lt;/h1&gt;
&lt;p&gt;求
&lt;span class="math"&gt;\(\sum_{x_1=0}^{+\infty} \sum_{x_2=0}^{+\infty} \dots \sum_{x_n=0}^{+\infty} \frac{x_1+x_2+\dots+x_n}{k^{x_1+x_2+\dots+x_n}}\)&lt;/span&gt;
数据保证答案是一个有理数，求出模 $10^9+7$ 意义下的值。&lt;/p&gt;
&lt;h2 id="section-10"&gt;分析&lt;/h2&gt;
&lt;p&gt;首先转化一下，计算 每一项的出现次数，即 &lt;span class="math"&gt;\(x_1+x_2+\dots+x_n=t\)&lt;/span&gt; 的整数解的数量（可为 $0$），这一步是经典组合计数问题，答案为 &lt;span class="math"&gt;\(\binom{n-1+t}{n-1}\)&lt;/span&gt;。然后就有&lt;/p&gt;
&lt;div class="math"&gt;
\[
\text{原式}=\sum_{t=0}^{+ \infty} \binom{n-1+t}{n-1}\frac{t}{k^t}
\]&lt;/div&gt;
&lt;p&gt;关于二项式系数有以下恒等式（&lt;span class="math"&gt;\(n \geq 0\)&lt;/span&gt;）：&lt;/p&gt;
&lt;div class="math"&gt;
\[
\frac{1}{(1-z)^{n+1}}=\sum_{k=0}^{+\infty} \binom{n+k}{n} z^k
\]&lt;/div&gt;
&lt;p&gt;注意到此题中求和项中多了一个 &lt;span class="math"&gt;\(t\)&lt;/span&gt;，那么对上述恒等式左右求导，由幂级数性质有&lt;/p&gt;
&lt;div class="math"&gt;
\[
(n+1)(1-z)^{-(n+2)}=\sum_{k=0}^{+\infty} \binom{n+k}{n} kz^{k-1}
\]&lt;/div&gt;
&lt;p&gt;左右再乘上 &lt;span class="math"&gt;\(z\)&lt;/span&gt;，就和我们要求的式子形式相同了。&lt;/p&gt;
&lt;div class="math"&gt;
\[
z(n+1)(1-z)^{-(n+2)}=\sum_{k=0}^{+\infty} \binom{n+k}{n} kz^k
\]&lt;/div&gt;
&lt;p&gt;故原式等于 &lt;span class="math"&gt;\(zn(1-z)^{-(n+1)}\)&lt;/span&gt; ，其中 &lt;span class="math"&gt;\(z=1/k\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id="section-11"&gt;代码&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-c++"&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;cstdio&amp;gt;
#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;cstring&amp;gt;
#include &amp;lt;algorithm&amp;gt;
using namespace std;
typedef long long LL;
const LL MOD=1e9+7;
LL T,n,k;
LL qpow(LL a,LL n){
    LL ans=1;
    while(n){
        if(n&amp;amp;1)ans=ans*a%MOD;
        a=a*a%MOD;
        n&amp;gt;&amp;gt;=1;
    }
    return ans;
}
inline LL inv(LL x){
    return qpow(x,MOD-2);
}
int main(){
    cin&amp;gt;&amp;gt;T;
    while(T--){
        cin&amp;gt;&amp;gt;n&amp;gt;&amp;gt;k;
        LL z=inv(k);
        LL t=inv((MOD+1-z)%MOD);
        LL ans=z*n%MOD*qpow(t,n+1)%MOD;
        cout&amp;lt;&amp;lt;ans&amp;lt;&amp;lt;endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</content></entry></feed>
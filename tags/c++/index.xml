<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C++ on StardustDL's Blog</title><link>https://stardustdl.github.io/tags/c++/</link><description>Recent content in C++ on StardustDL's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 23 Jul 2020 13:23:31 +0800</lastBuildDate><atom:link href="https://stardustdl.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>C++ 模板实现编译期计算数列</title><link>https://stardustdl.github.io/posts/learning/cpp-template-seq/</link><pubDate>Thu, 23 Jul 2020 13:23:31 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/cpp-template-seq/</guid><description>虽然 C++ 模板最初被 Bjarne Stroustrup 称为参数化类型，但是实际上其工作方式更像一个受限制的高级版宏，”模板“这个名称更加合适。
这里使用 C++ 模板的非类型参数特性来实现一些数列的编译期计算。
阶乘数列 $$ F_i = \begin{cases} 1 &amp;amp; i = 0 \\ iF_{i-1} &amp;amp; i &amp;gt; 0 \end{cases} $$
template &amp;lt;int num&amp;gt; class Factorial { public: static const int value = num * Factorial&amp;lt;num - 1&amp;gt;::value; }; template &amp;lt;&amp;gt; class Factorial&amp;lt;0&amp;gt; { public: static const int value = 1; }; int main() { cout &amp;lt;&amp;lt; Factorial&amp;lt;10&amp;gt;::value &amp;lt;&amp;lt; endl; } 为什么这是编译期运算呢？可以从两个方面了解。
关闭编译器所有优化。
g++ -S fac.</description></item></channel></rss>
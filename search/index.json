[{"content":"泛型 泛型函数 fn largest\u0026lt;T: PartialOrd +Copy\u0026gt;(list: \u0026amp;[T])-\u0026gt; T{letmutlargest=list[0];for\u0026amp;iteminlist{ifitem\u0026gt;largest{largest=item;}}largest}泛型结构 struct Point\u0026lt;T\u0026gt;{x: T,y: T,}fn main(){letinteger=Point{x: 5,y: 10};letfloat=Point{x: 1.0,y: 4.0};}struct Point\u0026lt;T,U\u0026gt;{x: T,y: U,}fn main(){letboth_integer=Point{x: 5,y: 10};letboth_float=Point{x: 1.0,y: 4.0};letinteger_and_float=Point{x: 5,y: 4.0};}泛型枚举 enum Option\u0026lt;T\u0026gt;{Some(T),None,}enum Result\u0026lt;T,E\u0026gt;{Ok(T),Err(E),}泛型方法 struct Point\u0026lt;T\u0026gt;{x: T,y: T,}// 通用实现（对所有类型） impl\u0026lt;T\u0026gt;Point\u0026lt;T\u0026gt;{fn x(\u0026amp;self)-\u0026gt; \u0026amp;T{\u0026amp;self.x}}// 特定实现（对指定类型） implPoint\u0026lt;f32\u0026gt;{fn distance_from_origin(\u0026amp;self)-\u0026gt; f32 {(self.x.powi(2)+self.y.powi(2)).sqrt()}}fn main(){letp=Point{x: 5,y: 10};println!(\u0026#34;p.x = {}\u0026#34;,p.x());}泛型结合生存期 usestd::fmt::Display;fn longest_with_an_announcement\u0026lt;\u0026#39;a,T\u0026gt;(x: \u0026amp;\u0026#39;astr,y: \u0026amp;\u0026#39;astr,ann: T,)-\u0026gt; \u0026amp;\u0026#39;astrwhereT: Display,{println!(\u0026#34;Announcement! {}\u0026#34;,ann);ifx.len()\u0026gt;y.len(){x}else{y}}特征：定义共享行为 定义特征 pubtraitSummary{fn summarize(\u0026amp;self)-\u0026gt; String;}实现特征 pubstruct NewsArticle{pubheadline: String,publocation: String,pubauthor: String,pubcontent: String,}implSummaryforNewsArticle{fn summarize(\u0026amp;self)-\u0026gt; String {format!(\u0026#34;{}, by {} ({})\u0026#34;,self.headline,self.author,self.location)}}提供默认实现 pubtraitSummary{fn summarize_author(\u0026amp;self)-\u0026gt; String;fn summarize(\u0026amp;self)-\u0026gt; String {format!(\u0026#34;(Read more from {}...)\u0026#34;,self.summarize_author())}}implSummaryforTweet{fn summarize_author(\u0026amp;self)-\u0026gt; String {format!(\u0026#34;@{}\u0026#34;,self.username)}}implSummaryforNewsArticle{}// need an empty impl block for NewsArticle 使用特征作为参数 pubfn notify(item: \u0026amp;implSummary){println!(\u0026#34;Breaking news! {}\u0026#34;,item.summarize());}pubfn notify(item: \u0026amp;(implSummary+Display)){}使用特征作为返回值 fn returns_summarizable()-\u0026gt; implSummary{Tweet{username: String::from(\u0026#34;horse_ebooks\u0026#34;),content: String::from(\u0026#34;of course, as you probably already know, people\u0026#34;,),reply: false,retweet: false,}}使用特征限制泛型 pubfn notify\u0026lt;T: Summary\u0026gt;(item: \u0026amp;T){println!(\u0026#34;Breaking news! {}\u0026#34;,item.summarize());}pubfn notify\u0026lt;T: Summary+Display\u0026gt;(item: \u0026amp;T){}fn some_function\u0026lt;T,U\u0026gt;(t: \u0026amp;T,u: \u0026amp;U)-\u0026gt; i32 whereT: Display+Clone,U: Clone +Debug{}使用特征限制实现块 usestd::fmt::Display;struct Pair\u0026lt;T\u0026gt;{x: T,y: T,}impl\u0026lt;T\u0026gt;Pair\u0026lt;T\u0026gt;{fn new(x: T,y: T)-\u0026gt; Self{Self{x,y}}}impl\u0026lt;T: Display+PartialOrd\u0026gt;Pair\u0026lt;T\u0026gt;{fn cmp_display(\u0026amp;self){ifself.x\u0026gt;=self.y{println!(\u0026#34;The largest member is x = {}\u0026#34;,self.x);}else{println!(\u0026#34;The largest member is y = {}\u0026#34;,self.y);}}}impl\u0026lt;T: Display\u0026gt;ToStringforT{// --snip-- }","date":"2021-07-06T19:50:46+08:00","permalink":"https://stardustdl.github.io/posts/learning/rust-generic-types/","title":"Rust 泛型"},{"content":"变长列表 // 创建 letv: Vec\u0026lt;i32\u0026gt;=Vec::new();letv=vec![1,2,3];// 修改 letmutv=Vec::new();v.push(5);// 访问 letthird: \u0026amp;i32 =\u0026amp;v[2];println!(\u0026#34;The third element is {}\u0026#34;,third);matchv.get(2){Some(third)=\u0026gt;println!(\u0026#34;The third element is {}\u0026#34;,third),None=\u0026gt;println!(\u0026#34;There is no third element.\u0026#34;),}// 遍历 letv=vec![100,32,57];foriin\u0026amp;v{println!(\u0026#34;{}\u0026#34;,i);}letmutv=vec![100,32,57];foriin\u0026amp;mutv{*i+=50;}在有引用的情况下无法对列表进行修改。\nUTF-8 字符串 // 创建 letmuts=String::new();// 更新 letmuts=String::from(\u0026#34;foo\u0026#34;);s.push_str(\u0026#34;bar\u0026#34;);s.push(\u0026#39;l\u0026#39;);// 合并 lets1=String::from(\u0026#34;Hello, \u0026#34;);lets2=String::from(\u0026#34;world!\u0026#34;);lets3=s1+\u0026amp;s2;// note s1 has been moved here and can no longer be used // 格式化 lets1=String::from(\u0026#34;tic\u0026#34;);lets2=String::from(\u0026#34;tac\u0026#34;);lets3=String::from(\u0026#34;toe\u0026#34;);lets=format!(\u0026#34;{}-{}-{}\u0026#34;,s1,s2,s3);// do not take onwership 字符串内部对 Vec\u0026lt;u8\u0026gt; 进行包装。不支持直接索引。\n切片 lethello=\u0026#34;Здравствуйте\u0026#34;;// each of these characters was 2 bytes lets=\u0026amp;hello[0..4];// s == Зд lets=\u0026amp;hello[0..1];// panic at runtime in the same way as if an invalid index were accessed in a vector 遍历 forcin\u0026#34;नमस्ते\u0026#34;.chars(){println!(\u0026#34;{}\u0026#34;,c);}forbin\u0026#34;नमस्ते\u0026#34;.bytes(){println!(\u0026#34;{}\u0026#34;,b);}哈希表 对于不支持 Copy 特征的对象，哈希表将获取其所有权。\n// 创建 usestd::collections::HashMap;letmutscores=HashMap::new();// 修改 scores.insert(String::from(\u0026#34;Blue\u0026#34;),10);scores.insert(String::from(\u0026#34;Blue\u0026#34;),25);scores.insert(String::from(\u0026#34;Yellow\u0026#34;),50);scores.entry(String::from(\u0026#34;Yellow\u0026#34;)).or_insert(50);letteams=vec![String::from(\u0026#34;Blue\u0026#34;),String::from(\u0026#34;Yellow\u0026#34;)];letinitial_scores=vec![10,50];letmutscores: HashMap\u0026lt;_,_\u0026gt;=teams.into_iter().zip(initial_scores.into_iter()).collect();// 访问 letteam_name=String::from(\u0026#34;Blue\u0026#34;);letscore=scores.get(\u0026amp;team_name);// 遍历 for(key,value)in\u0026amp;scores{println!(\u0026#34;{}: {}\u0026#34;,key,value);}entry.or_insert 返回一个可变引用。\nlettext=\u0026#34;hello world wonderful world\u0026#34;;letmutmap=HashMap::new();forwordintext.split_whitespace(){letcount=map.entry(word).or_insert(0);*count+=1;}","date":"2021-07-06T17:50:46+08:00","permalink":"https://stardustdl.github.io/posts/learning/rust-collections/","title":"Rust 集合"},{"content":"包 Packages 一个 Cargo 特性支持构建，测试，和分享 Crates。包含了 Cargo.toml 来描述如何构建 Crates。包至少包含0或1个库Crate，可以包含任意多的二进制Crate，但至少要有一个Crate。\nsrc/ main.rs 二进制Crate的根（名称为包名） lib.rs 库Crate的根（名称为包名） bin/ 更多二进制Crate（其中的每个文件为一个Crate） 构建配置 # https://doc.rust-lang.org/cargo/reference/profiles.html [profile.dev] opt-level = 0 [profile.release] opt-level = 3 共享相同依赖开发多个包：Cargo Workspaces。\n文档注释 /// Adds one to the number given. /// /// # Examples /// /// ``` /// let arg = 5; /// let answer = my_crate::add_one(arg); /// /// assert_eq!(6, answer); /// ``` /// # Panics / Errors / Safety pubfn add_one(x: i32)-\u0026gt; i32 {x+1}使用 cargo doc --open 启动文档预览，使用 cargo test 进行文档测试。\n使用 //! 为当前文件添加注释。\n//! # My Crate //! //! `my_crate` is a collection of utilities to make performing certain //! calculations more convenient. /// Adds one to the number given. // --snip-- 发布 cargo login \u0026lt;API Key\u0026gt; cargo publish Cargo.toml：\n[package] name = \u0026#34;guessing_game\u0026#34; version = \u0026#34;0.1.0\u0026#34; authors = [\u0026#34;Your Name \u0026lt;you@example.com\u0026gt;\u0026#34;] edition = \u0026#34;2018\u0026#34; description = \u0026#34;A fun game where you guess what number the computer has chosen.\u0026#34; license = \u0026#34;MIT OR Apache-2.0\u0026#34; [dependencies] 撤销一个版本：cargo yank --vers 1.0.1。\nCrates 树结构的一系列模块，用于生成类库或可执行文件（二进制）。\nCrate 的根是一个由 Rust 编译器开始编译并作为根模块的源代码。\n模块 Modules 控制代码组织，作用域和可访问性（可被外部访问或私有）。\nmod front_of_house{mod hosting{fn add_to_waitlist(){}fn seat_at_table(){}}mod serving{fn take_order(){}fn serve_order(){}fn take_payment(){}}}crate └── front_of_house ├── hosting │ ├── add_to_waitlist │ └── seat_at_table └── serving ├── take_order ├── serve_order └── take_payment 公开项目 使用 pub 标记公开。\n公开函数和模块。\nmod front_of_house{pubmod hosting{pubfn add_to_waitlist(){}}}pubfn eat_at_restaurant(){// Absolute path crate::front_of_house::hosting::add_to_waitlist();// Relative path front_of_house::hosting::add_to_waitlist();}公开结构体及其字段。\nmod back_of_house{pubstruct Breakfast{pubtoast: String,seasonal_fruit: String,}implBreakfast{pubfn summer(toast: \u0026amp;str)-\u0026gt; Breakfast{Breakfast{toast: String::from(toast),seasonal_fruit: String::from(\u0026#34;peaches\u0026#34;),}}}}pubfn eat_at_restaurant(){// Order a breakfast in the summer with Rye toast letmutmeal=back_of_house::Breakfast::summer(\u0026#34;Rye\u0026#34;);// Change our mind about what bread we\u0026#39;d like meal.toast=String::from(\u0026#34;Wheat\u0026#34;);println!(\u0026#34;I\u0026#39;d like {} toast please\u0026#34;,meal.toast);// The next line won\u0026#39;t compile if we uncomment it; we\u0026#39;re not allowed // to see or modify the seasonal fruit that comes with the meal // meal.seasonal_fruit = String::from(\u0026#34;blueberries\u0026#34;); }公开枚举。\nmod back_of_house{pubenum Appetizer{Soup,Salad,}}pubfn eat_at_restaurant(){letorder1=back_of_house::Appetizer::Soup;letorder2=back_of_house::Appetizer::Salad;}导入项目 usestd::{cmp::Ordering,io};usestd::io::{self,Write};usestd::collections::*;mod front_of_house{pubmod hosting{pubfn add_to_waitlist(){}}}usecrate::front_of_house::hosting;pubfn eat_at_restaurant(){hosting::add_to_waitlist();hosting::add_to_waitlist();hosting::add_to_waitlist();}使用 as 关键字设置新名称。\nusestd::fmt::Result;usestd::io::ResultasIoResult;fn function1()-\u0026gt; Result {// --snip-- }fn function2()-\u0026gt; IoResult\u0026lt;()\u0026gt;{// --snip-- }使用 pub use 重新导出。\nmod front_of_house{pubmod hosting{pubfn add_to_waitlist(){}}}pubusecrate::front_of_house::hosting;pubfn eat_at_restaurant(){hosting::add_to_waitlist();hosting::add_to_waitlist();hosting::add_to_waitlist();}分割模块到多个文件 // lib.rs mod front_of_house;// Declaring the front_of_house module whose body will be in src/front_of_house.rs pubusecrate::front_of_house::hosting;pubfn eat_at_restaurant(){hosting::add_to_waitlist();hosting::add_to_waitlist();hosting::add_to_waitlist();}// src/front_of_house.rs pubmod hosting;// src/front_of_house/hosting.rs pubfn add_to_waitlist(){}路径 Paths 命名一个项目的方式。\n 绝对路径：从Crate根的名字开始或使用 crate 指代根。 相对路径：从当前模块的名字开始或使用 self, super 指代。  mod front_of_house{pubmod hosting{pubfn add_to_waitlist(){}}}pubfn eat_at_restaurant(){// Absolute path crate::front_of_house::hosting::add_to_waitlist();// Relative path front_of_house::hosting::add_to_waitlist();}","date":"2021-07-06T16:50:46+08:00","permalink":"https://stardustdl.github.io/posts/learning/rust-modules/","title":"Rust 模块与项目"},{"content":"规则  每个值都有一个称为其所有者的变量 同一时刻只能有一个所有者 当所有者离开作用域时，值被舍弃（调用 drop 函数）  变量与数据的交互 移动语义 Rust 从不自动进行变量的深层复制，而是使用移动语义。\nlets1=String::from(\u0026#34;abc\u0026#34;);lets2=s1;// s1 is invalid 克隆语义 使用 clone 函数实现明确的深层复制。\nlets1=String::from(\u0026#34;hello\u0026#34;);lets2=s1.clone();复制语义 诸如整数等类型数据，具有编译时已知的大小，并完全存储在栈上，能够快速复制，浅层复制与深层复制没有实际区别，不需要使用 clone 函数（实现 Copy 特征以标记这类数据）。\nletx=5;lety=x;引用 lets1: String =String::from(\u0026#34;hello\u0026#34;);letref_s1: \u0026amp;String =\u0026amp;s1;letmutmut_s1: String =String::from(\u0026#34;hello\u0026#34;);letref_s1: \u0026amp;mutString=\u0026amp;mutmut_s1;\u0026amp; 表示引用变量，不取得变量的所有权，默认以不可变方式进行引用，\u0026amp;mut 表示可变方式引用。 传入引用变量的函数，称为借用了这个变量。\n在同一作用域下，对同一个对象的引用，只允许以下组合方式：\n 一个或多个不可变引用 一个可变引用，没有不可变引用  切片 切片指对一个序列中的一段连续元素的引用，不取得变量的所有权。\nleta=[1,2,3,4,5];letslice=\u0026amp;a[1..3];assert_eq!(slice,\u0026amp;[2,3]);字符串切片 lets=String::from(\u0026#34;hello world\u0026#34;);lethello: \u0026amp;str =\u0026amp;s[0..5];letworld: \u0026amp;str =\u0026amp;s[6..11];letslice: \u0026amp;str =\u0026amp;s[..2];letslice: \u0026amp;str =\u0026amp;s[3..];letslice: \u0026amp;str =\u0026amp;s[..];字符串字面值的类型为字符串切片（\u0026amp;str）。\n生存期 借用检查器会检查生存期长短关系，来保证借用安全。\nfn main(){{letx=5;// ----------+-- \u0026#39;b // | letr=\u0026amp;x;// --+-- \u0026#39;a | // | | println!(\u0026#34;r: {}\u0026#34;,r);// | | // --+ | }// ----------+ }标记生存期 \u0026amp;i32// a reference \u0026amp;\u0026#39;ai32// a reference with an explicit lifetime \u0026amp;\u0026#39;amuti32// a mutable reference with an explicit lifetime 函数中的生存期 由于未标记生存期，以下代码无法编译：\nfn longest(x: \u0026amp;str,y: \u0026amp;str)-\u0026gt; \u0026amp;str {ifx.len()\u0026gt;y.len(){x}else{y}}报错如下。\n | 9 | fn longest(x: \u0026amp;str, y: \u0026amp;str) -\u0026gt; \u0026amp;str { | ---- ---- ^ expected named lifetime parameter | = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y` help: consider introducing a named lifetime parameter | 9 | fn longest\u0026lt;'a\u0026gt;(x: \u0026amp;'a str, y: \u0026amp;'a str) -\u0026gt; \u0026amp;'a str { | ^^^^ ^^^^^^^ ^^^^^^^ ^^^ 修正后的代码。\nfn longest\u0026lt;\u0026#39;a\u0026gt;(x: \u0026amp;\u0026#39;astr,y: \u0026amp;\u0026#39;astr)-\u0026gt; \u0026amp;\u0026#39;astr{ifx.len()\u0026gt;y.len(){x}else{y}}结构中的生存期 struct ImportantExcerpt\u0026lt;\u0026#39;a\u0026gt;{part: \u0026amp;\u0026#39;astr,}impl\u0026lt;\u0026#39;a\u0026gt;ImportantExcerpt\u0026lt;\u0026#39;a\u0026gt;{fn level(\u0026amp;self)-\u0026gt; i32 {3}}fn main(){letnovel=String::from(\u0026#34;Call me Ishmael. Some years ago...\u0026#34;);letfirst_sentence=novel.split(\u0026#39;.\u0026#39;).next().expect(\u0026#34;Could not find a \u0026#39;.\u0026#39;\u0026#34;);leti=ImportantExcerpt{part: first_sentence,};}生存期省略 不标记生存期，编译器根据三个规则进行分析。\n 每个引用参数赋予其自己独立的生存期。 如果只有一个生存期参数，则这个生存期赋予给返回值。 如果有多个生存期参数，但其中一个是 self 的引用（即方法），则 self 的生存期赋予给返回值。  静态生存期 永久生存。\nlets: \u0026amp;\u0026#39;staticstr=\u0026#34;I have a static lifetime.\u0026#34;;","date":"2021-07-06T11:50:46+08:00","permalink":"https://stardustdl.github.io/posts/learning/rust-onwership/","title":"Rust 所有权特性"},{"content":"安装 https://www.rust-lang.org/tools/install\n 安装管理器 rustup 编译器 rustc 构建系统与包管理器 cargo  常用命令  创建项目 cargo new {name} 可编译检查 cargo check 编译 cargo build (--release) 运行 cargo run 更新依赖包小版本 cargo upgrade （大版本需要手动修改）  变量 letimmutable_var: i32 =5;letmutmutable_var: i32 =5;constCONST: u32 =100_000;数值字面值\n 十进制 98_222 十六进制 0xff 八进制 0o77 二进制 0b1111_0000 字节 b'A'  类型  数值类型 i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize, f32, f64 布尔类型 bool 字符类型 char 四字节 元组类型 (T1, T2, ...) = (1, 2, 3) 数组类型 [i32; 5] = [1, 2, 3, 4, 5]  结构体 定义 struct User{username: String,email: String,sign_in_count: u64,active: bool,}struct Color(i32,i32,i32);struct Point(i32,i32,i32);实例化 letuser1=User{email: String::from(\u0026#34;someone@example.com\u0026#34;),username: String::from(\u0026#34;someusername123\u0026#34;),active: true,sign_in_count: 1,};成员修改 letmutuser1=User{email: String::from(\u0026#34;someone@example.com\u0026#34;),username: String::from(\u0026#34;someusername123\u0026#34;),active: true,sign_in_count: 1,};user1.email=String::from(\u0026#34;anotheremail@example.com\u0026#34;);基于现有结构更新 letuser2=User{email: String::from(\u0026#34;another@example.com\u0026#34;),username: String::from(\u0026#34;anotherusername567\u0026#34;),..user1};枚举 简单枚举 enum IpAddrKind{V4,V6,}letfour: IpAddrKind=IpAddrKind::V4;letsix: IpAddrKind=IpAddrKind::V6;数据枚举 enum IpAddr{V4(u8,u8,u8,u8),V6(String),}lethome=IpAddr::V4(127,0,0,1);letloopback=IpAddr::V6(String::from(\u0026#34;::1\u0026#34;));enum Message{Quit,Move{x: i32,y: i32 },Write(String),ChangeColor(i32,i32,i32),}控制流 // 分支 ifnumber%4==0{println!(\u0026#34;number is divisible by 4\u0026#34;);}elseifnumber%3==0{println!(\u0026#34;number is divisible by 3\u0026#34;);}else{println!(\u0026#34;number is not divisible by 4 or 3\u0026#34;);}letnumber=ifcondition{5}else{\u0026#34;six\u0026#34;};// 循环 loop{println!(\u0026#34;again!\u0026#34;);}letresult=loop{counter+=1;ifcounter==10{breakcounter*2;}};whilenumber!=0{println!(\u0026#34;{}!\u0026#34;,number);number-=1;}fornumberin(1..4).rev(){println!(\u0026#34;{}!\u0026#34;,number);}模式匹配 模式 模式有可反驳和不可反驳（对所有传入的值都满足模式）两种。\n// 字面值 letx=1;matchx{1=\u0026gt;println!(\u0026#34;one\u0026#34;),2=\u0026gt;println!(\u0026#34;two\u0026#34;),3=\u0026gt;println!(\u0026#34;three\u0026#34;),_=\u0026gt;println!(\u0026#34;anything\u0026#34;),}// 具名变量 letx=Some(5);matchx{Some(50)=\u0026gt;println!(\u0026#34;Got 50\u0026#34;),Some(y)=\u0026gt;println!(\u0026#34;Matched, y = {:?}\u0026#34;,y),_=\u0026gt;println!(\u0026#34;Default case, x = {:?}\u0026#34;,x),}// 多重匹配（或） letx=1;matchx{1|2=\u0026gt;println!(\u0026#34;one or two\u0026#34;),3=\u0026gt;println!(\u0026#34;three\u0026#34;),_=\u0026gt;println!(\u0026#34;anything\u0026#34;),}// 值区间匹配 letx=5;matchx{1..=5=\u0026gt;println!(\u0026#34;one through five\u0026#34;),// equals to 1 | 2 | 3 | 4 | 5 _=\u0026gt;println!(\u0026#34;something else\u0026#34;),}letx=\u0026#39;c\u0026#39;;matchx{\u0026#39;a\u0026#39;..=\u0026#39;j\u0026#39;=\u0026gt;println!(\u0026#34;early ASCII letter\u0026#34;),\u0026#39;k\u0026#39;..=\u0026#39;z\u0026#39;=\u0026gt;println!(\u0026#34;late ASCII letter\u0026#34;),_=\u0026gt;println!(\u0026#34;something else\u0026#34;),}// 解构 letp=Point{x: 0,y: 7};letPoint{x: a,y: b}=p;assert_eq!(0,a);assert_eq!(7,b);matchp{Point{x,y: 0}=\u0026gt;println!(\u0026#34;On the x axis at {}\u0026#34;,x),Point{x: 0,y}=\u0026gt;println!(\u0026#34;On the y axis at {}\u0026#34;,y),Point{x,y}=\u0026gt;println!(\u0026#34;On neither axis: ({}, {})\u0026#34;,x,y),}matchmsg{Message::Quit=\u0026gt;{println!(\u0026#34;The Quit variant has no data to destructure.\u0026#34;)}Message::Move{x,y}=\u0026gt;{println!(\u0026#34;Move in the x direction {} and in the y direction {}\u0026#34;,x,y);}Message::Write(text)=\u0026gt;println!(\u0026#34;Text message: {}\u0026#34;,text),Message::ChangeColor(r,g,b)=\u0026gt;println!(\u0026#34;Change the color to red {}, green {}, and blue {}\u0026#34;,r,g,b),}// 多层解构 enum Color{Rgb(i32,i32,i32),Hsv(i32,i32,i32),}enum Message{Quit,Move{x: i32,y: i32 },Write(String),ChangeColor(Color),}fn main(){letmsg=Message::ChangeColor(Color::Hsv(0,160,255));matchmsg{Message::ChangeColor(Color::Rgb(r,g,b))=\u0026gt;println!(\u0026#34;Change the color to red {}, green {}, and blue {}\u0026#34;,r,g,b),Message::ChangeColor(Color::Hsv(h,s,v))=\u0026gt;println!(\u0026#34;Change the color to hue {}, saturation {}, and value {}\u0026#34;,h,s,v),_=\u0026gt;(),}}let((feet,inches),Point{x,y})=((3,10),Point{x: 3,y: -10});// 多级模式 @ enum Message{Hello{id: i32 },}letmsg=Message::Hello{id: 5};matchmsg{Message::Hello{id: id_variable@3..=7,}=\u0026gt;println!(\u0026#34;Found an id in range: {}\u0026#34;,id_variable),Message::Hello{id: 10..=12}=\u0026gt;{println!(\u0026#34;Found an id in another range\u0026#34;)}Message::Hello{id}=\u0026gt;println!(\u0026#34;Found some other id: {}\u0026#34;,id),}// 忽略 fn foo(_: i32,y: i32){println!(\u0026#34;This code only uses the y parameter: {}\u0026#34;,y);}match(setting_value,new_setting_value){(Some(_),Some(_))=\u0026gt;{println!(\u0026#34;Can\u0026#39;t overwrite an existing customized value\u0026#34;);}_=\u0026gt;{setting_value=new_setting_value;}}letnumbers=(2,4,8,16,32);matchnumbers{(first,_,third,_,fifth)=\u0026gt;{println!(\u0026#34;Some numbers: {}, {}, {}\u0026#34;,first,third,fifth)}}matchnumbers{(first,..,last)=\u0026gt;{println!(\u0026#34;Some numbers: {}, {}\u0026#34;,first,last);}}letorigin=Point{x: 0,y: 0,z: 0};matchorigin{Point{x,..}=\u0026gt;println!(\u0026#34;x is {}\u0026#34;,x),}fn main(){let_x=5;// unused var to ignore warning when compiling lety=10;}匹配 let 语句，函数参数，for 循环只接受不可反驳模式。 match 只接受可反驳模式。\n// 完全匹配，要求全面讨论情况，按前后顺序依次进行，匹配后不再进行后续 #[derive(Debug)]enum UsState{Alabama,Alaska,// --snip-- }enum Coin{Penny,Nickel,Dime,Quarter(UsState),}fn value_in_cents(coin: Coin)-\u0026gt; u8 {matchcoin{Coin::Penny=\u0026gt;{println!(\u0026#34;Lucky penny!\u0026#34;);1},Coin::Nickel=\u0026gt;5,Coin::Dime=\u0026gt;10,Coin::Quarter(state)=\u0026gt;{println!(\u0026#34;State quarter from {:?}!\u0026#34;,state);25}_=\u0026gt;0,}}letnum=Some(4);matchnum{Some(x)ifx\u0026lt;5=\u0026gt;println!(\u0026#34;less than five: {}\u0026#34;,x),Some(x)=\u0026gt;println!(\u0026#34;{}\u0026#34;,x),None=\u0026gt;(),}letx=4;lety=false;matchx{4|5|6ify=\u0026gt;println!(\u0026#34;yes\u0026#34;),// (4 | 5 | 6) if y _=\u0026gt;println!(\u0026#34;no\u0026#34;),}// 单条件匹配 (if/while) let PATTERN = VALUE letsome_u8_value=Some(0u8);matchsome_u8_value{Some(3)=\u0026gt;println!(\u0026#34;three\u0026#34;),_=\u0026gt;(),}ifletSome(3)=some_u8_value{println!(\u0026#34;three\u0026#34;);}else{}letmutstack=Vec::new();stack.push(1);stack.push(2);stack.push(3);whileletSome(top)=stack.pop(){println!(\u0026#34;{}\u0026#34;,top);}// 解包匹配 letv=vec![\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;,\u0026#39;c\u0026#39;];for(index,value)inv.iter().enumerate(){println!(\u0026#34;{} is at index {}\u0026#34;,value,index);}let(x,y,z)=(1,2,3);fn print_coordinates(\u0026amp;(x,y): \u0026amp;(i32,i32)){println!(\u0026#34;Current location: ({}, {})\u0026#34;,x,y);}fn main(){letpoint=(3,5);print_coordinates(\u0026amp;point);}函数 fn fnname(arg1: i32,arg2:u32)-\u0026gt; u32 {5}关联函数 关联函数是定义在结构，枚举和特征的上下文中的函数，不使用实例变量。\nimplRectangle{fn square(size: u32)-\u0026gt; Rectangle{Rectangle{width: size,height: size,}}}letr=Rectangle::square(5);方法 方法是定义在结构，枚举和特征的上下文中的传入实例变量的函数，其第一个参数总是 self 代表了调用此方法的实例（可以使用不可变借用，可变借用，或获得所有权）。\n#[derive(Debug)]struct Rectangle{width: u32,height: u32,}implRectangle{fn area(\u0026amp;self)-\u0026gt; u32 {self.width*self.height}}fn main(){letrect1=Rectangle{width: 30,height: 50,};println!(\u0026#34;The area of the rectangle is {} square pixels.\u0026#34;,rect1.area());}Rust 支持自动引用和解引用，所以调用方法时，使用 .，而没有 -\u0026gt; 运算符。 对于方法调用 object.something()，Rust 自动添加 \u0026amp;, \u0026amp;mut, * 来传递实例参数。\n错误处理 不可恢复错误 panic! panic!(\u0026#34;crash and burn\u0026#34;);发生不可恢复错误时，Rust 默认会沿调用堆栈进行回溯，这会带来额外工作量，另一种选择是直接终止。\n[profile.release] panic = \u0026#39;abort\u0026#39; 查看调用栈（需启用调试符号）：\n$ RUST_BACKTRACE=1 cargo run 可恢复错误 Result\u0026lt;T, E\u0026gt; enum Result\u0026lt;T,E\u0026gt;{Ok(T),Err(E),}使用模式匹配处理：\nusestd::fs::File;usestd::io::ErrorKind;fn main(){letf=File::open(\u0026#34;hello.txt\u0026#34;);letf=matchf{Ok(file)=\u0026gt;file,Err(error)=\u0026gt;matcherror.kind(){ErrorKind::NotFound=\u0026gt;matchFile::create(\u0026#34;hello.txt\u0026#34;){Ok(fc)=\u0026gt;fc,Err(e)=\u0026gt;panic!(\u0026#34;Problem creating the file: {:?}\u0026#34;,e),},other_error=\u0026gt;{panic!(\u0026#34;Problem opening the file: {:?}\u0026#34;,other_error)}},};} unwrap_or_else(|error|{}) 提供错误处理逻辑 unwrap() 发生错误时立即 panic! expect(message) 发生错误时立即 panic!(message)  usestd::fs::File;usestd::io::ErrorKind;fn main(){letf=File::open(\u0026#34;hello.txt\u0026#34;).unwrap_or_else(|error|{iferror.kind()==ErrorKind::NotFound{File::create(\u0026#34;hello.txt\u0026#34;).unwrap_or_else(|error|{panic!(\u0026#34;Problem creating the file: {:?}\u0026#34;,error);})}else{panic!(\u0026#34;Problem opening the file: {:?}\u0026#34;,error);}});}错误传播 usestd::fs::File;usestd::io;usestd::io::Read;fn read_username_from_file()-\u0026gt; Result\u0026lt;String,io::Error\u0026gt;{letf=File::open(\u0026#34;hello.txt\u0026#34;);letmutf=matchf{Ok(file)=\u0026gt;file,Err(e)=\u0026gt;returnErr(e),};letmuts=String::new();matchf.read_to_string(\u0026amp;muts){Ok(_)=\u0026gt;Ok(s),Err(e)=\u0026gt;Err(e),}}fn read_username_from_file2()-\u0026gt; Result\u0026lt;String,io::Error\u0026gt;{letmutf=File::open(\u0026#34;hello.txt\u0026#34;)?;letmuts=String::new();f.read_to_string(\u0026amp;muts)?;Ok(s)}fn read_username_from_file3()-\u0026gt; Result\u0026lt;String,io::Error\u0026gt;{letmuts=String::new();File::open(\u0026#34;hello.txt\u0026#34;)?.read_to_string(\u0026amp;muts)?;Ok(s)}? 运算符：能被使用在返回 Result 的函数中。发生错误时，返回 Err(e)，使用定义在 From 特征中的 from 函数实现错误类型的转换。\n在 main 函数中使用 ? 运算符。\nusestd::error::Error;usestd::fs::File;fn main()-\u0026gt; Result\u0026lt;(),Box\u0026lt;dynError\u0026gt;\u0026gt;{letf=File::open(\u0026#34;hello.txt\u0026#34;)?;Ok(())}","date":"2021-07-06T09:42:46+08:00","permalink":"https://stardustdl.github.io/posts/learning/rust-startup/","title":"Rust 语言基础使用"},{"content":"基本信息 psake 是一个自动化构建工具，基于 PowerShell 构建，提供了类似 Make 的构建功能。\n安装 # Set-PSRepository -Name PSGallery -InstallationPolicy Trusted Install-Module -Name psake 使用 创建 psakefile.ps1，然后使用以下命令\nInvoke-psake # Get-Help Invoke-psake -full psakefile 结构    Function Description Required     Include() Call this function to have psake include the functions of another file into your script no   Properties() Call this function to set your properties no   Task() This is the main function that you write to execute a step in your build script. NOTE: There can be only one task function that is named \u0026ldquo;default\u0026rdquo; in your psake script and it cannot contain any code. psake will throw an exception if it finds more than one default task function or if the default task function contains code yes   Exec() Call a command-line program and throw an exception if it returns a non-zero DOS exit code no   Assert() Use to simplify writing conditional statements no   FormatTaskName() Allows you to reformat how psake displays the currently running task no   TaskSetup() A function that will run before each task is executed no   TaskTearDown() A function that will run after each task no   BuildSetup() A script block that will run before the first task starts no   BuildTearDown() A script block that will run when either all tasks have completed, or the build has failed no    BNF:\n\u0026lt;BuildScript\u0026gt; ::= \u0026lt;Includes\u0026gt; | \u0026lt;Properties\u0026gt; | \u0026lt;FormatTaskName\u0026gt; | \u0026lt;BuildSetup\u0026gt; | \u0026lt;TaskSetup\u0026gt; | \u0026lt;TaskTearDown\u0026gt; | \u0026lt;Tasks\u0026gt; \u0026lt;Includes\u0026gt; ::= Include \u0026lt;StringLiteral\u0026gt; | \u0026lt;Includes\u0026gt; \u0026lt;Properties\u0026gt; ::= Properties \u0026lt;ScriptBlock\u0026gt; | \u0026lt;Properties\u0026gt; \u0026lt;FormatTaskName\u0026gt; ::= FormatTaskName \u0026lt;Stringliteral\u0026gt; \u0026lt;BuildSetup\u0026gt; ::= BuildSetup \u0026lt;ScriptBlock\u0026gt; \u0026lt;BuildTearDown\u0026gt; ::= BuildTearDown \u0026lt;ScriptBlock\u0026gt; \u0026lt;TaskSetup\u0026gt; ::= TaskSetup \u0026lt;ScriptBlock\u0026gt; \u0026lt;TaskTearDown\u0026gt; ::= TaskTearDown \u0026lt;ScriptBlock\u0026gt; \u0026lt;Tasks\u0026gt; ::= Task \u0026lt;TaskParameters\u0026gt; | \u0026lt;Tasks\u0026gt; \u0026lt;TaskParameters\u0026gt; ::= -Name \u0026lt;StringLiteral\u0026gt; | -Action \u0026lt;ScriptBlock\u0026gt; | -PreAction \u0026lt;ScriptBlock\u0026gt; | -PostAction \u0026lt;ScriptBlock\u0026gt; | -PreCondition \u0026lt;ScriptBlock\u0026gt; | -PostCondition \u0026lt;ScriptBlock\u0026gt; | -ContinueOnError \u0026lt;Boolean\u0026gt; | -Depends \u0026lt;TaskNames\u0026gt; | -Description \u0026lt;StringLiteral\u0026gt; \u0026lt;TaskNames\u0026gt; ::= \u0026lt;StringLiteral\u0026gt;, | \u0026lt;TaskNames\u0026gt;\t\u0026lt;ScriptBlock\u0026gt; ::= { \u0026lt;PowerShellStatements\u0026gt; } \u0026lt;Boolean\u0026gt; ::= $true | $false 常见模式 Task default -Depends Test Task Test -Depends Compile, Clean { \u0026#34;This is a test\u0026#34; } Task Compile -Depends Clean { \u0026#34;Compile\u0026#34; } Task Clean -ContinueOnError { \u0026#34;Clean\u0026#34; } 传递参数和属性 调用：\nInvoke-psake .\\parameters.ps1 -parameters @{\u0026#34;p1\u0026#34;=\u0026#34;v1\u0026#34;;\u0026#34;p2\u0026#34;=\u0026#34;v2\u0026#34;} 传递的参数会作为脚本的变量。\npsakefile：\nproperties { $my_property = $p1 + $p2 } task default -depends TestParams task TestParams { Assert ($my_property -ne $null) \u0026#39;$my_property should not be null\u0026#39; } 覆盖预定义属性：\nInvoke-psake .\\properties.ps1 -properties @{\u0026#34;x\u0026#34;=\u0026#34;1\u0026#34;;\u0026#34;y\u0026#34;=\u0026#34;2\u0026#34;} 条件运行 task default -depends A,B,C task A { \u0026#34;TaskA\u0026#34; } task B -precondition { return $false } { \u0026#34;TaskB\u0026#34; } task C -precondition { return $true } { \u0026#34;TaskC\u0026#34; } 导入外部脚本 Include \u0026#34;.\\build_utils.ps1\u0026#34; 调用命令行工具 Exec -maxRetries 3 -retryTriggerErrorPattern \u0026#34;Service is not currently available.\u0026#34; { dotnet build } 参考资料  psake Document  ","date":"2020-07-24T19:30:40+08:00","permalink":"https://stardustdl.github.io/posts/tools/psake/","title":"psake"},{"content":"基本信息 GitHub Actions 中的 Workflow 提供了基于仓库相关事件驱动的工作流，可以基于此实现持续集成，持续部署等功能。\n基础使用 # Trigger eventon:# Trigger the workflow on push or pull request,# but only for the master branchpush:branches:- masterpull_request:# global env variablesenv:SERVER:production# default configdefaults:run:shell:bashworking-directory:scripts# all jobsjobs:job1:name:My first jobruns-on:ubuntu-latestjob2:name:My second jobneeds:job1strategy:matrix:node:[6,8,10]env:defaults:# When set to true, GitHub cancels all in-progress jobs if any matrix job fails.fail-fast:true# Prevents a workflow run from failing when a job fails. Set to true to allow a workflow run to pass when this job fails.continue-on-error:falseif:${{ true }}steps:- name:Print a greetingif:${{ true }}env:working-directory:./temprun:|echo $MY_VAR $FIRST_NAME $MIDDLE_NAME $LAST_NAME.shell:bash- # use extenal actionsname:My first stepuses:actions/hello_world@masterwith:first_name:Monamiddle_name:Thelast_name:Octocat - uses:actions/setup-node@v1with:# The Node.js version to configurenode-version:${{ matrix.node }}使用敏感数据 在仓库设置页面的 Secrets 部分添加敏感数据。\n- name:CIenv:NUGET_AUTH_TOKEN:${{ secrets.AZ_TOKEN }}run:Invoke-psake ci -parameters @{ \u0026#34;NUGET_AUTH_TOKEN\u0026#34; = $env:NUGET_AUTH_TOKEN }上传文件 - name:Upload reportsuses:actions/upload-artifact@v2with:name:ci-${{ matrix.os }}path:./reports启动外部工作流 Caller:\ninvoke-cd:needs:ciruns-on:ubuntu-latestif:${{ github.event_name == \u0026#39;push\u0026#39; \u0026amp;\u0026amp; github.ref == \u0026#39;refs/heads/master\u0026#39; }}steps:- name:Repository Dispatchuses:peter-evans/repository-dispatch@v1with:token:${{ secrets.PA_TOKEN }}event-type:cdCallee:\non:repository_dispatch:types:[cd]构建并推送 Docker 镜像 - name:Push imageuses:docker/build-push-action@v1with:username:${{ secrets.DOCKER_USERNAME }}password:${{ secrets.DOCKER_PASSWORD }}repository:repo_nametag_with_ref:truedockerfile:./Dockerfile参考资料  GitHub Actions Document  ","date":"2020-07-24T18:30:40+08:00","permalink":"https://stardustdl.github.io/posts/tools/github-workflow/","title":"GitHub Actions - Workflow"},{"content":"虽然 C++ 模板最初被 Bjarne Stroustrup 称为参数化类型，但是实际上其工作方式更像一个受限制的高级版宏，”模板“这个名称更加合适。\n这里使用 C++ 模板的非类型参数特性来实现一些数列的编译期计算。\n阶乘数列 $$ F_i = \\begin{cases} 1 \u0026amp; i = 0 \\\\ iF_{i-1} \u0026amp; i \u0026gt; 0 \\end{cases} $$\ntemplate \u0026lt;int num\u0026gt; class Factorial { public: static const int value = num * Factorial\u0026lt;num - 1\u0026gt;::value; }; template \u0026lt;\u0026gt; class Factorial\u0026lt;0\u0026gt; { public: static const int value = 1; }; int main() { cout \u0026lt;\u0026lt; Factorial\u0026lt;10\u0026gt;::value \u0026lt;\u0026lt; endl; } 为什么这是编译期运算呢？可以从两个方面了解。\n关闭编译器所有优化。\ng++ -S fac.cpp -O0 查看编译得到的汇编代码。\nmain: .LFB1522: .cfi_startproc endbr64 pushq\t%rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq\t%rsp, %rbp .cfi_def_cfa_register 6 -\tmovl\t$3628800, %esi \tleaq\t_ZSt4cout(%rip), %rdi call\t_ZNSolsEi@PLT movq\t%rax, %rdx movq\t_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@GOTPCREL(%rip), %rax movq\t%rax, %rsi movq\t%rdx, %rdi call\t_ZNSolsEPFRSoS_E@PLT movl\t$0, %eax popq\t%rbp .cfi_def_cfa 7, 8 ret .cfi_endproc 可以看到在标注的那一行，编译期直接将阶乘结果写到了汇编代码中。\n当运算结果超出 int 范围时，能否编译通过？\n更改 main 函数：\nint main() { cout \u0026lt;\u0026lt; Factorial\u0026lt;20\u0026gt;::value \u0026lt;\u0026lt; endl; } 再次编译：\nfac.cpp: In instantiation of ‘const int Factorial\u0026lt;13\u0026gt;::value’: fac.cpp:8:34: recursively required from ‘const int Factorial\u0026lt;19\u0026gt;::value’ fac.cpp:8:34: required from ‘const int Factorial\u0026lt;20\u0026gt;::value’ fac.cpp:20:28: required from here - fac.cpp:8:34: warning: integer overflow in expression of type ‘int’ results in ‘1932053504’ [-Woverflow]  8 | static const int value = num * Factorial\u0026lt;num - 1\u0026gt;::value; | ~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~ fac.cpp:8:22: error: overflow in constant expression [-fpermissive] 8 | static const int value = num * Factorial\u0026lt;num - 1\u0026gt;::value; | ^~~~~ fac.cpp:8:22: error: overflow in constant expression [-fpermissive] 可以看到编译器计算出了结果，同时也发现了溢出错误。\n斐波那契数列 $$ F_i = \\begin{cases} 0 \u0026amp; i = 0 \\\\ 1 \u0026amp; i = 1 \\\\ F_{i-1} + F_{i-2} \u0026amp; i \u0026gt; 1 \\end{cases} $$\ntemplate \u0026lt;int num\u0026gt; class Fibonacci { public: static const int value = Fibonacci\u0026lt;num - 1\u0026gt;::value + Fibonacci\u0026lt;num - 2\u0026gt;::value; }; template \u0026lt;\u0026gt; class Fibonacci\u0026lt;0\u0026gt; { public: static const int value = 0; }; template \u0026lt;\u0026gt; class Fibonacci\u0026lt;1\u0026gt; { public: static const int value = 1; }; 组合数 $$ F_{n,m} = \\begin{cases} 1 \u0026amp; m = 0 \\\\ 0 \u0026amp; n = 0 \\wedge m \u0026gt; 0 \\\\ F_{n-1,m-1} + F_{n-1,m} \u0026amp; \\text{otherwise} \\end{cases} $$\n上述递推式可以蕴含 $n\u0026gt;m$ 时 $F_{n,m}=0$ 的情况。\ntemplate \u0026lt;int n, int m\u0026gt; class Combinatorial { public: static const int value = Combinatorial\u0026lt;n - 1, m\u0026gt;::value + Combinatorial\u0026lt;n - 1, m - 1\u0026gt;::value; }; template \u0026lt;int m\u0026gt; class Combinatorial\u0026lt;0, m\u0026gt; { public: static const int value = 0; }; template \u0026lt;int n\u0026gt; class Combinatorial\u0026lt;n, 0\u0026gt; { public: static const int value = 1; }; template \u0026lt;\u0026gt; class Combinatorial\u0026lt;0, 0\u0026gt; { public: static const int value = 1; }; 因为 class Combinatorial\u0026lt;0, m\u0026gt; 和 class Combinatorial\u0026lt;n, 0\u0026gt; 均能匹配 $F_{0,0}$ 的情况，所以需要额外加入一个模板。\n如果不加入，编译器会自动检查出递归式的定义在 $(0,0)$ 处出现了冲突。\ncomb.cpp: In instantiation of ‘const int Combinatorial\u0026lt;1, 1\u0026gt;::value’: comb.cpp:8:61: recursively required from ‘const int Combinatorial\u0026lt;9, 3\u0026gt;::value’ comb.cpp:8:61: required from ‘const int Combinatorial\u0026lt;10, 3\u0026gt;::value’ comb.cpp:28:35: required from here - comb.cpp:8:61: error: ambiguous template instantiation for ‘class Combinatorial\u0026lt;0, 0\u0026gt;’  8 | static const int value = Combinatorial\u0026lt;n - 1, m\u0026gt;::value + Combinatorial\u0026lt;n - 1, m - 1\u0026gt;::value; | ~~~~~~^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ comb.cpp:12:7: note: candidates are: ‘template\u0026lt;int m\u0026gt; class Combinatorial\u0026lt;0, m\u0026gt; [with int m = 0]’ 12 | class Combinatorial\u0026lt;0, m\u0026gt; | ^~~~~~~~~~~~~~~~~~~ comb.cpp:19:7: note: ‘template\u0026lt;int n\u0026gt; class Combinatorial\u0026lt;n, 0\u0026gt; [with int n = 0]’ 19 | class Combinatorial\u0026lt;n, 0\u0026gt; | ^~~~~~~~~~~~~~~~~~~ comb.cpp:8:61: error: incomplete type ‘Combinatorial\u0026lt;0, 0\u0026gt;’ used in nested name specifier 8 | static const int value = Combinatorial\u0026lt;n - 1, m\u0026gt;::value + Combinatorial\u0026lt;n - 1, m - 1\u0026gt;::value; | ","date":"2020-07-23T13:23:31+08:00","permalink":"https://stardustdl.github.io/posts/learning/cpp-template-seq/","title":"C++ 模板实现编译期计算数列"},{"content":"AcBlog 是一个还在开发中的开源博客系统，支持纯静态部署。\nAcBlog 前端使用 WebAssembly 实现，支持 SPA，纯静态部署，后端支持静态和动态部署。以下是静态生成器生成的网站示例。\n AcBlog GitHub Pages AcBlog Gitee Pages  创建存储库 对于纯静态部署的博客，参照项目主页的文件结构建立存储库：\n app 目录下的内容将被直接复制到网站根目录 posts 目录下的内容为所有的文章（以 .md 为后缀），生成器将读取并用于生成静态后端 assets 目录下的内容将被直接复制到生成器输出目录，可用于存储文章中使用的图片等文件 acblog.json 包含了提供给生成器的相关配置 blog.json 包含了博客的相关信息 .github/workflows/deploy.yml 脚本用于自动构建并推送 GitHub Pages  编写说明 acblog.json 配置文件 { \u0026#34;acblog\u0026#34;: { \u0026#34;Properties\u0026#34;: { \u0026#34;Raw\u0026#34;: { \u0026#34;remote.origin.generator.baseAddress\u0026#34;: \u0026#34;博客网址\u0026#34;, } } } } 一般情况下，只需要填写博客网址，以供站点地图和 ATOM feed (RSS) 的生成使用。\n 生成的站点地图默认位于 博客网址/data/Site/sitemap.xml 生成的 ATOM feed 默认位于 博客网址/data/Site/atom.xml  blog.json { \u0026#34;Name\u0026#34;: \u0026#34;Blog name\u0026#34;, \u0026#34;Description\u0026#34;: \u0026#34;Blog description\u0026#34;, \u0026#34;StartYear\u0026#34;: 2020, \u0026#34;Onwer\u0026#34;: \u0026#34;onwer\u0026#34;, // 主页背景图地址，将图片放到 app 目录下，在这里填写文件名即可 \u0026#34;Cover\u0026#34;: \u0026#34;cover.jpg\u0026#34;, \u0026#34;Properties\u0026#34;: { \u0026#34;Raw\u0026#34;: {} } } 此文件提供了博客的描述信息，被用于网站的信息展示。\n文章结构 --- id: 文章id(生成网址) author: \u0026#39;\u0026#39; title: \u0026#39;标题\u0026#39; creationTime: 2020/1/1 12:00:00 +08:00 modificationTime: 2020/1/1 12:00:00 +08:00 category: [一级分类, 二级分类] keywords: [关键字] type: 类型(article,slides,note) password: 密码 --- Content (Markdown) 如不指定分类，将使用文件的目录结构自动生成分类：/posts/A/B/article.md 分类为 [A, B]。\n自动构建 AcBlog 实现了静态前端和静态后端自动生成的 GitHub Actions，通过它们可以很容易地进行自动构建。\n文件路径 .github/workflows/deploy.yml。\nname:Deployon:push:jobs:update:runs-on:ubuntu-latestcontinue-on-error:falsesteps:- name:Checkoutuses:actions/checkout@v2with:persist-credentials:false- # 静态前端生成器name:Generate Frontenduses:acblog/wasm-ghpages-generate-action@master- # 静态后端生成器name:Generate Backenduses:acblog/static-backend-generate-action@masterwith:# 生成器输出目录，对应网站根目录下的 /data 目录dist:\u0026#34;./dist/data\u0026#34;- # 如果使用了 assets 目录，则可以加上这一条# 将 assets 提升到项目根目录处，简化链接编写name:Copy out assetsrun:cp -r ./dist/data/assets ./dist/assets- name:Deployuses:JamesIves/github-pages-deploy-action@releases/v3with:# GitHub Token 用于 push 到仓库ACCESS_TOKEN:${{ secrets.PUSH_TOKEN }}BRANCH:masterFOLDER:distCLEAN:true由于项目前端依赖 WebAssembly，需手动在 GitHub Pages 分支的根目录下添加 .nojekyll 文件（内容为空即可）以禁用 GitHub Pages 的 Jekyll 自动构建。\n","date":"2020-07-15T08:23:46+08:00","image":"https://stardustdl.github.io/posts/projects/acblog-staticgen/head_hu9efe531bff7b440f821e48b9e03327e7_46403_120x120_fill_box_smart1_2.png","permalink":"https://stardustdl.github.io/posts/projects/acblog-staticgen/","title":"AcBlog 静态博客生成器使用说明"},{"content":" Project Source Demo Video  \r\r来源 最初的想法来自 计算机图形学的课程项目作业，其要求基于 Python + Qt 实现一个支持简单图元绘制的 GUI+CLI 程序。\n之前一般仅使用 Python 写一些简单的小型项目。曾写过一个较大项目，但即使使用了类型标注，也很快随着项目复杂度的提升，遇到了维护瓶颈，大大影响开发效率，遂中断了开发。\n这次是第一次使用 Python 开发图形用户界面的软件，也是第一次使用 Qt，考虑到这个项目的需求较为明确并且有足够的扩展可能，决定将此项目作为一个 Python 较大单人项目的练手，并规避以前 Python 项目遇到的一些问题。\nIdea 根据课程项目的模板代码，发现此项目非常适合 OOP 模式设计。结合以前的 WPF 学习经历，决定依照 WPF 的设计思路，试图在 ImagingS 中复刻 WPF 的呈现模型。\n \n 图元 Geometry 对象描述图元及其绘制算法 绘图 Drawing 将各种图元绘制到 DrawingContext 上 绘图上下文 DrawingContext 提供具体绘图的抽象，统一 GUI 绘图和图片文件绘图。  通过这三个层次，将呈现系统的两部分：定义与呈现分离。\n设计 核心的 API 集中在以下几个类中，其中与绘制抽象相关的大部分类均能在 WPF 绘制模型中找到对应。\n 图元类：各种图元的基类，定义了绘制算法（strokePoints）和变换。  class Geometry(PropertySerializable, ABC): def __init__(self) -\u0026gt; None: pass def transform(self) -\u0026gt; Optional[Transform]: pass def strokePoints(self, pen: Pen) -\u0026gt; Iterable[Point]: pass def fillPoints(self) -\u0026gt; Iterable[Point]: pass def inStroke(self, pen: Pen, point: Point) -\u0026gt; bool: pass def inFill(self, point: Point) -\u0026gt; bool: pass def transformed(self) -\u0026gt; Geometry: pass def bounds(self) -\u0026gt; Rect: pass 绘制类：所有可绘制元素的基类，定义了绘制函数（render）。对于图元对象，实现了 GeometryDrawing 来实际完成图元的绘制任务。  class Drawing(PropertySerializable, IdObject, ABC): def __init__(self) -\u0026gt; None: pass @abstractmethod def render(self, context: RenderContext) -\u0026gt; None: pass @property @abstractmethod def bounds(self) -\u0026gt; Rect: pass 绘图上下文类：对实际绘制的目标的抽象  class RenderContext(ABC): @abstractmethod def _point(self, position: Point, color: Color) -\u0026gt; None: pass @abstractmethod def bounds(self) -\u0026gt; Rect: pass def point(self, position: Point, color: Color) -\u0026gt; None: pass def points(self, positions: Iterable[Point], brush: Brush) -\u0026gt; None: pass 变换类：所有变换的基类，定义了如何将一个点变换到另一个点  class Transform(PropertySerializable, IdObject, ABC): def __init__(self) -\u0026gt; None: pass @abstractmethod def transform(self, origin: Point) -\u0026gt; Point: pass 文档类：定义了当前文档所包含的画刷，图元，画布大小等信息，实现了序列化操作  class Document(PropertySerializable, IdObject): def __init__(self) -\u0026gt; None: pass @property def brushes(self) -\u0026gt; IdObjectList[Brush]: pass @property def drawings(self) -\u0026gt; DrawingGroup: pass @property def size(self) -\u0026gt; Size: pass def save(self, file, format: DocumentFormat = DocumentFormat.ISD) -\u0026gt; None: pass @staticmethod def load(file, format: DocumentFormat = DocumentFormat.ISD) -\u0026gt; Document: pass 画布类：将抽象绘制对象包装成 Qt 中的绘制对象  class Canvas(QGraphicsView): pass class DrawingItem(QGraphicsItem): def __init__(self, drawing: Drawing, size: QSizeF, parent: Optional[QGraphicsItem] = None): pass 交互类：定义了 GUI 上与图元交互的所有操作，提供给画布一个统一的接口来处理用户交互  class Interactivity(QObject): started = pyqtSignal(QObject) ended = pyqtSignal(QObject) updated = pyqtSignal(QObject) def __init__(self) -\u0026gt; None: pass def start(self) -\u0026gt; None: pass def end(self, success: bool) -\u0026gt; None: pass def update(self) -\u0026gt; None: pass @property def viewItem(self) -\u0026gt; Optional[QGraphicsItem]: pass @property def state(self) -\u0026gt; InteractivityState: pass def onMousePress(self, point: QPointF) -\u0026gt; None: pass def onMouseMove(self, point: QPointF) -\u0026gt; None: pass def onMouseRelease(self, point: QPointF) -\u0026gt; None: pass def onMouseDoubleClick(self, point: QPointF) -\u0026gt; None: pass def onKeyPress(self, key: QKeyEvent) -\u0026gt; None: pass def onKeyRelease(self, key: QKeyEvent) -\u0026gt; None: pass 实现  To be done  总结 这个项目借鉴了 WPF 呈现模型的设计，一个成熟的模型的确是富有扩展性和较易维护的。Python + Qt 的组合开发效率也是很高的，但是运行效率有一定损失。\n项目目前的主要不足，一是图形学相关算法实现较少；二是部分类的 API 设计不够准确，这部分可能来源于 Qt 绘图模型和 WPF 依赖的 DirectX 两者的不一致，复刻的过程中部分设计需要适配 Qt ，造成一定妥协（例如 PyQt 的绘制效率低下，导致部分功能不容易在此模型下高效实现）。\n","date":"2020-07-04T22:17:52+08:00","image":"https://stardustdl.github.io/posts/projects/images-dev/head_hu305c74f0c0f0b5e138f098c149d6d1b0_54241_120x120_fill_box_smart1_2.png","permalink":"https://stardustdl.github.io/posts/projects/images-dev/","title":"ImagingS 开发笔记"},{"content":"基本信息  Dockerfile 为 Docker 提供镜像构建命令及描述。 Docker 书写思想：  自动化，无交互 顺序相关 清理 易读    基础语法  // 注释 INSTRUCTION arguments 指令格式，一般指令名大写  指令 FROM 指定基础镜像，必须是第一句有效指令。\nFROM\u0026lt;imagesName:tag\u0026gt;多个 FROM 指令使用最后一个。\nMAINTAINER 设置维护者信息。\nMAINTAINERName \u0026lt;Email\u0026gt;RUN 运行指定命令。\n shell 格式  RUN echo HelloWorld exec 格式（不启动 shell）  RUN [\u0026#34;prog\u0026#34;, \u0026#34;arg1\u0026#34;, \u0026#34;arg2\u0026#34;]ENV 设置镜像的环境变量。\nENV \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;COPY 将本地文件或文件夹复制到镜像指定路径下。\nCOPY /local/path/file /images/path/fileADD 可从本地或网上获取，存储到镜像指定路径下，也可对文件自动解包。\nADD file /images/path/fileADD latest.tar.gz /var/www/ 相同复制命令下，ADD 构建的镜像比 COPY 构建的镜像大 不能对构建目录或上下文之外的文件进行 ADD 操作：不能使用 ../path 会自动创建目的位置 会使得构建缓存无效  EXPOSE 指定暴露端口。\nEXPOSE\u0026lt;port\u0026gt; [\u0026lt;port\u0026gt;...]CMD 设置镜像启动命令。只有最后一个 CMD 指令有效。\nCMD [\u0026#34;echo\u0026#34;, \u0026#34;Hello World\u0026#34;]ENTRYPOINT 设置入口点。\nENTRYPOINT [\u0026#34;echo\u0026#34;]VOLUME 设置数据卷。\nVOLUME [\u0026#34;/data\u0026#34;, \u0026#34;/data2\u0026#34;]USER 设置构建用户。指定的用户需要在 USER 指令前创建。\nUSERuserUSERuser:groupUSERuid:gidWORKDIR 设置 RUN,CMD,ENTRYPOINT 工作目录。\nWORKDIR/path/workdirONBUILD 用于子镜像的二次构建中执行的 Dockerfile 指令。\nONBUILD RUN echo \u0026#34;Hello World\u0026#34;LABEL 添加元数据到镜像。尽量使用一个 LABEL 标签，减少构建 layer 数量。\nLABEL multi.label1=\u0026#34;value1\u0026#34; multi.label2=\u0026#34;value2\u0026#34;ARG 设置构建变量。\nARG \u0026lt;key\u0026gt; \u0026lt;value\u0026gt;STOPSIGNAL 指定运行 docker stop 时，向容器发送的信号。\nSTOPSIGNALSIGKILLHEALTHCHECK 检查容器状态。\n参数有：\n --interval 容器启动多长时间后开始检查 --timeout 设置超时时间，若超时，则认为容器异常 --retried 设置重试次数  HEALTHCHECK [OPTIONS] CMD commandSHELL 指示更换 shell 环境。\nSHELL [\u0026#34;powershell\u0026#34;, \u0026#34;-command\u0026#34;]参考资料  《Docker 从入门到实战》 黄靖钧 机械工业出版社  ","date":"2018-11-12T19:37:36+08:00","permalink":"https://stardustdl.github.io/posts/tools/proglang-dockerfile/","title":"Dockerfile"},{"content":"基本信息  官网 介绍：YAML 是一种数据序列化语言，旨在对人类友好，并与现代编程语言配合使用，以执行常见的日常任务。 优点  YAML的可读性好。 YAML和脚本语言的交互性好。 YAML使用实现语言的数据类型。 YAML有一个一致的信息模型。 YAML易于实现。    语法 基础语法  大小写敏感 使用缩进表示层级关系 缩进时不允许使用 Tab 键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略。  基础结构 对象 对象，键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）。使用冒号结构表示。也可将所有键值对写成一个行内对象。\nanimal:petshash:{name: Steve, foo:bar } 数组 数组，一组按次序排列的值，又称为序列（sequence） / 列表（list）。\n- Cat- Dog- Goldfishanimal:[Cat, Dog]纯量 纯量是最基本的、不可再分的值。支持的类型有：\n 布尔值：true false 整数，浮点数：字面量 12.30 Null：~ 时间：ISO8601 格式 2001-12-14t21:59:43.10-05:00 日期：复合 iso8601 格式的年、月、日表示 1976-07-31  使用两个感叹号，可强制转换类型。\ne:!!str123f:!!strtrue字符串  默认不使用引号表示 如果字符串之中包含空格或特殊字符，需要放在引号之中 单引号和双引号都可以使用，双引号不会对特殊字符转义 单引号之中如果还有单引号，必须连续使用两个单引号转义 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格 多行字符串可以使用 | 保留换行符，也可以使用 \u0026gt; 折叠换行  + 表示保留文字块末尾的换行，- 表示删除字符串末尾的换行。    str:这是一行字符串s1:\u0026#39;内容\\n字符串\u0026#39;s2:\u0026#34;内容\\n字符串\u0026#34;str:\u0026#39;labor\u0026#39;\u0026#39;s day\u0026#39;str:这是一段多行字符串this:|Foo Barthat:\u0026gt;Foo Bar s1:|Foos2:|+Foos3:|-Foo引用  \u0026amp; 建立锚点 \u0026lt;\u0026lt; 合并到当前数据 * 引用锚点  defaults:\u0026amp;defaultsadapter:postgreshost:localhostdevelopment:database:myapp_development\u0026lt;\u0026lt;:*defaultstest:database:myapp_test\u0026lt;\u0026lt;:*defaults# 等价于defaults:adapter:postgreshost:localhostdevelopment:database:myapp_developmentadapter:postgreshost:localhosttest:database:myapp_testadapter:postgreshost:localhost参考资料  YAML Version 1.2 YAML 语言教程  ","date":"2018-11-12T10:20:00+08:00","image":"https://raw.githubusercontent.com/github/explore/80688e429a7d4ef2fca1e82350fe8e3517d3494d/topics/yaml/yaml.png","permalink":"https://stardustdl.github.io/posts/tools/proglang-yaml/","title":"YAML Ain't Markup Language"},{"content":"概述  框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言  Nanos-lite是南京大学操作系统Nanos的裁剪版。可运行在 x86-nemu 的 AM 上。\n框架代码结构 nanos-lite/ # NANOS-LITE 项目 include/ # 头文件 src/ # 源文件 device.c # 设备抽象 fs.c # 文件系统 files.h # ramdisk 中的文件描述 initrd.S # ramdisk设备 irq.c # 中断异常处理 loader.c # 加载器 main.c # 主程序 mm.c # 存储管理 proc.c # 进程调度 ramdisk.c # ramdisk驱动程序 syscall.c # 系统调用处理 syscall.h # 系统调用相关宏 Makefile navy-apps/ nemu/ nexus-am/ include/ common.h 引用 AM 中的 am.h klib.h。\ndebug.h 简化调试输出的宏，可类比 nemu/debug.h。\nfs.h 文件系统的相关内容。\nLSEEK 类型枚举：\n   枚举 描述     SEEK_SET 将文件流位置设置为指定值   SEEK_CUR 将文件流位置设置为当前位置向后偏移指定值   SEEK_END 将文件流位置设置文件末尾    文件系统操作函数：\n   函数 描述     fs_open 打开文件，返回 ID   fs_read 读取文件   fs_write 写入文件   fs_lseek 改变文件流位置   fs_close 关闭文件   fs_filesz 获取文件大小    src/ main.c NANOS-LITE 主程序。\n 初始化存储 （init_mm） 初始化镜像文件 （init_ramdisk） 初始化设备 （init_device） 初始化中断处理 （init_irq） 初始化文件系统 （init_fs） 初始化进程 （init_proc）  从 ramdist 中加载程序镜像到指定位置 启动进程   测试自陷事件（_yield）  ramdisk.c 变量 ramdisk_start,ramdisk_end 指示 ramdisk 所在的内存区间。 宏 RAMDISK_SIZE 指示 ramdisk 对应内存大小。\nramdisk 相关操作函数。\n// 初始化 ramdisk void init_ramdisk(); // 从ramdisk中 offset 偏移处的 len 字节读入到 buf 中 size_t ramdisk_read(void *buf, size_t offset, size_t len); // 把 buf 中的 len 字节写入到ramdisk中 offset 偏移处 size_t ramdisk_write(const void *buf, size_t offset, size_t len); // 返回ramdisk的大小, 单位为字节 size_t get_ramdisk_size(); fs.c 文件系统相关。实现了 fs.h 中定义的函数。\n  init_fs 初始化文件系统\n 初始化 FD_FB 文件的大小（根据 VGA 屏幕大小）    ReadFn 类型：VFS 通用文件读取函数类型\n  WriteFn 类型：VFS 通用文件写入函数类型\n  typedef size_t (*ReadFn) (void *buf, size_t offset, size_t len); typedef size_t (*WriteFn) (const void *buf, size_t offset, size_t len); 用于禁用文件读写的函数：\n invalid_read 非法读取 invalid_write 非法写入  枚举 特殊文件类型枚举。\n   枚举 描述     FD_STDIN 标准输入   FD_STDOUT 标准输出   FD_STDERR 标准错误输出   FD_FB 显存    结构体 Finfo 文件描述信息。\n   成员 描述     name 文件名   size 文件大小   dist_offset 在 ramdisk 中的地址偏移   open_offset 文件流位置   read 读取函数   write 写入函数     file_table 保存了所有文件信息  files.h 定义了在 ramdisk 中的文件   NR_FILES 文件总数  特殊文件：\n   文件名 描述     stdin 标准输入   stdout 标准输出   stderr 标准错误输出   /dev/fb 显存   /proc/dispinfo 显示器信息   /dev/events 事件，包含时钟和键盘信号    device.c 将设备抽象成文件的实现。\n init_device 初始化设备  调用 _ioe_init() 初始化硬件 获取屏幕大小，写入到 dispinfo 缓冲区       函数 描述     serial_write 串口写入   events_read 读取事件   dispinfo_read 读取屏幕信息   fb_write 写入显存    loader.c 加载器。\n宏 DEFAULT_ENTRY 用户程序默认入口点。\n函数 loader static uintptr_t loader(PCB *pcb, const char *filename); 把指定名称的用户程序加载到正确的内存位置。 使用了 fs_read 操作函数（定义在 fs.h 中）\n函数 naive_uload 调用 loader 加载程序，并执行（在 proc.c/init_proc() 中使用）。\nproc.c 进程相关。\n函数 init_proc 初始化进程。\n 调用 naive_uload() （在 loader.c 中定义），加载并执行指定程序。  irq.c 定义了中断处理相关函数。\n do_event() 根据上下文和事件进行处理  将系统调用事件分发给 syscall.c   init_irq() 初始化中断处理  调用 _cte_init() 注册 do_event 作为处理函数。    syscall.h 定义了各种系统调用类型的编号。\nenum { SYS_exit, // 以指定结束码退出  SYS_yield, // 自陷  SYS_open, // 打开文件  SYS_read, // 读取文件  SYS_write, // 写入文件  SYS_kill, SYS_getpid, SYS_close, // 关闭文件  SYS_lseek, // 改变文件流位置  SYS_brk, // 设置 program break，用于堆内存管理  SYS_fstat, SYS_time, SYS_signal, SYS_execve, SYS_fork, SYS_link, SYS_unlink, SYS_wait, SYS_times, SYS_gettimeofday }; syscall.c 函数 do_syscall 根据上下文（在栈中保存），执行系统调用。 使用 nexus-am/am.h 中的 GRP? 宏访问系统调用参数。根据调用类型执行对应函数并处理返回值。\n引用资料  ICS2018 PA 讲义  ","date":"2018-11-05T17:30:22+08:00","permalink":"https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nanos-lite/","title":"NJU ICS Programming Assignment 代码分析 - NANOS-LITE"},{"content":"概述  框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言  Navy-Apps 提供一系列运行在 Nanos-lite 上的用户程序，也包含了 Newlib 库。\n框架代码结构 nanos-lite/ navy-apps/ apps/ # 用户程序 am-apps/ Makefile init/ litenes/ lua/ nterm/ nwm/ pal/ # 仙剑奇侠传 slider/ fsimg/ # 根文件系统 libs/ # 库 libc/ # Newlib C库 libos/ # 系统调用的用户层封装 syscall.h # 系统调用类型 tests/ # 一些测试 nemu/ nexus-am/  libs/libos/syscall.h 与 nanos-lite/syscall.h 相同。  libs/ libc/ Newlib 项目, 它是一个专门为嵌入式系统提供的 C 库, 库中的函数对运行时环境的要求极低. 这对Nanos-lite来说是非常友好的, 我们不需要为了配合C库而在Nanos-lite中实现额外的功能. 用户程序的入口位于 navy-apps/libs/libc/start.c 中的 _start() 函数, 它会调用用户程序的 main() 函数, 从 main() 函数返回后会调用 exit() 结束运行.\nlibos/src/nanos.c 系统调用的用户层封装。\n函数 syscall 进行系统调用的接口。\nintptr_t _syscall_(int type, intptr_t a0, intptr_t a1, intptr_t a2) { int ret; asm volatile(\u0026#34;int $0x80\u0026#34;: \u0026#34;=a\u0026#34;(ret): \u0026#34;a\u0026#34;(type), \u0026#34;b\u0026#34;(a0), \u0026#34;c\u0026#34;(a1), \u0026#34;d\u0026#34;(a2)); return ret; } 一系列系统调用函数    函数 描述     _exit 退出   _open 打开文件   _write 写入文件   _sbrk 增长堆区大小   _read 读取文件   _close 关闭文件   _lseek 改变文件流位置   _execve    (TODO)     引用资料  ICS2018 PA 讲义  ","date":"2018-11-05T17:30:22+08:00","permalink":"https://stardustdl.github.io/posts/learning/nju-icspa-analytics-navy-apps/","title":"NJU ICS Programming Assignment 代码分析 - NAVY-APPS"},{"content":"问题引入 给定 $64$ 位有符号整数 $a,b,m$ （类型为 int64_t），希望求出 $a\\times b \\bmod m$ 的数值。\nint64_t multimod(int64_t a, int64_t b, int64_t m); 给出一个尽可能高效的正确 multimod 实现。使得它对于任意在 $[0,2^{63}-1]$ 范围内的 $a,b,m$ 均能正确求出 $a\\times b \\bmod m$ 的数值，且在任何时候不触发有符号整数溢出。\n解决方法 运行环境 Windows 10 （64 位） 上 Hyper-V 平台，Debian 9 虚拟机 （64 位）\n CPU 型号：Intel(R) Core(TM) i7-7700HQ CPU 主频：2.80 GHz  基础设施 为使实验顺利，实验前先准备了测试程序和时间测量程序。\n测试程序 使用 Python 自动生成测试用例，运行程序，检查输出。\nimport os import random import sys def getNum(): return random.randint(0,2**63-1) if __name__==\u0026#34;__main__\u0026#34;: cnt = 10**4; passed = 0 failed = 0 if len(sys.argv)\u0026gt;1: cnt = int(sys.argv[1]) print(\u0026#34;Running\u0026#34;) for i in range(cnt): a,b,m = getNum(),getNum(),getNum() ans = a*b%m _ans = int(os.popen(\u0026#34; \u0026#34;.join([\u0026#34;./runner\u0026#34;,str(a),str(b),str(m)])).read()) if ans != _ans: if failed \u0026lt;= 5: print(\u0026#34;Error for a =\u0026#34;,a,\u0026#34;b =\u0026#34;,b,\u0026#34;m =\u0026#34;,m,\u0026#34;:\u0026#34;) print(\u0026#34;expected\u0026#34;,ans,\u0026#34;but real\u0026#34;,_ans) failed+=1 else: passed+=1 print(\u0026#34;Test\u0026#34;,cnt,\u0026#34;cases\u0026#34;); print(\u0026#34;Passed\u0026#34;,passed); print(\u0026#34;Failed\u0026#34;,failed); 其中 runner 程序调用 multimod 并将结果输出。\n#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;string.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026#34;p.c\u0026#34; typedef int64_t (*func)(int64_t, int64_t, int64_t); int main(int argc, char *argv[]){ assert(argc == 4); int64_t a, b, m; sscanf(argv[1], \u0026#34;%lld\u0026#34;, \u0026amp;a); sscanf(argv[2], \u0026#34;%lld\u0026#34;, \u0026amp;b); sscanf(argv[3], \u0026#34;%lld\u0026#34;, \u0026amp;m); func f = multimod; int64_t ans = f(a, b, m); printf(\u0026#34;%lld\\n\u0026#34;,ans); return 0; } 计时程序 使用 Python 随机生成测试用例，调用计时程序得到单次运行时间，统计后取平均值，会输出总耗时，平均耗时，和最大耗时，最小耗时。\nimport os import random import sys import time def getNum(): return random.randint(0,2**63-1) if __name__==\u0026#34;__main__\u0026#34;: cnt = 10**4; passed = 0 failed = 0 if len(sys.argv)\u0026gt;1: cnt = int(sys.argv[1]) print(\u0026#34;Running\u0026#34;) start = time.time() l = [] for i in range(cnt): a,b,m = getNum(),getNum(),getNum() ans = int(os.popen(\u0026#34; \u0026#34;.join([\u0026#34;./timer\u0026#34;,str(a),str(b),str(m)])).read()) l.append((a,b,m,ans)) end = time.time() print(\u0026#34;Test\u0026#34;,cnt,\u0026#34;cases use\u0026#34;,end-start,\u0026#34;seconds\u0026#34;); _l = list(map(lambda x: x[3],l)) sumC = sum(_l) print(\u0026#34;Sum CPU cycles:\u0026#34;,sumC) print(\u0026#34;Average CPU cycles:\u0026#34;,sumC / len(l)) mx,mn = max(_l),min(_l) idmx,idmn = _l.index(mx),_l.index(mn) print(\u0026#34;Maximum:\u0026#34;, mx, \u0026#34;@\u0026#34;, l[idmx]) print(\u0026#34;Minimum:\u0026#34;, mn, \u0026#34;@\u0026#34;, l[idmn]) 其中 timer 程序调用 multimod 进行运算并使用 Linux 中的 clock_gettime 函数获取执行时间（纳秒级，CPU 时钟数）。\n#include \u0026lt;stdint.h\u0026gt;#include \u0026lt;assert.h\u0026gt;#include \u0026lt;stdio.h\u0026gt;#include \u0026lt;time.h\u0026gt; #include \u0026#34;p.c\u0026#34; typedef int64_t (*func)(int64_t, int64_t, int64_t); volatile int64_t a, b, m; uint64_t measure(func f){ struct timespec st; clock_gettime(CLOCK_MONOTONIC,\u0026amp;st); int64_t before = st.tv_nsec; f(a, b, m); clock_gettime(CLOCK_MONOTONIC,\u0026amp;st); int64_t after = st.tv_nsec; return after - before; } int main(int argc, char *argv[]){ assert(argc == 4); sscanf(argv[1], \u0026#34;%lld\u0026#34;, \u0026amp;a); sscanf(argv[2], \u0026#34;%lld\u0026#34;, \u0026amp;b); sscanf(argv[3], \u0026#34;%lld\u0026#34;, \u0026amp;m); func f = multimod; uint64_t ans = measure(f); printf(\u0026#34;%llu\\n\u0026#34;,ans); return 0; } Makefile Makefile 文件指定依赖关系，使用 make check 和 make time 调用上述程序。\n.PHONY : clean time check all all : timer runner @echo \u0026#34;Builded\u0026#34; # p.o : p.c \t# $(CC) p.c -c $(CFLAGS) -o p.o timer: timer.o p.c $(CC) -o timer timer.o $(CFLAGS) $(LDFLAGS) -O2 runner: runner.o p.c $(CC) -o runner runner.o $(CFLAGS) $(LDFLAGS) -O2 time: timer @python3 ./measure.py check: runner @python3 ./checker.py clean: -rm -f *.o 有了上述基础设施后，下面开始编写 multimod 函数。\n基准实现 使用朴素二进制乘法，设输入 $A,B$，则结果 $C$ 有\n$$C_{i+j} = \\sum_{0\\le i,j \u0026lt; 64} A_iB_j$$\n则有\n$$Ans=(\\sum_{0\\le i \u0026lt; 128} (C_i\\times 2^i)\\bmod m)\\bmod m$$\n注意到 $0\\le m \u0026lt; 2^{63}$，两个 $m$ 以内的数相加不会发生无符号溢出。故转成无符号数，将乘 $2^i$，转化为 $i$ 次翻倍迭代取模就可以避免溢出。\n最终程序为：\n#include \u0026lt;stdint.h\u0026gt;int64_t multimod(int64_t a, int64_t b, int64_t m){ const int L = 128; uint64_t c[L]; for(int i = 0; i \u0026lt; L; i++) c[i] = 0; for(int i = 0; i \u0026lt; 64; i++) for(int j = 0; j \u0026lt; 64; j++) c[i+j]+=((a\u0026gt;\u0026gt;i\u0026amp;1)\u0026amp;(b\u0026gt;\u0026gt;j\u0026amp;1)); uint64_t ans = 0; for(int i=0;i\u0026lt;L;i++){ uint64_t t = c[i]; for(int j=0;j\u0026lt;i;j++) t=(t\u0026lt;\u0026lt;1)%m; ans=(ans+t)%m; } return ans; } 使用 make check 测试，输出如下：\nRunning Test 10000 cases Passed 10000 Failed 0 通过测试。\n性能优化 优化1：二进制拆分 使用 ACM/ICPC 圈子中常用的一种计算 $ab \\bmod m$ 的算法。将 $b$ 二进制拆分，得到其二进制表示 $(b_{63}\\dots b_0)_2$，则\n$$ ab=\\sum_{0\\le i\u0026lt;64} b_i\\times a2^i $$\n$a2^i$ 可以递推得到，由此可得到 $O(\\log b)$ 的算法。类似基准实现中讨论，转成无符号数后不会出现溢出问题。\n#include \u0026lt;stdint.h\u0026gt;int64_t multimod(int64_t a, int64_t b, int64_t m){ uint64_t _a = a % m, _b = b % m; uint64_t ans = 0; while(_b){ if(_b \u0026amp; 1){ ans+=_a; ans%=m; } _a+=_a; _a%=m; _b\u0026gt;\u0026gt;=1; } return ans; } 使用 make check 测试，输出如下：\nRunning Test 10000 cases Passed 10000 Failed 0 通过测试。\n优化2：高低位分别处理 类比计算 32 位整数乘积时的算法。将 $a,b$ 的高32位，和低32位各自取出，得到\n$$a=a_1\\times 2^{32} + a_0$$ $$b=b_1\\times 2^{32} + b_0$$\n则\n$$ \\begin{aligned} ab\u0026amp;=(a_1\\times 2^{32} + a_0)(b_1\\times 2^{32} + b_0)\\\n\u0026amp;=a_1b_1\\times 2^{64} + (a_0b_1+a_1b_0)\\times 2^{32} + a_0b_0 \\end{aligned} $$\n由输入范围限制，可得 $a_1b_1\u0026lt;2^{64},a_0b_1+a_1b_0\u0026lt;2^{64}$，但 $a_0b_0$ 可能发生一位溢出（因为 $a_0,b_0$ 可能等于 $2^{32}-1$。\n设 $ab=c=c_1\\times 2^{64} + c_0$，则有\n$$c_1 = a_1b_1+(a_0b_1+a_1b_0)_ {h32} + \\text{OF}(a_0b_0)$$ $$c_0 = (a_0b_0)\\bmod 2^{32}+(a_0b_1+a_1b_0)_{l32}$$\n由此可计算得出 $c_1,c_0$，由基准实现中讨论，将 $c_1\\times 2^{64} \\bmod m$ 转化成 $64$ 次翻倍迭代，避免溢出问题。\n#include \u0026lt;stdint.h\u0026gt;// #include \u0026lt;assert.h\u0026gt; static uint32_t _32f = (~((uint32_t)0)); static uint64_t _64f = (~((uint64_t)0)); int64_t multimod(int64_t a, int64_t b, int64_t m){ uint64_t a1 = a\u0026gt;\u0026gt;32, a0 = a\u0026amp;_32f; uint64_t b1 = b\u0026gt;\u0026gt;32, b0 = b\u0026amp;_32f; uint64_t t = a1*b0 + a0*b1; uint64_t t1 = t\u0026gt;\u0026gt;32, t0 = t\u0026amp;_32f, tc0 = a0*b0; uint64_t c1 = a1*b1 + t1, c0 = tc0 + (t0\u0026lt;\u0026lt;32); if(c0\u0026lt;tc0) // overflow  c1++; // __int128 _cor = ((__int128)a)*((__int128)b);  // assert((_cor\u0026gt;\u0026gt;64)==c1);  // assert((_cor\u0026amp;_64f)==c0);  for(int i=0;i\u0026lt;64;i++) c1 = (c1\u0026lt;\u0026lt;1)%m; return (c0%m + c1)%m; } 使用 make check 测试，输出如下：\nRunning Test 10000 cases Passed 10000 Failed 0 通过测试。\n效率实测 使用 make time 测试得到。以下表格中数值为测试 10000 组随机用例，得到的平均单次操作 CPU 时钟数。\n   程序 O0 O1 O2     p1.c $98554.87$ $102880.89$ $100160.11$   p2.c $1470.79$ $1472.98$ $1473.57$   p3.c $1185.46$ $1217.1$ $1207.91$    可见优化 1，2 较基准实现提高显著，不同编译优化级别对此程序运行效率影响不大。\n注：make time 输出内容\n# -O0 # p1.c Running Test 10000 cases use 11.16751217842102 seconds Sum CPU cycles: 985548700 Average CPU cycles: 98554.87 Maximum: 4802300 @ (2265130052289059763, 7783645480371944058, 3115603639858794422, 4802300) Minimum: 87600 @ (20906801206135418, 1235445072834323451, 7495840395140955697, 87600) # p2.c Running Test 10000 cases use 11.892813444137573 seconds Sum CPU cycles: 14707900 Average CPU cycles: 1470.79 Maximum: 142700 @ (1598719057711499987, 8349967337302892367, 5320637895082198498, 142700) Minimum: 1000 @ (7326329361318569666, 6606926909931228833, 6606926867070148477, 1000) # p3.c Running Test 10000 cases use 12.87213659286499 seconds Sum CPU cycles: 11854600 Average CPU cycles: 1185.46 Maximum: 58500 @ (957615596508775045, 4417329977803451093, 6085566768103491103, 58500) Minimum: 900 @ (3868418006544775637, 3115279496994464447, 2343316703378067646, 900) # -O1 # p1.c Running Test 10000 cases use 12.523572444915771 seconds Sum CPU cycles: 1028808900 Average CPU cycles: 102880.89 Maximum: 1932400 @ (7242145147389599538, 1833121011939475515, 6206342766087253890, 1932400) Minimum: 87500 @ (1822799065865324744, 2537174733001160, 158801504793342122, 87500) # p2.c Running Test 10000 cases use 10.98656439781189 seconds Sum CPU cycles: 14729800 Average CPU cycles: 1472.98 Maximum: 75600 @ (221577760594163762, 3833386045247446405, 2751795901368777150, 75600) Minimum: 1100 @ (371764953656247878, 5957505246066178493, 661631939839983461, 1100) # p3.c Running Test 10000 cases use 13.122157096862793 seconds Sum CPU cycles: 12171000 Average CPU cycles: 1217.1 Maximum: 271900 @ (7398188815938423410, 8253708753758420468, 4659411386263076728, 271900) Minimum: 900 @ (3809943949718199994, 3287343789103329664, 8650829315397374343, 900) # -O2 # p1.c Running Test 10000 cases use 13.260606288909912 seconds Sum CPU cycles: 1001601100 Average CPU cycles: 100160.11 Maximum: 926300 @ (339379419259308487, 3491644293891775690, 4785117665160931184, 926300) Minimum: 87500 @ (5052948108270793981, 27482781138671, 7792928891817598563, 87500) # p2.c Running Test 10000 cases use 12.278534412384033 seconds Sum CPU cycles: 14735700 Average CPU cycles: 1473.57 Maximum: 132100 @ (7176780085212300945, 2291171313687225809, 7324459208582226040, 132100) Minimum: 1000 @ (9203745517614844759, 6874714748664006916, 67857160092233, 1000) # p3.c Running Test 10000 cases use 12.674974918365479 seconds Sum CPU cycles: 12079100 Average CPU cycles: 1207.91 Maximum: 202400 @ (8532847693583176248, 6988877428537774137, 8782939934027677977, 202400) Minimum: 900 @ (3971319143760212181, 2705697508146050036, 1115671950010882609, 900) ","date":"2018-10-25T17:30:22+08:00","permalink":"https://stardustdl.github.io/posts/learning/multimod-64bit-method/","title":"64位有符号数乘法取模问题"},{"content":"概述  框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言  一方面, 应用程序的运行都需要运行时环境的支持; 另一方面, 只进行纯粹计算任务的程序在TRM上就可以运行, 更复杂的应用程序对运行时环境必定还有其它的需求。将这些需求收集起来，抽象成统一的API提供给程序, 这样我们就得到了一个可以支撑各种程序运行在各种机器上的库。具体地, 每个机器都按照它们的特性实现这组API; 应用程序只需要直接调用这组API即可, 无需关心自己将来运行在哪个机器上. 由于这组统一抽象的API代表了程序运行对机器的需求, 所以我们把这组API称为抽象计算机.\nNEXUS-AM(Abstract machine) 把程序和机器解耦。作为一个向程序提供运行时环境的库, AM根据程序的需求把库划分成以下模块\nAM = TRM + IOE + CTE + VME + MPE  TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力 IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力 CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力 VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力 MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力  框架代码结构 nanos-lite/ navy-apps/ nemu/ nexus-am/ # NEXUS-AM 项目 am/ # AM 相关 arch/ # 不同机器的 AM 实现 native/ x86-nemu/ build/ # AM 构建输出文件夹 apps/ # 直接运行在AM上的应用 hello/ # Hello World 程序 dhrystone/ # 性能测试程序 1 coremark/ # 性能测试程序 2 microbench/ # 性能测试程序 3 slider/ # 幻灯片播放程序 typing/ # 打字小游戏 litenes/ # 超级玛丽 libs/ # 可以直接运行在AM上的库 compiler-rt/ fixmath/ imgui/ klib/ # kernel library, 提供一些兼容 libc 的基础功能 tests/ # 直接运行在AM上的测试 cputest/ # CPU 实现测试（指令译码与执行） timetest/ # 时钟设备测试 keytest/ # 键盘设备测试 videotest/ # VGA 设备测试 ... Makefile # AM 构建命令 Makefile.check # AM 上项目的构建命令 Makefile.check 通过设置 ARCH 变量，指定默认 AM：\n native x86-nemu  am/ 特定 AM 实现代码结构 此为大致结构，不一定完全按照此结构。\nimg/ build run include/ # 头文件 arch.h # 基础头文件 src/ # 源码文件 devices/ # 设备接口实现 input.c # 输入设备（键盘） timer.c # 时钟设备 video.c # VGA 设备 cte.c # 对 CTE API 部分的实现。 ioe.c # 对 IOE API 部分的实现。 trm.c # 对 TRM API 部分的实现。 vme.c # 对 VME API 部分的实现。 trap.S  input.c 中需要实现对寄存器 _DEVREG_INPUT_KBD 的支持  am.h 定义了 AM 基础 API。\n枚举 定义了事件类型枚举，指示事件类型。\nenum { _EVENT_NULL = 0, _EVENT_ERROR, _EVENT_IRQ_TIMER, _EVENT_IRQ_IODEV, _EVENT_PAGEFAULT, _EVENT_YIELD, // 自陷  _EVENT_SYSCALL, // 系统调用 }; 结构体 _Context 规定了上下文结构体 _Context。 因为不同机器之间上下文信息的差异过大，所以在AM中, _Context 的具体成员也是由不同的机器自己定义的。因此, 在操作系统中, 对 _Context 成员的直接引用, 都属于机器相关的行为, 会损坏操作系统的可移植性. 不过大多数情况下, 操作系统并不需要单独访问 _Context 结构中的成员. 必要的时候, CTE也可以提供一些统一的接口, 来让操作系统通过这些接口来访问, 从而保证操作系统的相关代码与机器无关.\n_Area 一段内存区域。\n   成员 描述     start 起点   end 终点（不包含）    _Device 设备。\n   成员 描述     id 唯一ID   name 名字(非必须)   read 读操作   write 写操作    size_t (*read) (uintptr_t reg, void *buf, size_t size); size_t (*write)(uintptr_t reg, void *buf, size_t size);  read()/write() 分别是设备读/写操作的实现, 用于从设备的 reg 寄存器中读出 size 字节的内容到缓冲区 buf 中, 或者往设备的 reg 寄存器中写入缓冲区 buf 中的 size 字节的内容  需要注意的是, 这里的reg寄存器并不是设备寄存器, 因为设备寄存器的编号是机器相关的. 在IOE中, 我们希望采用一种机器无关的\u0026quot;抽象寄存器\u0026quot;, 这个reg其实是一个功能编号, 我们约定在不同的机器中, 同一个功能编号的含义也是相同的, 这样就实现了设备寄存器的抽象.\n_Event 事件，指示程序流切换的原因。\n   成员 描述     event 事件类型编号，使用上述枚举   cause 描述信息   ref    msg 事件信息字符串    TRM  void _trm_init() 初始化 TRM _Area _heap 结构用于指示堆区的起始和末尾 void _putc(char ch) 输出一个字符 void _halt(int code) 结束程序的运行  IOE  int _ioe_init() 初始化 IOE _Device *_device(int n) 返回编号为 n 的设备的数据结构. 机器中的可用设备从 1 开始按顺序编号, 若不存在编号为 n 的设备, 则返回 NULL。  可以使用这个 API 枚举机器中的每一个设备。    CTE  int _cte_init(_Context* (*handler)(_Event ev, _Context *ctx)) 用于进行CTE相关的初始化操作. 其中它还接受一个来自操作系统的事件处理回调函数的指针, 当发生事件时, CTE将会把事件和相关的上下文作为参数, 来调用这个回调函数, 交由操作系统进行后续处理. void _yield() 用于进行自陷操作, 会触发一个编号为 _EVENT_YIELD 事件.  VME (TODO)\nMPE (TODO)\namdev.h 使用宏定义常见设备 ID ：\n   宏 描述     _DEV_INPUT 输入设备   _DEV_TIMER 时钟设备   _DEV_VIDEO VGA 设备    使用宏定义了一些用于设备访问的抽象寄存器并定义了相关结构体：\n _DEVREG_INPUT_KBD 键盘控制器  从中读出 _KbdReg 结构体, keydown = 1 为按下按键, keydown = 0 为释放按键. keycode 为按键的断码, 没有按键时, keycode 为 _KEY_NONE .   _DEVREG_TIMER_UPTIME 系统启动时间  从中读出 _UptimeReg 结构体, (hi \u0026lt;\u0026lt; 32LL) | lo 是系统启动的毫秒数.   _DEVREG_TIMER_DATE 实时时钟(RTC)  从中读出 _DateReg 结构体, 包含年月日时分秒   _DEVREG_VIDEO_INFO 显示控制器信息  从中读出 _VideoInfoReg 结构体, 其中 width 为屏幕宽度, height 为屏幕高度. 另外假设AM运行过程中, 屏幕大小不会发生变化.   _DEVREG_VIDEO_FBCTL 帧缓冲控制器  向其写入 _FBCtlReg 结构体, 向屏幕 (x, y) 坐标处绘制 w*h 的矩形图像. 图像像素按行优先方式存储在 pixels 中, 每个像素用32位整数以 00RRGGBB 的方式描述颜色.    #define _DEVREG_INPUT_KBD 1  ... enum { _KEY_NONE = 0, _KEYS(_KEY_NAME) }; typedef struct { int keydown; // is keydown ? 1 : 0  int keycode; // key code _KEY_XXX  } _KbdReg; // ----------- _DEV_TIMER: AM Real Time Clock (0000ac03) ------------- #define _DEVREG_TIMER_UPTIME 1  typedef struct { uint32_t hi; // high 32bit of uptime (ms)  uint32_t lo; // low 32bit of uptime (ms)  } _UptimeReg; #define _DEVREG_TIMER_DATE 2  typedef struct { int year, month, day; // date  int hour, minute, second; // time  } _RTCReg; // ----------- _DEV_VIDEO: AM Video Controller (0000ac04) ------------ #define _DEVREG_VIDEO_INFO 1  typedef struct { int32_t width, height; // screen size: @width * @height  } _VideoInfoReg; #define _DEVREG_VIDEO_FBCTL 2  typedef struct { int x, y; // draw to (@x, @y)  uint32_t *pixels; // @pixels: @w*@h pixels to draw  int w, h; // @pixels[i * w + j] is 00RRGGBB  int sync; // @sync ? sync screen : do nothing  } _FBCtlReg; amtrace.h (TODO)\nx86-nemu/ x86-NEMU 编译与运行流程  在让NEMU运行客户程序之前, 我们需要将客户程序的代码编译成可执行文件. 需要说明的是, 我们不能使用gcc的默认选项直接编译, 因为默认选项会根据GNU/Linux的运行时环境将代码编译成运行在GNU/Linux下的可执行文件. 但此时的NEMU并不能为客户程序提供GNU/Linux的运行时环境, 在NEMU中无法正确运行上述可执行文件, 因此我们不能使用gcc的默认选项来编译用户程序.\n 解决这个问题的方法是交叉编译, 我们需要在GNU/Linux下根据AM的运行时环境编译出能够在 x86-nemu 这个新环境中运行的可执行文件. 为了不让链接器 ld 使用默认的方式链接, 我们还需要提供描述 x86-nemu 的运行时环境的链接脚本. AM的框架代码已经把相应的配置准备好了:\n gcc 将 x86-nemu 的AM实现的源文件编译成目标文件, 然后通过 ar 将这些目标文件作为一个库, 打包成一个归档文件 gcc 把应用程序源文件编译成目标文件 必要的时候通过 gcc 和 ar 把程序依赖的运行库 (如 nexus-am/libs/klib) 也打包成归档文件 执行脚本文件 nexus-am/am/arch/x86-nemu/img/build, 在脚本文件中  将程序入口 nexus-am/am/arch/x86-nemu/img/boot/start.S 编译成目标文件 最后让 ld 根据链接脚本 nexus-am/am/arch/x86-nemu/img/loader.ld, 将上述目标文件和归档文件链接成可执行文件    根据这一链接脚本的指示, 可执行程序重定位后的节从 0x100000 开始, 首先是 .text 节, 其中又以 nexus-am/am/arch/x86-nemu/img/boot/start.o 中自定义的 entry 节开始, 然后接下来是其它目标文件的 .text 节. 这样, 可执行程序的 0x100000 处总是放置 nexus-am/am/arch/x86-nemu/img/boot/start.S 的代码, 而不是其它代码, 保证客户程序总能从 0x100000 开始正确执行. 链接脚本也定义了其它节(包括 .rodata, .data, .bss )的链接顺序, 还定义了一些关于位置信息的符号, 包括每个节的末尾, 栈顶位置, 堆区的起始和末尾.\n我们对编译得到的可执行文件的行为进行简单的梳理:\n 第一条指令从 nexus-am/am/arch/x86-nemu/img/boot/start.S 开始, 设置好栈顶之后就跳转到 nexus-am/am/arch/x86-nemu/src/trm.c 的 _trm_init() 函数处执行. 在 _trm_init() 中调用 main() 函数执行程序的主体功能. 从 main() 函数返回后, 调用 _halt() 结束运行.  include/ arch.h 定义了宏 PMEM_SIZE 指定物理内存大小。\n结构体 _Context x86-nemu 上的上下文结构体。其顺序根据上下文构造过程决定（需参考 int pusha 指令以及 trap.S 实现）。 上下文构造过程：\n int 指令 trap.S 中指令  pusha 指令    在还原上下文时，仍需要根据上述顺序还原。\n系统调用事件的参数被 CTE 保存到上下文中。为方便处理系统调用事件，定义以下宏对应系统调用参数（根据 navy-apps/libs/libos/src/nanos.c 中的 _syscall_）。系统调用类型参见 nanos-lite/syscall.h。\n   宏 描述     GPR1 系统调用 ID   GPR2 第一个参数   GPR3 第二个参数   GPR4 第三个参数   GPRx 系统调用返回值    x86-nemu.h 包含了 arch.h.\nx86.h 定义了大量宏常量。\n   宏 描述     NR_IRQ IDT 大小    定义了辅助函数（使用内联汇编实现）：\n   函数 描述     uint8_t inb(int port) 从端口读取一字节值   uint16_t inw(int port) 从端口读取双字节值   uint32_t inl(int port) 从端口读取四字节值   void outb(int port, uint8_t data) 从端口写入一字节值   void outw(int port, uint16_t data) 从端口写入双字节值   void outl(int port, uint32_t data) 从端口写入四字节值   void set_idt(GateDesc *idt, int size) 设置 IDTR 寄存器    结构体 GateDesc 指示中断操作的门描述符(Gate Descriptor)类型。与 NEMU 中定义的对应结构体结构相同。\n定义了宏 GATE(type, cs, entry, dpl) 简化 GateDesc 构造。\nsrc/ devices/ 对应于 NEMU 中的设备实现设备访问接口。利用端口映射 I/O 和内存映射 I/O。参见 {% post_link solving/nju-icspa-analytics-nemu#device.c %}。\n 键盘访问端口 I8042_DATA_PORT 时钟访问端口 RTC_PORT VGA 访问端口 SCREEN_PORT 和内存 VMEM  对每个设备，需要实现 amdev.h 中特定抽象寄存器的操作。在设备初始化函数 deviceName_init() 中，可以进行一些初始化操作。\ncte.c 定义了 IDT 数组 idt.\n_yield() 实现：\n 在 x86-nemu 中, 我们约定自陷操作通过 0x81 号中断（int $0x81）触发（在 trap.S 中规定）.  _cte_init 实现：\n 初始化 IDT  设置 vectrap 与 vecsys   设置 IDTR 寄存器（使用 set_idt） 注册 user_handler  函数 irq_handle 硬件级别（NEMU）中断处理函数。根据上下文生成 _Event，调用注册的用户回调函数。\ntrap.S 给出了 vecsys vectrap irq0 vecnull 等调用 CTE 处理过程的函数。\n函数 asm_trap 构造上下文，调用函数 irq_handle。\nlibs/ klib/ Kernal Library. 提供一些兼容 libc 的基础功能。\ninclude/klib.h 定义了 klib 中定义的的函数。\n框架代码编译到 native 的时候默认链接到 glibc，可以使用宏 __NATIVE_USE_KLIB__ 使这些调用链接到这里实现的 klib.\nsrc/ stdio.c 标准输入输出。\n   函数 描述     vsnprintf 变长参数列表输出到字符串，限制最大字符数   vsprintf 变长参数列表输出到字符串   snprintf 输出到字符串，限制最大字符数   sprintf 输出到字符串   printf 输出到串口设备    string.c 字符串操作。\n   函数 描述     strlen    strcpy    strncpy    strcat    strcmp    strncmp    memset    memcpy    memcmp     stdlib.c 标准库函数。\n   函数 描述     rand    srand     io.c 常用的输入输出功能。\n// 返回系统启动后经过的毫秒数 uint32_t uptime(); // 在 rtc 结构中返回当前时间, PA中不会用到 void get_timeofday(void *rtc); // 返回按键的键盘码, 若无按键, 则返回 _KEY_NONE int read_key(); // 将 pixels 指定的矩形像素绘制到屏幕中以 (x, y) 和 (x+w, y+h) 两点连线为对角线的矩形区域 void draw_rect(uint32_t *pixels, int x, int y, int w, int h); // 将之前的绘制内容同步到屏幕上 void draw_sync(); // 返回屏幕的宽度 int screen_width(); // 返回屏幕的高度 int screen_height(); cpp.c (TODO)\napps/ 直接运行在AM上的应用。\nmicrobench/ 性能测试程序 3。microbench提供了两个不同规模的测试集test和ref. 其中ref测试集规模较大, 用于跑分测试, 默认会编译ref测试集; test测试集规模较小, 用于正确性测试, 需要在运行make时显式指定编译test测试集:\nmake INPUT=TEST tests/ 直接运行在AM上的测试。\n使用测试方法：\n 进入测试项目目录 使用 make run 运行测试  可使用 ARCH=native 指定 AM    cputest/ 包含一些测试 CPU 指令实现的测试。 使用 make ALL=testname run 指定测试。\n引用资料  ICS2018 PA 讲义  ","date":"2018-10-23T17:30:22+08:00","permalink":"https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nexus-am/","title":"NJU ICS Programming Assignment 代码分析 - NEXUS-AM"},{"content":"概述  框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言  由于 NJU ICS PA 框架代码较多且缺少足够说明，讲义多为基础引入内容，为方便后续程序编写，根据实际作业过程中的理解整理出此文。 本文主要包含对 NJU ICS 课程编程作业的框架代码中 NEMU 部分的理解和分析，跟随课程及讲义进度更新，以个人使用为主，可能存在错误。\n 部分内容框架代码并不包含（如扩展的 Debug 宏），均为我为编码而添加的内容。采用 a_b 方式命名的多为原内容，采用 aB 方式命名的多为补充内容。由于此项目是 NJU ICS PA 的一部分，其中会包含与相关项目的互操作内容。\n NEMU (NJU EMUlator) 是在 Linux 上的一个 n86（x86 子集）模拟器，模拟了基本计算机系统的功能（内存，CPU等）。包含了：\n 内存 CPU，寄存器 调试器（监视器）  框架代码结构 nanos-lite/ navy-apps/ nexus-am/ nemu/ # NEMU 项目 build/ # 构建输出文件夹 nemu # NEMU 主程序（可执行文件） include/ # 头文件 src/ # 源码文件 tools/ # 工具文件 runall.sh # 测试 AM cputest 测试集 （nexus-am/tests/cputest） Makefile # NEMU 构建命令 Makefile.git # NEMU Git 记录命令 include/ nemu.h 基础头文件。包含了 commom.h，memory/memory.h，cpu/reg.h\nmacro.h 定义了一些字符串连接宏 concat 等。\ncommon.h 定义了一些类型别名。\n   类型别名 原类型 描述     rtlreg_t uint32_t RTL寄存器   vaddr_t uint32_t 虚拟地址   paddr_t uint32_t 物理地址   ioaddr_t uint16_t I/O 端口地址     relreg_t 多用于寄存器访问 vaddr_t paddr_t 多用于内存访问 ioaddr_t 多用于设备 I/O 端口访问  定义了一些控制编译方式的宏。\n   宏 描述     DEBUG 启用调试   DIFF_TEST 启用 diff-test   HAS_IOE 启用输入输出扩展     DIFF_TEST 可启用一个差异测试工具，参见 tools/qemu-diff 部分。 HAS_IOE 启用输入输出设备，参见设备部分。  debug.h 定义了便于调试的宏。\n   宏 描述     Log_write(format, ...) 仅记录日志   printflog(format, ...) 显示文本并记录日志   Log(format, ...) 对 printflog 的扩展，包含当前文件，行，函数   Info(format, ...) 对 Log 的扩展，日志级别：提示   Warning(format, ...) 对 Log 的扩展，日志级别：警告   Error(format, ...) 对 Log 的扩展，日志级别：错误   panic(format, ...) 强制退出，显示文本并记录日志   Assert(cond [, format, ...]) 设置断言，失败时强制退出，显示文本并记录日志   TODO() 标识待完成项，执行时会触发 panic    cpu/ reg.h 定义了寄存器结构，和辅助寄存器的一些宏和函数。\n 外部数组 regsl, regsw, regsb 不同寄存器名。实现在 src/cpu/reg.c  extern const char* regsl[]; extern const char* regsw[]; extern const char* regsb[]; 结构体 CPU_state 寄存器结构，包含了所有寄存器，均为无符号整数。\n 对于 8 个通用寄存器，内部以 gpr 数组为基础结构，提供 eax 等别名方便访问。寄存器按照 i386 指令中寄存器标号顺序排列。可使用 _16,_8[0],_8[1] 访问寄存器低位部分。 eip 当前执行指令位置寄存器 eflags 标志位寄存器（使用匿名结构体，可直接访问 CF,OF,ZF,SF）  eflags 初始化为 0x2   cs,ss,ds,es,fs,gs 程序段寄存器（仅为支持 diff-test）  cs 初始化为 8   idtr 48 位寄存器，存放 IDT (Interrupt Descriptor Table, 中断描述符表)的首地址和长度  limit 16位，长度，单位：字节 base 32位，IDT 基地址       函数/宏 描述     reg_l(index) 获取指定下标处寄存器32位值   reg_w(index) 获取指定下标处寄存器低16位值   reg_b(index) 获取指定下标处寄存器低8位值   reg_name(index,width) 根据下标和位宽获得寄存器名     寄存器存储在变量 cpu 中。\n 枚举 定义了形如 R_NAME 的寄存器枚举，其顺序与寄存器结构中的顺序一致。\nenum { R_EAX, R_ECX, R_EDX, R_EBX, R_ESP, R_EBP, R_ESI, R_EDI }; enum { R_AX, R_CX, R_DX, R_BX, R_SP, R_BP, R_SI, R_DI }; enum { R_AL, R_CL, R_DL, R_BL, R_AH, R_CH, R_DH, R_BH }; decode.h 定义了用于指令译码的结构和函数。\n结构体 Operand 操作数。\n   成员 描述     type 类型（见下方枚举）   width 位宽   val 实际值   str 原串（用于调试输出）   reg 寄存器下标   addr 内存地址   imm 立即数   simm 带符号立即数    结构体 DecodeInfo 单条命令译码结果。\n   成员 描述 对应x86指令部分     opcode 指令码 opcode   seq_eip 序列 EIP 位置    is_operand_size_16 标识操作数是否为 16 位 operand-size prefix   ext_opcode 额外指令码 ModR/M 中 opcode   is_jmp 标识是否为跳转语句    jmp_eip 跳转目标（绝对地址），仅对于跳转语句    src 源操作数    src2 第二个源操作数    dest 目标操作数    assembly     asm_buf     p       seq_eip 随译码过程改变，最终停留在需要译码的下一个位置，可根据这一值实现 eip 更新。 is_operand_size_16 多用于实现单命令存在 16 位，32 位两个版本的情况 ext_opcode 用于实现 sub /5 这种根据第二个指令码 /5 区分不同指令的情况，在译码中使用 make_group 实现。 is_jmp 多在运行时指定（如 rtl_j 函数），如果标记，则不会再根据 seq_eip 更新 eip     函数/宏 描述     id_src (\u0026amp;decoding.src)   id_src2 (\u0026amp;decoding.src2)   id_dest (\u0026amp;decoding.dest)   operand_write(Operand *, rtlreg_t *) 根据第一个参数中记录的类型的不同进行相应的写操作，包括写寄存器和写内存   load_addr(vaddr_t *, ModR_M *, Operand *)    read_ModR_M(vaddr_t *, Operand *, bool, Operand *, bool)      译码内容存储在变量 decoding 中。\n 结构体 ModR_M 指令中的 ModR/M。\n结构体 SIB 指令中的 SIB。\n枚举 定义了操作数的类型 OP_TYPE_REG，OP_TYPE_MEM，OP_TYPE_IMM，分别为寄存器，内存，立即数。\n宏 make_DHelper 与函数族 decode_name 由宏 make_DHelper 定义了一族函数（参数相同），用于指令译码，并定义了这些函数的指针类型 DHelper。\n 设计目的：由于大量指令的操作数模式相似，将这一点提取出来，实现解耦。  #define make_DHelper(name) void concat(decode_, name) (vaddr_t *eip) typedef void (*DHelper) (vaddr_t *); 函数族中部分函数命名规则（不全）：\n   名称 描述     I 立即数   SI 有符号立即数   E 内存或寄存器（对应指令描述中的 r/m）   G 通用寄存器   r 单一寄存器   a 指定寄存器为 eax,ax,al   I2G 立即数到通用寄存器   I_E2G 立即数与内存或寄存器到通用寄存器   O 未知     r 一般用于寄存器信息存储在 opcode 中的情况 还有一些专用于特定指令的译码函数   建议结合 i386 手册附录 C 理解。\n 函数族中特殊函数：\n J 跳转指令解码。单操作数，存储到 jmp_eip 中。  exec.h 定义了一些用于调试的指令打印宏：\n   宏 描述     print_asm 打印指令   suffix_char 根据宽度获取指令宽度后缀   print_asm_template1 单操作数指令   print_asm_template2 双操作数指令   print_asm_template3 三操作数指令    函数 instr_fetch uint32_t instr_fetch(vaddr_t *eip, int len) 从 eip 开始，读取 len 个字节，返回值，并自动增加 eip。\n 设计目的：与机器的大端小端解耦。  宏 make_EHelper 与 函数族 exec_name 用于定义一族函数（参数相同），用于指令执行，并定义了这些函数的指针类型 EHelper。\n#define make_EHelper(name) void concat(exec_, name) (vaddr_t *eip) typedef void (*EHelper) (vaddr_t *); relop.h 定义了形如 RELOP_NAME 的枚举，标识不同类型的关系运算。对应了 setcc,jcc 命令的相应编码。\nenum { // +-- unsign  // | +-- sign  // | | +-- equal  // | | | +-- invert  // | | | |  RELOP_FALSE = 0 | 0 | 0 | 0, RELOP_TRUE = 0 | 0 | 0 | 1, RELOP_EQ = 0 | 0 | 2 | 0, RELOP_NE = 0 | 0 | 2 | 1, RELOP_LT = 0 | 4 | 0 | 0, RELOP_LE = 0 | 4 | 2 | 0, RELOP_GT = 0 | 4 | 2 | 1, RELOP_GE = 0 | 4 | 0 | 1, RELOP_LTU = 8 | 0 | 0 | 0, RELOP_LEU = 8 | 0 | 2 | 0, RELOP_GTU = 8 | 0 | 2 | 1, RELOP_GEU = 8 | 0 | 0 | 1, }; cc.h 定义了函数 get_cc_name 根据编码获取指定关系运算字符串。\n定义了 RTL 基本指令 rtl_setcc 用于根据当前关系运算和 eflags 寄存器标志位设置 dest。\nvoid rtl_setcc(rtlreg_t*, uint8_t); rtl.h 定义和实现了一些 RTL 指令，用于提供对指令执行的底层建模。可使用这些操作将复杂指令分解成更简单的操作。\nNEMU 中的 RTL 寄存器：\n x86的八个通用寄存器(在 include/cpu/reg.h 中定义) id_src, id_src2 和 id_dest 中的访存地址 addr 和操作数内容 val (在 include/cpu/decode.h 中定义). 从概念上看, 它们分别与MAR和 MDR有异曲同工之妙 临时寄存器 t0~t3 和 at (在 src/cpu/decode/decode.c 中定义)  extern rtlreg_t t0, t1, t2, t3, at;  宏 make_rtl_arith_logic 根据算术运算符名创建对应 RTL 基本指令和 RTL 指令，使用了 include/util/c_op.h 中的运算。  32位寄存器-寄存器类型的算术/逻辑运算 32位寄存器-立即数类型的算术/逻辑运算   定义函数 decoding_set_jmp(bool is_jmp) ：将 当前指令标记为跳转（标记 decoing.is_jmp） 定义函数 interpret_relop ：实现两个值的关系运算，返回结果（实现在 src/cpu/exec/relop.c  RTL 基本指令 特点：不需要使用临时寄存器, 可以看做是最基本的x86指令中的最基本的操作。 实现时添加了 interpret_ 前缀，但在 include/cpu/rtl-wrapper.h 作用下，其它代码中使用到这些RTL基本指令时会自动添加 interpret_ 前缀。\n 立即数读入 rtl_li 寄存器传输 rtl_mv 32位寄存器-寄存器类型的算术/逻辑运算, 包括 rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r]) , 这些运算的定义用到 include/util/c_op.h 中的C语言运算 被除数为64位的除法运算 rtl_i?div64_[q|r] guest内存访问 rtl_lm 和 rtl_sm host内存访问 rtl_host_lm 和 rtl_host_sm 关系运算 rtl_setrelop, 具体可参考 src/cpu/exec/relop.c 跳转, 包括直接跳转 rtl_j , 间接跳转 rtl_jr 和条件跳转 rtl_jrelop 终止程序 rtl_exit  具体声明：\n 未标明则函数修饰符均为 static inline。  // 立即数读入 void interpret_rtl_li(rtlreg_t* dest, uint32_t imm); // 寄存器传输 void interpret_rtl_mv(rtlreg_t* dest, const rtlreg_t *src1); // 32位寄存器-寄存器类型的算术/逻辑运算 void interpret_rtl_add (rtlreg_t* dest, const rtlreg_t* src1, const rtlreg_t* src2); // 被除数为64位的除法运算 void interpret_rtl_div64_q(rtlreg_t* dest, const rtlreg_t* src1_hi, const rtlreg_t* src1_lo, const rtlreg_t* src2); // guest内存访问 void interpret_rtl_lm(rtlreg_t *dest, const rtlreg_t* addr, int len); void interpret_rtl_sm(const rtlreg_t* addr, const rtlreg_t* src1, int len); // host内存访问 void interpret_rtl_host_lm(rtlreg_t* dest, const void *addr, int len); void interpret_rtl_host_sm(void *addr, const rtlreg_t *src1, int len); // 关系运算 void interpret_rtl_setrelop(uint32_t relop, rtlreg_t *dest, const rtlreg_t *src1, const rtlreg_t *src2); // 跳转 void interpret_rtl_j(vaddr_t target); void interpret_rtl_jr(rtlreg_t *target); void interpret_rtl_jrelop(uint32_t relop, const rtlreg_t *src1, const rtlreg_t *src2, vaddr_t target); // 终止程序 void interpret_rtl_exit(int state); RTL 伪指令 通过RTL基本指令或者已经实现的RTL伪指令来实现。\n 32位寄存器-立即数类型的算术/逻辑运算, 包括 rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])_i 通用寄存器访问 rtl_lr 和 rtl_sr EFLAGS标志位的读写 rtl_set_(CF|OF|ZF|SF) 和 rtl_get_(CF|OF|ZF|SF) 其它常用功能, 如按位取反 rtl_not ，符号扩展 rtl_sext 等  具体声明：\n 未标明则函数修饰符均为 static inline。 宏 make_rtl_setget_eflags 声明了需要实现的 EFLAGS标志位的读写 指令  rtl_set_name rtl_get_name    // 32位寄存器-立即数类型的算术/逻辑运算 void rtl_addi (rtlreg_t* dest, const rtlreg_t* src1, int imm) // 通用寄存器访问 void rtl_lr(rtlreg_t* dest, int r, int width); void rtl_sr(int r, const rtlreg_t* src1, int width); // EFLAGS标志位的读写 void rtl_set_CF (const rtlreg_t* src); void rtl_get_CF (rtlreg_t* dest); void rtl_set_OF (const rtlreg_t* src); void rtl_get_OF (rtlreg_t* dest); void rtl_set_ZF (const rtlreg_t* src); void rtl_get_ZF (rtlreg_t* dest); void rtl_set_SF (const rtlreg_t* src); void rtl_get_SF (rtlreg_t* dest); // 根据运算结构更新 ZF, SF 标志位 void rtl_update_ZF(const rtlreg_t* result, int width); void rtl_update_SF(const rtlreg_t* result, int width); void rtl_update_ZFSF(const rtlreg_t* result, int width); // 按位取反 void rtl_not(rtlreg_t *dest, const rtlreg_t* src1); // 符号扩展 void rtl_sext(rtlreg_t* dest, const rtlreg_t* src1, int width); // 压栈 void rtl_push(const rtlreg_t* src1); // 弹栈 void rtl_pop(rtlreg_t* dest); // 32位寄存器-立即数类型 关系运算 void rtl_setrelopi(uint32_t relop, rtlreg_t *dest, const rtlreg_t *src1, int imm); // 取符号位（最高位） void rtl_msb(rtlreg_t* dest, const rtlreg_t* src1, int width); 我们定义RTL基本指令的时候, 约定了RTL基本指令不需要使用RTL临时寄存器. 但某些RTL伪指令需要使用临时寄存器存放中间结果, 才能实现其完整功能. 这样可能会带来寄存器覆盖的问题, 例如如下RTL指令序列:\n(1) rtl_mv(\u0026amp;t0, \u0026amp;t1); (2) rtl_sext(\u0026amp;t1, \u0026amp;t2, 1); // use t0 temporarily (3) rtl_add(\u0026amp;t2, \u0026amp;t0, \u0026amp;t1); 如果实现(2)的时候恰好使用到了t0作为临时寄存器, 在(3)中使用的t0就不再是(1)的结果了, 从而产生非预期的结果.\n为了尽可能避免上述问题, 我们有两条约定:\n 实现RTL伪指令的时候, 尽可能不使用 dest 之外的寄存器存放中间结果. 由于 dest 最后会被写入新值, 其旧值肯定要被覆盖, 自然也可以安全地作为RTL伪指令的临时寄存器. 实在需要使用临时寄存器的时候, 使用 at . at 全称是assembly temporary, 是MIPS ABI中定义的一个特殊寄存器: 编译器并不会使用它, 它可以在编写汇编代码的时候安全地作为可使用的临时寄存器. 在这里， 我们借鉴它的功能来作如下约定: 不要在RTL伪指令的内部实现之外使用 at . 这样， at 就可以安全地作为RTL伪指令的临时寄存器了.  rtl-wrapper.h 为 rtl.h 中定义的 RTL 基本指令的调用省去 interpret_ 前缀。\nmemory/ memory.h 定义了访问内存的函数。使用数组 pmem 模拟内存。\nextern uint8_t pmem[];    函数/宏 描述     uint32_t vaddr_read(vaddr_t, int) 从虚拟内存指定位置读取指定数目个字节   void vaddr_write(vaddr_t, uint32_t, int) 向虚拟内存指定位置写入指定数目个字节   uint32_t paddr_read(paddr_t, int) 从物理内存指定位置读取指定数目个字节   void paddr_write(paddr_t, uint32_t, int) 向物理内存指定位置写入指定数目个字节   guest_to_host(p) ((void *)(pmem + (unsigned)p))   host_to_guest(p) ((paddr_t)((void *)p - (void *)pmem))    mmu.h (TODO)\n结构体 GateDesc 指示中断操作的门描述符(Gate Descriptor)类型。门描述符是一个8字节的结构体, 里面包含着不少细节的信息, 在NEMU中简化了门描述符的结构, 只保留存在位P和偏移量OFFSET。\n 31 23 15 7 0 +-----------------+-----------------+---+-------------------------------+ | OFFSET 31..16 | P | Don't care |4 +-----------------------------------+---+-------------------------------+ | Don't care | OFFSET 15..0 |0 +-----------------+-----------------+-----------------+-----------------+ 在 raise_intr（定义在 intr.c 中）中使用。\n   成员 描述     offset_15_0 Offset 低位部分   offset_31_16 Offset 高位部分   present 标识是否有效     为方便从内存中读取，使用 union 结构以及 val0 val1 域简化读写。 此结构体与 AM 中定义的 GateDesc （在 arch/x86-nemu/include/x86.h 中）结构相同。  device/ mmio.h 对内存映射 I/O 编址方式的支持。注意，内存映射 I/O 的读写并不是面向 CPU 的。\n 端口映射I/O把端口号作为I/O指令的一部分, 这种方法很简单, 但同时也是它最大的缺点. 指令集为了兼容已经开发的程序, 是只能添加但不能修改的. 这意味着, 端口映射I/O所能访问的I/O地址空间的大小, 在设计I/O指令的那一刻就已经决定下来了. 所谓I/O地址空间, 其实就是所有能访问的设备的地址的集合. 随着设备越来越多, 功能也越来越复杂, I/O地址空间有限的端口映射I/O已经逐渐不能满足需求了. 有的设备需要让CPU访问一段较大的连续存储空间, 如VGA的显存, 24色加上Alpha通道的1024x768分辨率的显存就需要3MB的编址范围. 于是内存映射I/O(memory-mapped I/O)应运而生. 内存映射I/O这种编址方式非常巧妙, 它是通过不同的物理内存地址给设备编址的. 这种编址方式将一部分物理内存\u0026quot;重定向\u0026quot;到I/O地址空间中, CPU尝试访问这部分物理内存的时候, 实际上最终是访问了相应的I/O设备, CPU却浑然不知. 这样以后, CPU就可以通过普通的访存指令来访问设备. 这也是内存映射I/O得天独厚的好处: 物理内存的地址空间和CPU的位宽都会不断增长, 内存映射I/O从来不需要担心I/O地址空间耗尽的问题. 从原理上来说, 内存映射I/O唯一的缺点就是, CPU无法通过正常渠道直接访问那些被映射到I/O地址空间的物理内存了. 但随着计算机的发展, 内存映射I/O的唯一缺点已经越来越不明显了: 现代计算机都已经是64位计算机, 物理地址线都有48根, 这意味着物理地址空间有256TB这么大, 从里面划出3MB的地址空间给显存, 根本就是不痛不痒. 正因为如此, 内存映射I/O成为了现代计算机主流的I/O编址方式: RISC架构只提供内存映射I/O的编址方式, 而PCI-e, 网卡, x86的APIC等主流设备, 都支持通过内存映射I/O来访问.\n  在 NEMU 中， video memory是唯一使用内存映射 I/O 方式访问的 I/O 空间。\n 定义了类型 mmio_callback_t ，设备定义的回调函数，用以更新设备状态。\ntypedef void(*mmio_callback_t)(paddr_t, int, bool);    函数 描述     void* add_mmio_map(paddr_t, int, mmio_callback_t) 注册一个内存映射 I/O 映射关系，返回该映射关系的 I/O 空间首地址   int is_mmio(paddr_t) 判断一个物理地址是否被映射到 I/O 空间，如果是，返回映射号, 否则返回 -1   uint32_t mmio_read(paddr_t, int, int) 根据端口号和地址读取   void mmio_write(paddr_t, int, uint32_t, int) 根据端口号和地址写入    port-io.h 对端口映射 I/O 编址方式的支持。端口映射I/O(port-mapped I/O)， CPU使用专门的I/O指令对设备进行访问， 并把设备的地址称作端口号。 有了端口号以后， 在I/O指令中给出端口号， 就知道要访问哪一个设备寄存器了。\n定义了类型 pio_callback_t ，设备定义的回调函数，用以更新设备状态。\ntypedef void(*pio_callback_t)(ioaddr_t, int, bool);    函数 描述     void* add_pio_map(paddr_t, int, mmio_callback_t) 注册一个端口映射 I/O 映射关系，返回该映射关系的 I/O 空间首地址   uint32_t pio_read_[l,w,b](ioaddr_t) 面向 CPU 的端口 I/O 读接口   void pio_write_[l,w,b](ioaddr_t, uint32_t) 面向 CPU 的端口 I/O 写接口    monitor/ 监视器部分（也包含 NEMU 执行主循环）。\nexpr.h 定义了计算表达式的值的函数 expr。\nuint32_t expr(char *, bool *); monitor.h 定义了 NEMU 状态 变量 nemu_state，和枚举值 NEMU_STOP, NEMU_RUNNING, NEMU_END, NEMU_ABORT。 定义了 应用程序入口点 ENTRY_START ：\n#define ENTRY_START 0x100000 watchpoint.h 结构体 WP 监视点结构。采用链表结构存储。\n   成员 描述     NO 序号   next 下一监视点指针   expr 监视的表达式   lastVal 表达式最近一次的值    util/ c_op.h 定义了一些形如 c_opname_type 的宏，用于表示基础 C 运算。在 RTL基本指令中的寄存器运算指令中使用。\nsrc/ main.c NEMU 主程序。\n调用 init_monitor （实现在 /src/monitor/monitor.c）初始化监视器，并获取当前是否为批处理模式。 调用 ui_mainloop （实现在 /src/monitor/debug/ui.c）进行指令执行模拟。\ncpu/ reg.c 实现了 include/cpu/reg.h 中的 regsl,regsw,regsb，同时实现寄存器实际定义：变量 cpu。\n 函数 reg_test：测试寄存器结构定义（CPU_state）是否正确。  intr.c 函数 void raise_intr(uint8_t NO, vaddr_t ret_addr) 为 int 指令（在 system.c 中实现）的内部实现。 实现了触发中断或异常后的硬件处理：\n 依次将EFLAGS, CS(代码段寄存器), EIP寄存器（返回地址）的值压入堆栈 根据中断码，从IDTR中读出IDT的首地址 根据异常号在IDT中进行索引, 找到一个门描述符 将门描述符中的offset域组合成目标地址 跳转到目标地址  decode/ 指令译码相关。\ndecode.c 实现了 include/cpu/decode.h 中的译码函数族，函数 operand_write 以及译码信息变量 decoding。 实现了 include/cpu/rtl.h 中的临时寄存器 t0,t1,t2,t3,at 和函数 decoding_set_jmp。\n宏 make_DopHelper 与函数族 decode_op_name #define make_DopHelper(name) void concat(decode_op_, name) (vaddr_t *eip, Operand *op, bool load_val) 译码函数会进一步分解成各种不同操作数的译码的组合，以实现操作数译码的解耦. 操作数译码函数统一通过宏 make_DopHelper 来定义 （decode_op_rm 除外）。 操作数译码函数会把操作数的信息记录在结构体 op 中, 如果操作数在指令中， 就会通过 instr_fetch() 将它们从 eip 所指向的内存位置取出. 为了使操作数译码函数更易于复用， 函数中的 load_val 参数会控制 是否需要将该操作数读出到全局译码信息 decoding 供后续使用. 例如如果一个内存操作数是源操作数, 就需要将这个操作数从内存中读出来供后续执行阶段来使用； 如果它仅仅是一个目的操作数， 就不需要从内存读出它的值了，因为执行这条指令并不需要这个值， 而是将新数据写入相应的内存位置.\ndecode_op_name 函数族命名规则可参见 decode_name 函数族命名规则。\n decode_op_a 是一个特例，其用于将操作数标记为寄存器 ax 或 eax  modrm.c 实现了 include/cpu/decode.h 中的函数 load_addr 和 read_ModR_M。\nexec/ 指令执行相关。\ncc.c 实现了 include/cpu/cc.h 中的函数 rtl_setcc。根据指定关系运算以及条件标志位设置 dest。\nrelop.c 实现了 include/cpu/relop.h 中的函数 interpret_relop，使用 C语言关系运算符实现关系运算。\nall-instr.h 定义了已经实现的指令执行函数（在 exec.c 中使用）。\narith.c 算术运算指令执行函数实现。\n   指令 描述     add    sub    cmp    inc    dec    neg    adc    sbb    mul    imul1 imul 单操作数   imul2 imul 双操作数   imul3 imul 三操作数   div    idiv     control.c 控制指令执行函数实现。\n   指令 描述     jmp 直接跳转   jmp_rm 间接跳转   jcc 条件跳转   call 直接调用   call_rm 间接调用   ret     data-mov.c 数据移动指令执行函数实现。\n   指令 描述     mov    movsx    movzx    lea    push    pop    pusha    popa    leave    cltd    cwtl     logic.c 逻辑运算指令执行函数实现。\n   指令 描述     test    and    xor    or    sar    shl    shr    setcc    not    rol    ror     special.c 特殊指令执行函数实现。\n实现了 include/cpu/rtl.h 中的函数 interpret_rtl_exit。\n   指令 描述     nop    inv 非法指令   nemu_trap 结束执行    prefix.c 定义了执行函数 exec_real。 定义并实现了执行函数 exec_operand_size。\n exec_operand_size 以 16 位操作数执行指令（标记 decoding.is_operand_size_16）  system.c 系统相关指令实现。\n   指令 描述     lidt 设置 IDTR 寄存器   mov_r2cr    mov_cr2r    int 根据中断码进行中断跳转   iret 从中断跳转返回   in 读取端口映射 I/O   out 写入端口映射 I/O     x86 提供了 in 和 out 指令用于访问设备，其中 in 指令用于将设备寄存器中的数据传输到 CPU 寄存器中，out 指令用于将 CPU 寄存器中的数据传送到设备寄存器中  exec.c 指令执行过程核心实现。\n结构体 opcode_entry 译码查找表中元素。\n   成员 描述     DHelper decode 译码函数指针   EHelper execute 执行函数指针   width 指令宽度    数组 opcode_table 译码表。按指令第一个字节索引存放。分两段：单字节指令码和双字节指令码。\nopcode_entry opcode_table [512] = { /* 0x00 */\tEMPTY, EMPTY, EMPTY, EMPTY, /* 0x04 */\tEMPTY, EMPTY, EMPTY, EMPTY, /* 0x08 */\tEMPTY, EMPTY, EMPTY, EMPTY, ... };    宏 描述     IDEXW(id, ex, w) 根据译码函数名，执行函数名，宽度生成 opcode_entry   IDEX(id, ex) 根据译码函数名，执行函数名，以宽度 0 生成 opcode_entry   EXW(ex, w) 根据执行函数名，宽度，生成无译码函数的 opcode_entry   EX(ex) 根据执行函数名，生成宽度为 0 且无译码函数的 opcode_entry   EMPTY 未实现的命令，使用 exec_inv（定义在 special.c 中） 构造 opcode_entry   make_group(name, item0, item1, item2, item3, item4, item5, item6, item7) 用于实现 sub /5 这种根据第二个指令码 /5 区分不同指令的情况。会自动生成一个 exec_name 的统一执行函数，并根据 decoding.ext_opcode 分配到指定执行函数。    #define IDEXW(id, ex, w) {concat(decode_, id), concat(exec_, ex), w} #define IDEX(id, ex) IDEXW(id, ex, 0) #define EXW(ex, w) {NULL, concat(exec_, ex), w} #define EX(ex) EXW(ex, 0) #define EMPTY EX(inv)  #define make_group(name, item0, item1, item2, item3, item4, item5, item6, item7) \\ static opcode_entry concat(opcode_table_, name) [8] = { \\ /* 0x00 */item0, item1, item2, item3, \\ /* 0x04 */item4, item5, item6, item7 \\ }; \\ static make_EHelper(name) { \\ idex(eip, \u0026amp;concat(opcode_table_, name)[decoding.ext_opcode]); \\ } 使用 make_group 宏定义了一些组 gp1 - gp7。对应于 80386 手册附录中组的划分。\n函数 exec_wrapper void exec_wrapper(bool print_flag); 执行下一条指令。\n 首先将当前的 %eip 保存到全局译码信息 decoding 的成员 seq_eip 中 然后将其地址被作为参数送进 exec_real() 函数中  seq 代表顺序的意思, 当代码从 exec_real() 返回时，decoding.seq_eip 将会指向下一条指令的地址.   调用 update_eip 更新 %eip 调试模式下  记录日志（指令内容以及相关信息） 若 print_flag 为真，则显示 decoding.asm_buf    函数 exec_real  首先通过 instr_fetch() 函数(在 include/cpu/exec.h 中定义)进行取指， 得到指令的第一个字节, 将其解释成 opcode 并记录在全局译码信息 decoding 中. 根据 opcode 查阅译码查找表，得到操作数的宽度信息，并通过调用 set_width() 函数将其记录在全局译码信息 decoding 中 调用 idex() 对指令进行进一步的译码和执行  函数 set_width static inline void set_width(int width); 根据指令定义宽度（opcode_entry.width）指定所有操作数宽度（decoding.src.width）。\n 如果定义宽度为 0，则采用译码结果（decoding.is_operand_size_16）  函数 idex /* Instruction Decode and EXecute */ static inline void idex(vaddr_t *eip, opcode_entry *e); 调用译码查找表中的相应的译码函数（若存在）进行操作数的译码，译码过程结束之后, 会调用译码查找表中的相应的执行函数来进行真正的执行操作。\n函数 update_eip 根据当前指令是否为跳转指令，更新 %eip。\nstatic inline void update_eip(void) { if (decoding.is_jmp) { decoding.is_jmp = 0; } else { cpu.eip = decoding.seq_eip; } } memory/ memory.c 定义了宏 PMEM_SIZE 指定物理内存大小。 实现了 include/memory/memory.h 中的函数 paddr_read，paddr_write，vaddr_read，vaddr_write。\n vaddr_read, vaddr_write 的实现调用了 paddr_read 和 paddr_write。 为支持内存映射 I/O，paddr_read, paddr_write 的实现加入了对内存映射 I/O 的判断。  device/ io/ mmio.c 定义了宏 MMIO_SPACE_MAX 指定内存映射空间大小。 定义了结构体 MMIO_t 保存 MMIO 信息。\n实现了 include/device/mmio.h 中的函数。\n 在 mmio_read 和 mmio_write 中，调用了回调函数。  port-io.c 定义了宏 PORT_IO_SPACE_MAX 指定内存映射空间大小。 定义了结构体 PIO_t 保存 MMIO 信息。\n实现了 include/device/port-io.h 中的函数。\n 在 pio_read_common 和 pio_write_common 中，调用了回调函数。 基于 pio_read_common 和 pio_write_common 实现了不同的端口读写函数  device.c 提供初始化和控制设备的一些函数。含有和SDL库相关的代码，NEMU使用SDL库来实现设备的模拟。\n   宏 描述     TIMER_HZ 时钟频率   VGA_HZ VGA 刷新频率    函数 init_device 用于初始化设备：串口， 时钟， 键盘， VGA四种设备。 其中在初始化 VGA 时还会进行一些和SDL相关的初始化工作， 包括创建窗口， 设置显示模式等. 最后还会注册一个100Hz的定时器， 每隔0.01秒就会调用一次 device_update() 函数。\n函数 device_update 主要进行一些设备的模拟操作, 包括以50Hz的频率刷新屏幕, 以及检测是否有按键按下/释放.\n需要说明的是， 代码中注册的定时器是虚拟定时器， 它只会在 NEMU 处于用户态的时候进行计时： 如果 NEMU 在 ui_mainloop() 中等待用户输入， 定时器将不会计时; 如果 NEMU 进行大量的输出， 定时器的计时将会变得缓慢. 因此除非你在进行调试， 否则尽量避免大量输出的情况， 从而影响定时器的工作。\nserial.c 串口设备。 模拟了串口的功能。 其大部分功能也被简化，只保留了数据寄存器和状态寄存器。串口初始化时会分别注册 0x3F8 和 0x3FC 处长度为1个字节的端口，分别作为数据寄存器和状态寄存器。由于NEMU串行模拟计算机系统的工作，串口的状态寄存器可以一直处于空闲状态; 每当CPU往数据寄存器中写入数据时，串口会将数据传送到主机的标准输出。\n   函数/宏 描述     init_serial() 初始化设备   SERIAL_PORT=0x3F8 端口 I/O 地址    timer.c 时钟设备。 模拟了i8253计时器的功能. 计时器的大部分功能都被简化, 只保留了\u0026quot;发起时钟中断\u0026quot;的功能. 同时添加了一个自定义的RTC(Real Time Clock), 初始化时将会注册0x48处的端口作为RTC寄存器, CPU可以通过I/O指令访问这一寄存器, 获得当前时间(单位是ms).\n   函数/宏 描述     init_timer() 初始化设备   RTC_PORT=0x48 端口 I/O 地址    keyboard.c 键盘设备。 模拟了i8042通用设备接口芯片的功能. 其大部分功能也被简化, 只保留了键盘接口. i8042初始化时会注册 0x60 处的端口（长度为 4）作为数据寄存器. 每当用户敲下/释放按键时, 将会把相应的键盘码放入数据寄存器, CPU可以通过端口I/O访问数据寄存器, 获得键盘码; 当无按键可获取时, 将会返回 _KEY_NONE . 在AM中, 我们约定通码的值为 断码 | KEYDOWN_MASK.\n   函数/宏 描述     init_i8042() 初始化设备   I8042_DATA_PORT=0x60 端口 I/O 地址   KEYDOWN_MASK=0x8000 通码 MASK   KEY_QUEUE_LEN 键队列长度    vga.c VGA 设备。 模拟了VGA的功能. VGA初始化时注册了从 0x40000 开始的一段用于映射到video memory的物理内存. 在NEMU中, video memory是唯一使用内存映射I/O方式访问的I/O空间. 代码只模拟了400x300x32的图形模式, 一个像素占32个bit的存储空间, R(red), G(green), B(blue), A(alpha)各占8 bit, 其中VGA不使用alpha的信息。VGA 设备同时注册了位于 0x100 的长度为 4 的端口存储屏幕大小信息。\n   函数/宏 描述     init_vga() 初始化设备   SCREEN_PORT=0x100 端口 I/O 地址   VMEM=0x40000 内存映射 I/O 地址   SCREEN_H 屏幕高度   SCREEN_W 屏幕宽度    monitor/ 监视器部分实现（也包含 NEMU 执行主循环）。\nmonitor.c 函数 init_monitor 初始化监视器并启动（用于 main.c/main 中）。\n 解析并处理命令行参数 初始化日志文件 寄存器测试（调用 reg_test()，实现在 src/cpu/reg.c） 加载程序镜像（根据命令行参数，如果为空，则调用 load_default_img() 加载默认镜像） 启动环境（调用 restart()，初始化应用程序入口点，寄存器值） 编译正则表达式（调用 init_regex()，实现在 src/monitor/debug/expr.c） 初始化监视点池（调用 init_wp_pool()，实现在 src/monitor/debug/watchpoint.c） 初始化设备（调用 init_device()，实现在 src/device/device.c） 初始化差异测试（调用 init_difftest()，实现在 src/monitor/diff-test.c） 显示欢迎界面 返回是否为批处理模式（根据命令行参数）  注：\n 命令行参数  [img_file] 指定应用程序镜像文件 -b 批处理模式 -l log_file 指定日志文件 -d 指定 Diff-Test 镜像文件    cpu-exec.c 函数 cpu_exec void cpu_exec(uint64_t n); 模拟 CPU 工作。\n 判断 NEMU 状态（查看 nemu_state，定义在 include/monitor/monitor.h） 若指令数 n 小于 MAX_INSTR_TO_PRINT （默认为 10），则打印每条指令。 开始执行指令  调用 exec_wrapper 执行下一条指令（传入是否打印指令标记） 检查监视点状态是否有更新 更新设备信息 判断 NEMU 状态（查看 nemu_state），决定是否退出   执行完 n 条指令后，将 NEMU 状态置为结束（NEMU_END）  注：\n 执行某条命令后  若 NEMU 状态为结束（NEMU_END），则检查程序返回值（cpu.eax）是否为 0（是否正常退出）。并输出 HIT GOOD TRAP（正常退出） 或 HIT BAD TRAP（非正常退出）。    debug/ watchpoint.c 定义了监视点内存池及其相关的函数。\n wp_pool 监视点池 head 使用中的监视点链表头指针 free_ 监视点池中未使用的监视点链表头指针     函数 描述     init_wp_pool() 初始化监视点内存池   clearWP(wp) 清空某监视点的下一项指针   WP *getHeadWP() 获取 head   WP *createWP() 申请使用一个新监视点（内部调用 new_wp() 并更新链表信息）   removeWP(no) 删除指定编号的监视点   WP *new_wp() （私有）从内存池中获取下一个能使用的监视点，并作一定预处理   free_wp(wp) （私有）释放一个监视点    expr.c 实现了 expr.h/expr 函数，实现表达式解析和求值。\n常量  PRI_NEG 取负运算优先级 PRI_POINT 解引用运算优先级 形如 TK_TYPE 的 Token 类型枚举  数组 rules 规定了使用正则表达式解析 Token 的规则。\n   成员 描述     regex 正则表达式字符串   token_type 对应 Token 类型，可用 TK_TYPE 枚举或字符（如 +）表示   opPri 运算符 Token 的优先级    数组 re 根据 rules 编译后的正则表达式。\n函数 init_regex 根据 rules 编译到 re\n结构体 Token 识别后的 Token.\n   成员 描述     type Token 类型，可用 TK_TYPE 枚举或字符（如 +）表示   isOp 标记此 Token 是否是运算符   isValue 标记此 Token 是否是值   str Token 的原始字符串   data 值类型的实际数据   priority 运算符的优先级     isOp 和 isValue 多用于区分特殊单目运算符，如解引用和取负 data 多存储经过预处理的数据，如转换后的整数   解析后的 Token 列表存储在数组 tokens 中。 nr_token 指示 token 有效长度。\n 函数 make_token static bool make_token(char *e) 根据字符串解析 Token 列表，返回是否解析成功。\n实现思路：使用 re 依次尝试每一种匹配，直到遇到第一个成功匹配，根据其规则的 token_type 生成 Token，存入 token。\n 函数 toInteger ：以指定进制完成字符串到数的转换，用于 十进制，二进制，八进制，十六进制 数的解析。  static uint32_t toInteger(char *s, uint32_t base) 函数 evalWithToken uint32_t evalWithToken(int l, int r, bool * success) 求解 tokens[l..r] 中的表达式的值。\n实现思路：单 Token 特殊处理，然后处理外围括号情况，然后确定最后计算的运算符，分割成 left 和 right 两部分，然后递归解决，最后合并，\n 函数 checkExtraP 判断 tokens[l..r] 是否外围为括号且括号匹配正常。 函数 getReg 根据寄存器名获取寄存器值，使用了 regMap 数组 regMap 标识寄存器名与对应的偏移量（cpu.gpr）  函数 expr 对 expr.h/expr 的实现，调用了 make_token 和 evalWithToken。\nui.c 监视器 CUI 部分。\n函数族 fc2color 控制台字体颜色控制。\n   函数 描述     fc2red 前景色设为红色   fc2green 前景色设为绿色   fc2yellow 前景色设为黄色   fc2blue 前景色设为蓝色   fc2purple 前景色设为紫色   csClear 清除所有控制台设置    函数族 cmd_item 不同命令的实现。\n   函数 描述     cmd_help 获取帮助   cmd_q 退出   cmd_c 继续执行（调用 cpu_exec(-1)，实现在 src/monitor/cpu-exec.c）   cmd_si 执行单步指令   cmd_info name 查看信息   cmd_x N expr 显示地址从 expr 的值开始的 N 个字节值   cmd_p expr 计算表达式的值   cmd_w expr 新建监视点，监视表达式为 expr   cmd_d no 删除指定编号的监视点     cmd_info  r 打印所有寄存器信息 w 打印所有监视点信息    数组 cmd_table    成员 描述     name 命令名（用于识别命令）   description 命令描述（用于帮助列表）   handler 命令实现函数指针    函数 ui_mainloop void ui_mainloop(int is_batch_mode); NEMU 以及其 CUI 主循环，不断读取命令，并执行。\n 如果是批处理模式（is_batch_mode 为真），则直接执行应用程序，不监听用户命令。  diff-test/ 差异测试实现。\n 如果有一种方法能够表达指令的正确行为, 我们就可以基于这种方法来进行类似assert()的检查了。那么, 究竟什么地方表达了指令的正确行为呢? 最直接的, 当然就是i386手册了, 但是我们恰恰就是根据i386手册中的指令行为来在NEMU中实现指令的, 同一套方法不能既用于实现也用于检查. 如果有一个i386手册的参考实现就好了. 嘿! 我们用的真机不就是根据i386手册实现出来的吗? 我们让在NEMU中执行的每条指令也在真机中执行一次, 然后对比NEMU和真机的状态, 如果NEMU和真机的状态不一致, 我们就捕捉到error了! 这实际上是一种非常奏效的测试方法, 在软件测试领域称为differential testing(后续简称DiffTest). 我们刚才提到了\u0026quot;状态\u0026quot;, 那\u0026quot;状态\u0026quot;具体指的是什么呢? 我们在PA1中已经认识到, 计算机就是一个数字电路. 那么, \u0026ldquo;计算机的状态\u0026quot;就恰恰是那些时序逻辑部件的状态, 也就是寄存器和内存的值. 其实仔细思考一下, 计算机执行指令, 就是修改这些时序逻辑部件的状态的过程. 要检查指令的实现是否正确, 只要检查这些时序逻辑部件中的值是否一致就可以了! DiffTest可以非常及时地捕捉到error, 第一次发现NEMU的寄存器或内存的值与真机不一样的时候, 就是因为当时执行的指令实现有误导致的. 这时候其实离error非常接近, 防止了error进一步传播的同时, 要回溯找到fault也容易得多. 多么美妙的功能啊! 背后还蕴含着计算机本质的深刻原理! 但很遗憾, 不要忘记了, 真机上是运行了操作系统GNU/Linux的, 而NEMU中的测试程序是运行在x86-nemu上的, 我们无法在native中运行编译到x86-nemu的AM程序. 所以, 我们需要的不仅是一个i386手册的正确实现, 而且需要在上面能正确运行x86-nemu的AM程序. 事实上, QEMU就是一个不错的参考实现. 它是一个虚拟出来的完整的x86计算机系统, 而NEMU的目标只是虚拟出x86的一个子集, 能在NEMU上运行的程序, 自然也能在QEMU上运行. 因此, 为了通过DiffTest的方法测试NEMU实现的正确性, 我们让NEMU和QEMU逐条指令地执行同一个客户程序. 双方每执行完一条指令, 就检查各自的寄存器和内存的状态, 如果发现状态不一致, 就马上报告错误, 停止客户程序的执行.\n diff-test.h 定义了宏 DIFFTEST_REG_SIZE 规定访问的寄存器大小。\n#define DIFFTEST_REG_SIZE (sizeof(uint32_t) * 9) // GRPs + EIP ref.c 在 DUT(Design Under Test, 测试对象)和 REF(Reference, 参考实现) 之间定义了一组 API。\n// 从DUT host memory的 src 处拷贝 n 字节到REF guest memory的 dest 处 void difftest_memcpy_from_dut(paddr_t dest, void *src, size_t n); // 获取REF的寄存器状态到 r void difftest_getregs(void *r); // 设置REF的寄存器状态为 r void difftest_setregs(const void *r); // 让REF执行 n 条指令 void difftest_exec(uint64_t n); // 初始化REF的DiffTest功能 void difftest_init();  其中寄存器状态 r 要求寄存器的值按照某种顺序排列，若未按要求顺序排列， difftest_getregs() 和 difftest_setregs() 的行为是未定义的. REF 需要实现这些 API，DUT会使用这些 API 来进行 DiffTest 。  diff-test.c 定义了变量 is_skip_ref，is_skip_dut 用于标记忽视一些指令处的比对。（可结合 difftest_step 实现） 定义了函数 difftest_skip_ref，difftest_skip_dut 标记上述变量。\n函数 init_difftest 初始化 Diff-Test。\n 打开动态库文件 ref_so_file 从动态库中分别读取上述 API 的符号 对 REF 的 DIffTest功能进行初始化，此时会启动 REF，代码还会对 REF 的状态进行一些初始化工作，REF 运行在后台，因此将看不到 REF 的任何输出 将 DUT 的 guest memory 拷贝到 REF 中 将 DUT 的寄存器状态拷贝到 REF 中  函数 difftest_step 用于逐条指令执行后的状态对比。它会在 exec_wrapper() 的最后被调用。在这里读取 REF 的寄存器并与 NEMU 寄存器状态比对。\nmisc/ logo.c 定义了字符数组 logo 存储 i386 Manual Logo。用于 inv 指令（位于 special.c 中）。\ntools/ gen-expr.c 生成 C 表达式，用于测试表达式求值功能。\nqemu-diff QEMU 实现，用于 Diff-Test。编译成动态库 qemu-so，传入 nemu 的 -d 参数中。\n引用资料  ICS2018 PA 讲义  ","date":"2018-10-05T19:30:22+08:00","permalink":"https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nemu/","title":"NJU ICS Programming Assignment 代码分析 - NEMU"},{"content":"基本信息  官网 介绍：一种支持多种语言的调试器。  基础知识 使用 gdb 调试 C 程序时，建议在程序编译时加入调试符号信息 -g 选项。\ngdb a.out 可以使用 --tui 选项进入终端用户界面图形化调试。Ctrl + X + A 切换 TUI 和传统模式。\n   命令 描述     help h 帮助   quit q 退出    查看程序 list 或 l：查看源代码。\nlist -5 # show line 5 list func # show func disassemble 查看汇编码。\n/m # 源码和汇编一起排列 /r # 显示16进制代码 disassemble /m main 布局 layout 命令用于分割窗口，可以一边查看代码，一边测试。\n layout src 显示源代码窗口 layout asm 显示汇编窗口 layout regs 显示源代码/汇编和寄存器窗口 layout split 显示源代码和汇编窗口 layout next 显示下一个layout layout prev 显示上一个layout Ctrl + L 刷新窗口 Ctrl + x 再按1 单窗口模式，显示一个窗口 Ctrl + x 再按2 双窗口模式，显示两个窗口 Ctrl + x 再按a 回到传统模式，即退出layout，回到执行layout之前的调试窗口。  运行程序    命令 描述     run r 重新开始运行文件，可以带参数   start 单步执行，运行程序，停在第一执行语句   next n 单步调试（逐过程，函数直接执行）   step s 单步调试（逐语句：跳入自定义函数内部执行）   nexti ni 单步调试（逐指令，即汇编语句，函数直接执行）   stepi si 单步调试（逐指令，即汇编语句跳入自定义函数内部执行）   continue c 继续运行   finish 结束当前函数，返回到函数调用点    处理运行时信息 查看变量 print 或 p 用于查看变量（表达式），也可以查看寄存器的值（$eax $ebx）\ninfo 或 i 查看函数内部局部变量的数值。\n设置变量 set 设置变量的值。\n查看内存 x 命令用于查看内存。\nx/20xw \u0026lt;addr\u0026gt; # 显示20个单元，16进制，4字节每单元 x/i 查看指令。$pc 指向当前程序运行地址\nx/15i main 查看函数调用栈 backtrace 或 bt 查看函数的调用的栈帧和层级关系。\n切换函数栈帧 frame 或 f 切换函数的栈帧。\n追踪变量 display 追踪查看具体变量值。 undisplay 取消追踪观察变量。\n监视变量 watch 被设置观察点的变量（表达式）发生修改时，打印显示。 info watch 显示观察点\n断点 设置断点 break 或 b 设置断点。\nbreak 10 # at line 10 break *\u0026lt;addr\u0026gt; # at the instruction at addr break func # at function enable breakpoints 启用断点。 disable breakpoints 禁用断点。\n查看断点 info breakpoints 查看当前设置的所有断点\n删除断点 delete breakpoints \u0026lt;num\u0026gt; 删除第num个断点,简写 d\n参考资料 暂无\n","date":"2018-09-27T18:58:19+08:00","permalink":"https://stardustdl.github.io/posts/tools/gdb/","title":"GDB - The GNU Project Debugger"},{"content":"基本信息  官网 介绍：Powershell 是一个执行系统和应用程序管理自动化的命令行脚本环境。需要.NET环境的支持，同时支持.NET对象。Powershell 中每个内容都是对象，.NET 中的对象相关操作可以在 Powershell 中调用。  基础知识 快捷键    快捷键 功能     ALT+F7 清除命令的历史记录   PgUp PgDn 显示当前会话的第一个命令和最后一个命令   Enter 执行当前命令   End 将光标移至当前命令的末尾   Del 从右开始删除输入的命令字符   Esc 清空当前命令行   F2 自动补充历史命令至指定字符   F4 删除命令行至光标右边指定字符处   F7 对话框显示命令行历史记录   F8 检索包含指定字符的命令行历史记录   F9 根据命令行的历史记录编号选择命令，历史记录编号可以通过F7查看   左/右方向键 左右移动光标   上/下方向键 切换命令行的历史记录   Home 光标移至命令行最左端   Backspace 从右删除命令行字符   Ctrl+C 取消正在执行的命令   Ctrl+左/右方向键 在单词之间移动光标   Ctrl+Home 删除光标最左端的所有字符   Tab 自动补齐命令或者文件名    管道和重定向 管道：把上一条命令的输出作为下一条命令的输入。使用字符 |。 传统的Cmd管道是基于文本的，但是Powershell是基于对象。\n两个管道模式：\n 顺序模式（较慢）：在顺序模式中管道中同一时间只执行一条命令，只有当前一条命令的所有执行完毕，才会把所有结果交付给下一条 命令。这种模式速度慢并且耗内存，因为必须需要很多次分配空间存储中间结果。 流模式（较快）：流模式会立即执行所有命令，同一时间可能在执行多条命令。前一条命令可能会产生多个结果，但是一旦产生其中一个结果，就会立即交付给下一条命令处理。这样的流模式节省比较节省内-存，可能管道的某个任务还在执行，但是已经有部分结果输出了。减少了中间结果的保存。  重定向：把命令的输出保存到文件中，\u0026gt; 为覆盖，\u0026gt;\u0026gt; 追加。\n数学运算 Powershell 支持基本的数学运算，也能自动识别计算机容量单位，包括KB，MB，GB，TB，PB。通过使用 .NET 中的数学库可以使用更多的数学函数。\n执行外部命令 调用外部程序。类似传统 shell。\nCmdlets cmdlets是Powershell的内部命令。每个命令有一个动词和名词组成，命令的作用一目了然。 可以使用 Get-Command 获取所有命令，使用 Get-Help 获取命令帮助。\n常用命令：\n   命令 别名     Get-Location pwd   Set-Location cd   Get-ChildrenItem ls dir   Invoke-Item    Remove-Item rm del   Move-Item mv move   Copy-Item cp copy   Get-Item    Get-Content cat   Invoke-WebRequest wget curl   Get-Process ps   Stop-Process kill   Start-Process start   Clear-Host cls clear   Write-Output echo   Compare-Object diff    (TODO)\n别名  Get-Alias Set-Alias Export-Alias Import-Alias  变量 变量名均是以美元符 $ 开始，剩余字符可以是数字、字母、下划线的任意字符，并且powershell变量名大小写不敏感。某些特殊的字符在powershell中有特殊的用途，一般不推荐使用这些字符作为变量名。当然你硬要使用，请把整个变量名后缀用花括号括起来。 Powershell将变量的相关信息的记录存放在名为 variable: 的驱动中。如果要查看所有定义的变量，可以直接遍历 variable:\n$a = 10 $b = 4 $result = $a * $b $a,$b = $b,$a  Clear-Variable Get-Variable New-Variable Remove-Variable Set-Variable  Powershell 自动化变量 是那些一旦打开Powershell就会自动加载的变量。这些变量一般存放的内容包括\n 用户信息：例如用户的根目录$home 配置信息:例如powershell控制台的大小，颜色，背景等。 运行时信息：例如一个函数由谁调用，一个脚本运行的目录等。  数组 创建数组可以使用逗号，或使用完整表示 @()。\n$nums = 2,0,1,2 $nums = 1..5 $array = 1,\u0026#34;2012世界末日\u0026#34;,([System.Guid]::NewGuid()),(get-date) $a=@() # empty $a=,\u0026#34;moss\u0026#34; # one element 数组的元素可以使用索引寻址，第一个元素的索引为0，第i个元素的索引为i-1，最后一个元素的索引为Count-1，但是Powershell为了使用方便，直接可以将 -1 作为最后的一个元素的索引。\n$books[0] $books[-1] $result[0,3,5,12] # multi-element $books[($books.Count)..0] # reverse $books += \u0026#34;元素4\u0026#34; # append $num = $num[0..1]+$num[3] # remove $num[2] Powershell数组一般具有多态性，如果你不指定元素的具体类型，解释器会自动选择合适的类型存储每个元素。如果要统一限制所有元素的类型，可是使用类型名和一对方括号作为数组变量的类型。这样每当赋值时，会自动类型检查。如果目标数据类型不能转换成功，就会抛出一个异常。\n[int[]] $nums=@() 哈希表 使用 @{} 创建哈希表（类似 .NET 中 Dictionary）。\n$stu = @{ Name = \u0026#34;小明\u0026#34;;Age=\u0026#34;12\u0026#34;;sex=\u0026#34;男\u0026#34; } 管道应用 (TODO)\n对象 (TODO)\n分支 (TODO)\n循环 (TODO)\n函数 (TODO)\n脚本 (TODO)\n模块 (TODO)\n文本匹配 (TODO)\n文件系统 (TODO)\n工作流 (TODO)\n参考资料  PowerShell Documentation PowerShell 教程  ","date":"2018-09-27T18:40:02+08:00","image":"https://devblogs.microsoft.com/powershell/wp-content/uploads/sites/30/2018/09/Powershell_256.png","permalink":"https://stardustdl.github.io/posts/tools/powershell/","title":"PowerShell"},{"content":"基本信息  官网 介绍：一个分布式版本管理系统。  特点 Git 更像是把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个快照流。Git 更像是一个小型的文件系统，提供了许多以此为基础构建的超强工具。 在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。 Git 中所有数据在存储前都计算校验和，然后以校验和来引用。这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。Git 用以计算校验和的机制叫做 SHA-1 散列。实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 你执行的 Git 操作，几乎只往 Git 数据库中增加数据。很难让 Git 执行任何不可逆操作，或者让它以任何方式清 除数据。同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。\n基础知识 Git 有三种状态，你的文件可能处 于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。\n 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。  由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。\n Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作索引，不过一般说法还是叫暂存区域。  基本的 Git 工作流程如下：\n 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。  如果 Git 目录中保存着的特定版本文件，就属于已提交状态。如果作了修改并已放入暂存区域，就属于已暂存状 态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。\n有三种方法可以找到 Git 命令的使用手册：\ngit help \u0026lt;verb\u0026gt; git \u0026lt;verb\u0026gt; --help man git-\u0026lt;verb\u0026gt; 配置 使用 git config 命令。\n控制 Git 外观和行为的配置变量存储在三个不同的位置（每一个级别覆盖上一级别的配置）：\n /etc/gitconfig 包含系统上每一个用户及他们仓库的通用配置。通过 --system 访问和修改。 ~/.gitconfig 或 ~/.config/git/config 只针对当前用户。通过 --global 访问和修改。 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。  使用 --list 选项查看所有配置。使用 git config \u0026lt;key\u0026gt; 查看某一项配置，使用 git config \u0026lt;key\u0026gt; \u0026lt;value\u0026gt; 修改某一项配置，\ngit config --global user.name \u0026#34;John Doe\u0026#34; git config --global user.email johndoe@example.com    设置项 描述     user.name 用户名   user.email 邮箱   core.editor 默认文本编辑器    当安装完 Git 应该做的第一件事就是设置你的用户名称与邮件地址。这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改。\n指定忽略文件 修改项目根目录下的 .gitignore 文件，列出要忽略的文件模式。\n文件 .gitignore 的格式规范如下：\n 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。  Github 上提供的一些 .gitignore 文件：https://github.com/github/gitignore\n别名 git config --global alias.\u0026lt;newname\u0026gt; \u0026lt;originname\u0026gt; git config --global alias.visual \u0026#39;!gitk\u0026#39; Git 只是简单地将别名替换为对应的命令。然而，你可能想要执行外部命令，而不是一个 Git 子命令。如果是那样的话，可以在命令前面加入 ! 符号。\n获取仓库 在现有目录中初始化仓库 git init 克隆现有的仓库 git clone [url] git clone https://github.com/libgit2/libgit2 Git 支持多种数据传输协议。上面的例子使用的是 https:// 协议，不过你也可以使用 git:// 协议或者使用 SSH 传输协议，比如 user@server:path/to/repo.git \n查看状态 git status    选项 描述     -s -short 更为紧凑的格式输出    关于紧凑格式输出中，文件名前标记的解释：\n   标记 描述     M  被修改了并放入了暂存区    M 被修改了但是还没放入暂存区   ?? 新添加的未跟踪文件   A  新添加到暂存区中的文件    查看已暂存和未暂存的修改 git diff 使用 diff 命令查看具体修改内容。 默认此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。\n   选项 描述     --cached --staged 比较已暂存的内容和仓库中的内容    可以使用 git difftool 命令来用 Araxis ，emerge 或 vimdiff 等软件输出 diff 分析结果。使用 git difftool --tool-help 命令来看你的系统支持哪些 Git Diff 插件。\n查看历史 git log git log --pretty=format:\u0026#34;%h - %an, %ar : %s\u0026#34; git log --since=2.weeks git log -Sfunction_name    选项 描述     --decorate 查看各个分支当前所指的对象   -p 按补丁格式显示每个更新之间的差异   --stat 显示每次更新的文件修改统计信息   --shortstat 只显示 --stat 中最后的行数修改添加移除统计   --name-only 仅在提交信息后显示已修改的文件清单   --name-status 显示新增、修改、删除的文件清单   --abbrev-commit 仅显示 SHA-1 的前几个字符，而非所有的 40 个字符   --relative-date 使用较短的相对时间显示   --graph 形象地展示分支、合并历史   --pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format（后跟指定格式）   --oneline    --all    -\u0026lt;num\u0026gt; 仅显示最近的几次提交   --since=2.weeks --after 列出所有最近两周内的提交   --until=\u0026lt;time\u0026gt; --before 列出所有到某时间为止的提交   --author 仅显示指定作者的提交   --committer 仅显示指定提交者相关的提交   --grep 搜索提交说明中的关键字   --all-match 仅显示同时满足所有指定选项的提交（默认是或关系）   -S 列出那些添加或移除了某些字符串的提交   \u0026lt;path\u0026gt; 只显示某些路径的历史提交（因为是放在最后位置上的选项，所以用两个短划线（--）隔开之前的选项和后面限定的路径名。 ）    关于 git log --pretty=format 常用的选项见 参考资料\n提交 工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。\n跟踪新文件\u0026amp;暂存已修改文件 git add \u0026lt;filename\u0026gt; git add 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。 add 是个多功能命令，可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中” （暂存区）更合适。\n移除文件 git rm 如果只是简单地从工作目录中手工删除文件，会将工作区中文件状态置为已删除，然后再运行 git rm 记录此次移除文件的操作。这样下一次提交时，该文件就不再纳入版本管理了。\n   选项 描述     -f 强制移除文件（如果删除之前修改过并且已经放到暂存区域）   --cached 把文件从 Git 仓库中删除，但保留在当前工作目录中    移动文件 git mv file_from file_to 其实，运行 git mv README.md README 就相当于运行了下面三条命令：\nmv README.md README git rm README.md git add README 取消暂存的文件 git reset HEAD \u0026lt;filename\u0026gt; 撤消对文件的修改 git checkout -- [file] 将文件还原成上次提交时的样子。\n提交更新 git commit 使用 commit 命令将暂存内容提交到仓库。 这种方式会启动文本编辑器以便输入本次提交的说明。文本编辑器中会以注释行的方式显示一些与提交相关的信息，默认显示 git status 的信息。退出编辑器时，Git 会丢掉注释行，用你输入提交附带信息生成一次提交。\n   选项 描述     -v 将 diff 输出包含到提交注释信息中   -m 直接指定提交信息   -a 自动把所有已经跟踪过的文件暂存起来一并提交   --amend 尝试重新提交    标签 Git 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点。 Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。\n 一个轻量标签很像一个不会改变的分支 - 它只是一个特定提交的引用。 附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息；并且可以使用 GNU Privacy Guard （GPG）签名与验证。  通常建议创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的 标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。\n列出标签 git tag 创建标签 # annotated tag git tag -a [tag name] [-m [info]] # lightweight tag git tag [tag name] 默认情况下，tag 命令给最近的提交打标签。如果要指定提交，需要在命令的末尾指定提交的校验和（或部分校验和）。\ngit tag -a v1.2 9fceb02 共享标签 git push origin [tagname] 默认情况下，git push 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。\n检出标签 在 Git 中你并不能真的检出一个标签，因为它们并不能像分支一样来回移动。如果你想要工作目录与仓库中特定 的标签版本完全一样，可以使用 git checkout -b [branchname] [tagname] 在特定的标签上创建一个新分支。\n分支 创建分支\u0026amp;删除分支 git branch [branchname] [from branchname] 在 Git 中，使用一个指针 HEAD ，指向当前所在的本地分支（可看成别名）。\n   选项 描述     -v 查看每一个分支的最后一次提交   -vv 查看设置的所有跟踪分支和时间关系等信息   --merged 只显示已经合并到当前分支的分支   --no-merged 只显示未合并到当前分支的分支   -d 删除分支（此分支必须已被合并）   -D 强制删除分支   -u --set-upstream-to 修改跟踪的上游分支    设置当前的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支，你可以在任意时间使用 -u 或 --set-upstream-to 选项运行 git branch 来显式地设置。\n检出分支 git checkout [branchname]    选项 描述     -b 创建新分支并检出   --track 创建跟踪远程分支的本地分支    合并分支 git merge [branchname] 将指定分支合并到当前分支。\n处理冲突 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。此时 Git 做了合并，但是没有自动地创建一个新的合并提交。Git 会暂停下来，等待你去解决合并产生的冲突。 你可以在合并冲突后的任意时刻使用 git status 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。在你解决了所有文件里的冲突之后，对每个文件使用 git add 命令来将其标记为冲突已解决。一旦暂存这 些原本有冲突的文件，Git 就会将它们标记为冲突已解决。 如果你想使用图形化工具来解决冲突，可以运行 git mergetool。\n远程分支 远程跟踪分支是远程分支状态的引用。它们是你不能移动的本地引用，当你做任何网络通信操作时，它们会自动移动。远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签。它们以 (remote)/(branch) 形式命名。\n变基 参见官方文档。\n远程仓库 查看远程仓库 git remote    选项 描述     -v 显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL    git remote show [remote-name] show 命令会列出远程仓库的 URL 与跟踪分支的信息。\n远程引用是对远程仓库的引用（指针），包括分支、标签等等。你可以通过 git ls-remote (remote) 来显式地获得远程引用的完整列表，或者通过 git remote show (remote) 获得远程分支的更多信息。\n添加远程仓库 git remote add \u0026lt;shortname\u0026gt; \u0026lt;url\u0026gt; 远程仓库的移除与重命名 git remote rename [oldname] [newname] git remote rm [name] 从远程仓库中抓取与拉取 git fetch [remote-name]    选项 描述     --all 抓取所有远程库的数据    fetch 会访问远程仓库，从中拉取所有你还没有的数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。它并不会自动合并或修改你当前的工作。当准备好时你必须手动将其合并入你的工 作。 如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 可以运行 git merge origin/[branchname] 将这些工作合并到当前所在的分支。如果想要在自己的新分支上工作，可以将其建立在远程跟踪分支之上。\ngit checkout -b [branchname] origin/[branchname] git checkout --track origin/[branchname] 推送到远程仓库 git push [remote-name] [branchname] git push [remote-name] [tagname]    选项 描述     --tags 把所有不在远程仓库服务器上的标签全部推送   --delete [branchname] 删除远程分支    举例：\ngit push origin serverfix git push origin serverfix:serverfix 这里有些工作被简化了。Git 自动将 serverfix 分支名字展开为 refs/heads/serverfix:refs/heads/serverfix，那意味着，“推送本地的 serverfix 分支来更新远程仓库上的 serverfix 分支。”\n参考资料  Git Documentation Git Book  ","date":"2018-09-26T18:58:19+08:00","image":"https://git-scm.com/images/logo@2x.png","permalink":"https://stardustdl.github.io/posts/tools/git/","title":"Git"},{"content":"基本信息  官网 介绍：GCC，The GNU Compiler Collection，包含多种语言（C, C++, Objective-C, Fortran, Ada, Go) 的前端编译器。携带了相关的库。  安装 可以通过 build-essential 包安装。\napt install build-essential C/C++  C 语言：使用 gcc 或 g++ 编译。对于 C 语言文件，g++ 内部调用 gcc。 C++ 语言：使用 g++ 编译 ，由于 C++ 与 C 库文件命名不同，在编译链接过程中 g++ 能找到合适的库文件，而 gcc 不能。  编译分4个阶段：预处理、生成汇编码、编译（生成机器码）、链接\n相关编译指令，参数：\n   参数名 描述     \u0026lt;source names\u0026gt; 指定编译源文件   -E/e \u0026lt;source names\u0026gt; 只执行预处理操作（生成 .i 文件）   -S/s \u0026lt;.i file names / source names\u0026gt; 只执行到生成汇编码（生成 .s 文件）   -c \u0026lt;.s file names / source names\u0026gt; 只执行到编译（生成机器码）（生成 .o 文件）   \u0026lt;.o files\u0026gt; 无选项链接   --save-temps 生成编译过程的中间结果文件   -o \u0026lt;output name\u0026gt; 指定输出文件名   -Og -O1 -O2 -O3 指定优化级别   -g 开启调试开关（编译时生成debug有关的程序信息，供gdb使用）   -Wall 显示编译警告   -Wextra 输出 -Wall 不包含的警告等   -Werror 将警告视为错误输出   -D \u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; 加入宏定义，若不指定 value ，则默认为1   -std=\u0026lt;std id\u0026gt; 指定编译使用的语言标准   -fstack-protector\\-fno-stack-protector 是否开启堆栈保护，这里的保护是在返回地址之前加入一个验证值来确保返回地址不被破坏   -z execstack 启用可执行栈，默认是禁用的    关于 -std 中的语言标准：\n C 语言  c90/iso9899:1990 C89/C90 iso9899:199409 C94/C95 c99/iso9899:1999 C99 c11/iso9899:2011 C11 gnu90,gnu99,gnu11 在标准基础上加入 GNU 扩展   C++ 语言  c++98/c++03 C++98 c++11 C++11 c++14 C++14 c++17/c++1z C++17 gnu++98,gnu++11,gnu++14,gnu++1z 在标准基础上加入 GNU 扩展    参考资料  Linux的gcc和g++的区别 Linux下编辑、编译、调试命令总结——gcc和gdb描述 Language Standards Supported by GCC  ","date":"2018-09-19T18:58:19+08:00","permalink":"https://stardustdl.github.io/posts/tools/gcc/","title":"GCC - The GNU Compiler Collection"},{"content":"基本信息  介绍：apt，Advanced Packaging Tool 是Linux下的一款安装包管理工具。常用于 Debian, Ubuntu 等系统。是 dpkg 的前端。  常用命令  很多 apt 命令需要管理员权限。\n 更新数据库 安装软件前常需更新软件包数据库，以保证信息是最新的。\napt update 查找 apt search \u0026lt;seach name\u0026gt; 查看 apt show \u0026lt;package_name\u0026gt; # 查看package内容 apt list # 查看软件包列表    list 选项 描述     --upgradeable 可升级   --installed 已安装   --all 系统中所有能找到的package   -versions 所有版本    安装 apt install \u0026lt;package_name1\u0026gt; \u0026lt;package_name2\u0026gt; ... apt reinstall \u0026lt;package_name\u0026gt; # 重新安装包    选项 描述     --no-upgrade 安装该package但是不升级   --only-upgrade 升级该package   =\u0026lt;version_number\u0026gt; 指定版本    卸载 apt remove \u0026lt;package_name\u0026gt; # 移除该package apt purge \u0026lt;package_name\u0026gt; # 彻底删除该package（包含配置文件） apt autoremove # 自动移除部分无用软件包    remove 选项 描述     --purge 删除包，包括删除配置文件    更新 apt upgrade 下载 apt download \u0026lt;package_name\u0026gt; 查看缓存中的所有包名 apt-cache pkgnames 参考资料 网络\n","date":"2018-09-19T10:30:40+08:00","permalink":"https://stardustdl.github.io/posts/tools/apt/","title":"APT - Advanced Packaging Tool"},{"content":"基本信息  官网 介绍：用于在一个终端窗口中运行多个终端会话的工具。  安装 apt install tmux 基础知识 快捷键前缀（Prefix） 为了使自身的快捷键和其他软件的快捷键互不干扰，Tmux 提供了一个快捷键前缀。当想要使用快捷键时，需要先按下快捷键前缀，然后再按下快捷键。\n 默认前缀：Ctrl+B  配置文件 Tmux 配置文件位于 ~/.tmux.conf，每当开启一个新的会话时，Tmux 都会先读取这个文件。\n 修改快捷键前缀  unbind C-b set -g prefix C-a  使用 vi 操作模式  # Use vim keybindings in copy mode setw -g mode-keys vi 基本操作    快捷键（需使用 Prefix） 描述     % 新建竖直窗格   \u0026quot; 新建水平窗格   方向键 在窗格间切换   c 创建窗口   窗口对应数字 切换窗口    滚屏 Prefix + [ 进入滚屏模式，q 退出。\n复制 在 Tmux 中可以使用与 Vim 极为相似的方式在文本间移动光标。 使用 Prefix 进入复制模式，把光标移动到想复制的文本上后再按下空格键就可以开始选择文本了。选择完要复制的文本后再按下回车键。就复制到 tmux 剪贴板中了。\n在默认情况下，当从 Tmux 中复制文本时，复制下来的文本只能粘贴到同一个 Tmux 会话中。若要使复制下来的文本可以粘贴到任何位置，就需要让 Tmux 将文本复制到系统的剪贴板。为此，我们需要这样做： 安装 retach-to-user-namespace。\nbrew install reattach-to-user-namespace 更新配置文件：\n# invoke reattach-to-user-namespace every time a new window/pane opens set-option -g default-command \u0026quot;reattach-to-user-namespace -l bash\u0026quot; 会话 一个 Tmux 会话中可以包含多个窗口。可以为一个特定的项目创建一个专用的 Tmux 会话。\n创建会话 tmux new -s \u0026lt;name-of-my-session\u0026gt; 在 tmux 内创建会话：使用 Prefix，进入命令模式，然后输入\nnew -s \u0026lt;name-of-my-session\u0026gt; 如果进入了新的会话，但是原来的会话并没有消失。除非显式地关闭会话，否则 Tmux 的会话在重启计算机之前都不会消失。只要还没有重启计算机，你都可以自由地从一个项目的会话跳转到另一个。\n切换会话 使用 s 快捷键查看所有会话及其 ID，按下指定 ID 即可进入对应会话。如果你已经创建了一个或多个会话，但是还没有运行 Tmux，那么可以输入如下命令以接入已开启的会话。\ntmux attach 参考资料  A Tmux crash course: tips and tweaks.  ","date":"2018-09-17T19:40:02+08:00","permalink":"https://stardustdl.github.io/posts/tools/tmux/","title":"Tmux"},{"content":"基本信息  介绍：较安全实现远程连接，控制，传输的一种工具。  基础知识 SSH之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的：\n 远程主机收到用户的登录请求，把自己的公钥发给用户。 用户使用这个公钥，将登录密码加密后，发送回来。 远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。  这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像https协议，SSH协议的公钥是没有证书中心1（CA）公证的，也就是说，都是自己签发的。\n ssh 默认端口是 22  客户端 安装 apt install openssh-client 登录 以用户名 user ，登录远程主机 host\nssh user@host 使用 p 参数指定端口\nssh -p 2222 user@host 第一次登陆 ssh 会指出host主机的公钥指纹，可由此判断此主机是否是真实目标（防止中间人攻击）。确认后会要求输入密码。当远程主机的公钥被接受以后，它就会被保存在文件 $HOME/.ssh/known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。\n公钥登录 所谓\u0026quot;公钥登录\u0026quot;，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用 ssh-keygen 生成一个。 然后使用 ssh-copy-id user@host 命令，将公钥传送到远程主机host上（也可直接修改远程主机公钥存储文件）。 远程主机将用户的公钥，保存在登录后的用户主目录的 $HOME/.ssh/authorized_keys 文件中。公钥就是一段字符串，只要把它追加在 authorized_keys 文件的末尾就行了。 如果远程主机禁用了公钥登录，修改远程主机上的 /etc/ssh/sshd_config 后重启服务：\nRSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 单句执行 ssh user@host \u0026#39;mkdir -p .ssh \u0026amp;\u0026amp; cat \u0026gt;\u0026gt; .ssh/authorized_keys\u0026#39; \u0026lt; ~/.ssh/id_rsa.pub 单引号中间的部分，表示在远程主机上执行的操作；后面的输入重定向，表示数据通过SSH传向远程主机。 这就是说，SSH可以在用户和远程主机之间，建立命令和数据的传输通道。\n密钥生成 使用 ssh-keygen 生成密钥对。可以指定一段信息，密钥对存储位置，对私钥设置口令。默认情况下，在 $HOME/.ssh/ 目录下，会新生成两个文件：id_rsa.pub 和 id_rsa。前者是你的公钥，后者是你的私钥。\n远程复制 scp 是secure copy的简写，用于在Linux下进行远程拷贝文件的命令。其使用和 cp 命令类似，只是表达远程主机上的位置时需包含远程主机信息。\n 本地复制远程文件：（把远程的文件复制到本地）  scp root@www.test.com:/val/test/test.tar.gz /val/test/test.tar.gz  远程复制本地文件：（把本地的文件复制到远程主机上）  scp /val/test.tar.gz root@www.test.com:/val/test.tar.gz scp 命令参数  -1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 留原文件的修改时间，访问时间和访问权限。 -q 不显示传输进度条。 -r 递归复制整个目录。 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。 -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。 -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。 -l limit 限定用户所能使用的带宽，以Kbit/s为单位。 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式， -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。  参考资料  Linux 文档 什么是SSH 以及常见的ssh 功能  ","date":"2018-09-17T18:40:02+08:00","permalink":"https://stardustdl.github.io/posts/tools/ssh/","title":"SSH - Secure Shell"},{"content":"基本信息  官网 介绍：.NET 平台上的包管理器。支持创建，共享，安装，管理包。 特点：NuGet 提供支持专用托管的中心 nuget.org 存储库。NuGet 为开发人员提供创建、发布和使用包所需的工具。最重要的是，NuGet 能维护项目中所用包的引用列表，并且能够通过该列表还原和更新这些包。NuGet 管理包缓存和全局包文件夹，使安装和重新安装过程更为快捷。  使用包 NuGet 会记住每个已安装包的标识和版本号，并将其录制到 packages.config 或项目文件（使用 PackageReference）中，具体取决于项目类型和 NuGet 版本。 使用 NuGet 4.0+，PackageReference 为首选方法。\n\u0026lt;package id=\u0026#34;Newtonsoft.json\u0026#34; version=\u0026#34;6.0.4\u0026#34; allowedVersions=\u0026#34;[6,7)\u0026#34; /\u0026gt; \u0026lt;PackageReference Include=\u0026#34;Newtonsoft.json\u0026#34; Version=\u0026#34;[6, 7)\u0026#34; /\u0026gt; 查找包 搜索语法：\n 关键字：搜索操作将查找包含任何给定关键字的相关包。 示例：modern UI。 若要搜索包含所有给定关键字的包，请在搜索词之间使用“+”，例如 modern+UI。 短语：在引号内输入搜索词可查找与其大小写完全匹配的匹配项。 示例：\u0026quot;modern UI\u0026quot; package 筛选：可以按照语法 \u0026lt;property\u0026gt;:\u0026lt;term\u0026gt; 使用搜索词来搜索特定属性，其中，\u0026lt;property\u0026gt;（区分大小写）可为 id,packageid,version,title,tags,author,description,summary 和 owner。 可将搜索词添加在引号中（如需要），还可以同时搜索多个属性。 此外，按 id 属性搜索得到的是子字符串匹配项，而按 s 搜索将得到确切匹配。  id:NuGet.Core # Match any part of the id property Id:\u0026quot;Nuget.Core\u0026quot; ID:jQuery title:jquery # Searches title as cliown on the package listing PackageId:jquery # Match the package id exactly id:jquery id:ui # Search for multiple terms in the id id:jquery tags:validation # Search multiple properties id:\u0026quot;jquery.ui\u0026quot; # Phrase search invalid:jquery ui # Unsupported properties are ignored, so this # is the same as searching on jquery ui 安装包 还原包 要还原包，首先根据需要安装项目的直接依赖项，然后在整个依赖项关系图中安装这些包的所有依赖项。 如果尚未安装程序包，NuGet 首先尝试从缓存中检索它。 如果在缓存中未找到包，则 NuGet 将尝试从所有已启用的源下载该包。 默认情况下，NuGet 还原操作使用 global-packages 和 http-cache 文件夹中的包。\n重装和更新包 依赖项解析 创建包 承载包 NuGet CLI 配置  修改和查看配置  nuget config -Set \u0026lt;name\u0026gt;=[\u0026lt;value\u0026gt;] [\u0026lt;name\u0026gt;=\u0026lt;value\u0026gt; ...] [options] nuget config -AsPath \u0026lt;name\u0026gt; [options]  清除或列出本地 NuGet 资源  nuget locals \u0026lt;folder\u0026gt; [options] nuget locals all -list nuget locals http-cache -clear  管理源列表  nuget sources \u0026lt;operation\u0026gt; -Name \u0026lt;name\u0026gt; -Source \u0026lt;source\u0026gt; nuget sources Add -Name \u0026quot;MyServer\u0026quot; -Source \\\\myserver\\packages nuget sources Disable -Name \u0026quot;MyServer\u0026quot; nuget source Enable -Name \u0026quot;nuget.org\u0026quot; nuget sources add -name foo.bar -source C:\\NuGet\\local -username foo -password bar -StorePasswordInClearText -configfile %AppData%\\NuGet\\my.config  显示来自给定源的包列表  nuget list [search terms] [options] 创建  打包  nuget pack \u0026lt;nuspecPath | projectPath\u0026gt; [options] [-Properties ...]  签名  nuget sign \u0026lt;package(s)\u0026gt; [options] 推送 nuget pucli \u0026lt;packagePath\u0026gt; [options] 安装 nuget install \u0026lt;packageID | configFilePath\u0026gt; [options] 还原 nuget restore \u0026lt;projectPath\u0026gt; [options] 更新 nuget update \u0026lt;configPath\u0026gt; [options] 验证 nuget verify \u0026lt;-All|-Signatures\u0026gt; \u0026lt;package(s)\u0026gt; [options] 参考资料  An introduction to NuGet  ","date":"2018-09-17T17:40:02+08:00","image":"https://www.nuget.org/Content/gallery/img/logo-header.svg","permalink":"https://stardustdl.github.io/posts/tools/nuget/","title":"NuGet"},{"content":"基本信息  官网 介绍：一个能处理依赖关系，进行自动化编译的工具。 make 不仅可以用于处理程序编译过程，也可以处理更多的含依赖关系的事务  基础知识 GNU的 make 工作时的执行步骤如下：\n 读入所有的Makefile。 读入被include的其它Makefile。 初始化文件中的变量。 推导隐晦规则，并分析所有规则。 为所有的目标文件创建依赖关系链。 根据依赖关系，决定哪些目标要重新生成。 执行生成命令。  ","date":"2018-09-16T18:58:19+08:00","permalink":"https://stardustdl.github.io/posts/tools/make/","title":"Make"},{"content":"基本信息  Makefile 为 make 提供依赖描述和编译指令等设置。  基础知识  注释 # 转义 \\ 通配符：* ? ~  显式规则 Makefile 规则：指定依赖关系与生成命令。\ntarget ... : prerequisites ... command ... ... targets : prerequisites ; command command ...  target 可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签。可以使用通配符。 prerequisites 生成该target所依赖的文件和/或target command 该target要执行的命令（任意的shell命令），如果其不与“target:prerequisites”在一行，那么，必须以 Tab 键开头，如 果和prerequisites在一行，那么可以用分号做为分隔。   prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。\n 还可以通过这种方式表达依赖关系，多个目标依赖一个文件：\nkbd.o command.o files.o : command.h display.o insert.o search.o files.o : buffer.h  Make 将第一个目标作为最终目标 没有依赖项的目标一般不会被自动执行（除非是第一个），需要向 make 传递参数来执行特定目标 可以使用 \\ 折行  多目标 有可能我们的多个目标同时依赖于一个文件，并且 其生成的命令大体类似。可以使用自动化变量 $@。\nbigoutput littleoutput : text.g generate text.g -$(subst output,,$@) \u0026gt; $@ # equal to  bigoutput : text.g generate text.g -big \u0026gt; bigoutput littleoutput : text.g generate text.g -little \u0026gt; littleoutput 静态模式：\n\u0026lt;targets ...\u0026gt; : \u0026lt;target-pattern\u0026gt; : \u0026lt;prereq-patterns ...\u0026gt; \u0026lt;commands\u0026gt; ...  targets定义了一系列的目标文件，可以有通配符。是目标的一个集合。 target-parrtern是指明了targets的模式，也就是的目标集模式。 prereq-parrterns是目标的依赖模式，它对target-parrtern形成的模式再进行一次依赖目标的定义。  objects = foo.o bar.o all: $(objects) $(objects): %.o: %.c $(CC) -c $(CFLAGS) $\u0026lt; -o $@ # equal to  foo.o : foo.c $(CC) -c $(CFLAGS) foo.c -o foo.o bar.o : bar.c $(CC) -c $(CFLAGS) bar.c -o bar.o 静态模式很灵活：\nfiles = foo.elc bar.o lose.o $(filter %.o,$(files)): %.o: %.c $(CC) -c $(CFLAGS) $\u0026lt; -o $@ $(filter %.elc,$(files)): %.elc: %.el emacs -f batch-byte-compile $\u0026lt; 可以使用编译器的功能自动生成依赖关系：\ncc -M foo.c gcc -M foo.c # include std gcc -MM foo.c # exclude std 隐晦规则 make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写 Makefile。\n命令 命令显示 命令必须以 Tab 开始，以 Tab 开始的行会被视为命令。\n 通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 @ 字符在命令行前，那么， 这个命令将不被make显示出来  如果make执行时，带入make参数 -n 或 --just-print ，那么其只是显示命令，但不会执行命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么 顺序的。而make参数 -s 或 --silent 或 --quiet 则是全面禁止命令的显示。\n命令执行 当依赖目标新于目标时，也就是当规则的目标需要被更新时，make会一条一条的执行其后的命令。需要注意 的是，如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。 一般来说，make会以UNIX的标准Shell，也就是 /bin/sh 来执行命令。\nexec: cd /home/hchen; pwd 命令出错 每当命令运行完后，make会检测每个命令的返回码，如果命令返回成功，那么make会执行下一条命令，当规 则中所有的命令成功返回后，这个规则就算是成功完成了。如果一个规则中的某个命令出错了（命令退出码 非零），那么make就会终止执行当前规则，这将有可能终止所有规则的执行。\n忽略命令的出错，我们可以在Makefile的命令行前加一个减号 - （在Tab键之后） ，标记为不管命令出不出错都认为是成功的。\nclean: -rm -f *.o 给make加上 -i 或是 --ignore-errors 参数，那么，Makefile中 所有命令都会忽略错误。而如果一个规则是以 .IGNORE 作为目标的，那么这个规则中的所有命令将会 忽略错误。 给make加上 -k 或是 --keep-going ，这个参数的意思是，如果某 规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。\n嵌套Make subsystem: cd subdir \u0026amp;\u0026amp; $(MAKE) 如果你要传递变量到下级Makefile中，那么你可以使用这样的声明: export \u0026lt;variable ...\u0026gt;; 如果你不想让某些变量传递到下级Makefile中，那么你可以这样声明: unexport \u0026lt;variable ...\u0026gt;;\n有两个变量，一个是 SHELL ，一个是 MAKEFLAGS ，这两个变量不管你是否export，其总是要传递到下层 Makefile中，特别是 MAKEFLAGS 变量，其中包含了make的参数 信息，如果我们执行“总控Makefile”时有make参数或是在上层 Makefile中定义了这个变量，那么 MAKEFLAGS 变量将会是这些参数，并会传递到下层Makefile中，这是一个系统级的环境变量。\n如果你不想往下层传递参数，可显式指定参数为空：$(MAKE) MAKEFLAGS= 参数 -w 或是 --print-directory 会在make的过程 中输出一些信息，让你看到目前的工作目录。\n变量 定义变量 变量名可含有字符、数字，下划线（可以是数字开头）。\nobjects = main.o kbd.o command.o display.o \\  insert.o search.o files.o utils.o edit : $(objects) cc -o edit $(objects) 变量在声明时需要给予初值，而在使用时，需要给在变量名前加上 $ 符号，但最好用小括号 () 或是大括号 {} 把变量给包括起来。\n 如果你要使用真实的 $ 字符，那么你需要用 $$ 来表示。变量会在使用它的地方精确地展开。\n 在定义变量的值时，我们可以使用其它变量来构造变量的值。\n =：在 = 左侧是变量，右侧是变量的值，右侧变量的值可以定义在文件的任何一处，也就是说，右侧中的变量不一定非要是已定义好的值，其也可以使用后面定义的值。但这可能带来循环定义。 :=：只能使用前面已定义好了的变量。 ?=：如果没有被定义过，那么定义此变量，如果先前被定义过，那么这条语将什么也不做 +=：给变量追加值  如果我们要定义一个变量，其值是一个空格：\nnullstring := space := $(nullstring) # end of the line nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边 是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采 用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。\n请注意这里关于“#”的使用，注释符“#”的这种特性值得我们注意。\n变量覆盖 如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略。如果你想 在Makefile中设置这类参数的值，那么，你可以使用 override 指示符。\noverride \u0026lt;variable\u0026gt;; = \u0026lt;value\u0026gt;; 多行变量 define指示符后面跟的是变量的名字，而重起一行定义变量的值，定义是以endef 关键字结束。其工作方 式和“=”操作符一样。变量的值可以包含函数、命令、文字，或是其它变量。因为命令需要以[Tab]键开头， 所以如果你用define定义的命令变量中没有以 Tab 键开头，那么make 就不会把其认为是命令。\ndefine two-lines echo foo echo $(bar) endef 使用变量  变量值替换  $(var:a=b) 其意思是， 把变量“var”中所有以“a”字串“结尾”的“a”替换成“b”字串。这里的“结尾”意思是“空格”或是“结束符”。\n 把变量的值再当成变量  x = y y = z a := $($(x)) 局部变量 可以为某个目标设置局部变量，这种变量被称为“Target-specific Variable”，它可以 和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而 不会影响规则链以外的全局变量的值。\n\u0026lt;target ...\u0026gt; : \u0026lt;variable-assignment\u0026gt;; \u0026lt;target ...\u0026gt; : overide \u0026lt;variable-assignment\u0026gt; 同样可对 target 应用模式：\n\u0026lt;pattern ...\u0026gt;; : \u0026lt;variable-assignment\u0026gt;; \u0026lt;pattern ...\u0026gt;; : override \u0026lt;variable-assignment\u0026gt;; 环境变量  .DEFAULT_GOAL 指定默认目标 SHELL 指定默认 Shell  文件搜索路径 VPATH 变量：如果没有指明这个变量，make只会在当前 的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下 ，到所指定的目录中去找寻文件了。\nVPATH = src:../headers 还可以使用 vpath 关键字：\n vpath \u0026lt;pattern\u0026gt; \u0026lt;directories\u0026gt; 为符合模式的文件指定搜索目录。 vpath \u0026lt;pattern\u0026gt; 清除符合模式的文件的搜索目录。 vpath 清除所有已被设置好了的文件搜索目录。  vapth 使用方法中的\u0026lt;pattern\u0026gt;需要包含 % 字符。 % 的意思是匹配零或若干字符\n我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的 ，或是被重复了的，那么，make会按照vpath语句的先后顺序来执行搜索。\n自动化变量  $@ : 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么， $@ 就是匹配于目标中模式定义的集合。 $% : 仅当目标是函数库文件中，表示规则中的目标成员名。例如，如果一个目标是 foo.a(bar.o) ，那么， $% 就是 bar.o ， $@ 就是 foo.a 。如果目标不是函数库文件那么，其值为空。 $\u0026lt; : 依赖目标中的第一个目标名字。如果依赖目标是以模式（即 % ）定义的，那么 $\u0026lt;将是符合模式的一系列的文件集。注意，其是一个一个取出来的。 $? : 所有比目标新的依赖目标的集合。以空格分隔。 $^ : 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。 $+ : 这个变量很像 $^ ，也是所有依赖目标的集合。只是它不去除重复的依赖目标。 $* : 这个变量表示目标模式中 % 及其之前的部分。如果目标是 dir/a.foo.b ，并且目标的模式是 a.%.b ，那么， $* 的值就是 dir/a.foo 。这个变量对于构造有关联的文件名是比较有较。如果目标中没有模式的定义，那么 $* 也就不能被推导出，但是，如果目标文件的后缀是make所识别的，那么 $* 就是除了后缀的那一部分。例如：如果目标是 foo.c ，因为.c 是make所能识别的后缀名，所以， $* 的值就是 foo 。这个特性是GNU make的，很有可能不兼容于其它版本的make，所以，你应该尽量避免使用 $* ，除非是在隐含规则或是静态模式中。如果目标中的后缀是make所不能识别的，那么 $* 就是空值。  在上述所列出来的自动量变量中。四个变量（$@ 、 $\u0026lt; 、 $% 、 $* ）在扩展时 只会有一个文件，而另三个的值是一个文件列表。这七个自动化变量还可以取得文件的目录名或是在当前 目录下的符合模式的文件名，只需要搭配上 D 或 F 字样。这是GNU make中老版本的特性， 在新版本中，我们使用函数 dir 或 notdir 就可以做到了。 D 的含义就是Directory， 就是目录， F 的含义就是File，就是文件。\n $(@D) 表示 $@ 的目录部分（不以斜杠作为结尾），如果 $@ 值是 dir/foo.o ，那么 $(@D) 就是 dir ，而如果 $@ 中没有包含斜杠的话，其值就是 . （当前目录）。 $(@F) 表示 $@ 的文件部分，如果 $@ 值是 dir/foo.o ，那么 $(@F) 就是 foo.o ， $(@F) 相当于函数 $(notdir $@) 。 $(*D), $(*F) 和上面所述的同理，也是取文件的目录部分和文件部分。对于上面的那个例子， $(*D) 返回 dir ， 而 $(*F) 返回 foo $(%D), $(%F) 分别表示了函数包文件成员的目录部分和文件部分。这对于形同 archive(member) 形式的目标中的 member 中包含了不同的目录很有用。 $(\u0026lt;D), $(\u0026lt;F) 分别表示依赖文件的目录部分和文件部分。 $(^D), $(^F) 分别表示所有依赖文件的目录部分和文件部分。（无相同的） $(+D), $(+F) 分别表示所有依赖文件的目录部分和文件部分。（可以有相同的） $(?D), $(?F) 分别表示被更新的依赖文件的目录部分和文件部分。  文件指示 在Makefile使用 include 关键字可以把别的Makefile包含进来，filename 可以是当前操作系统Shell的文件模式（可以包含路径和通配符）。\ninclude \u0026lt;filename1\u0026gt; \u0026lt;filename2\u0026gt; 更多 伪目标 为了避免目标名和文件重名的情况，可以使用一个特殊的标记“.PHONY”来显式地指明一个目标是“伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。 注意伪目标同样也可成为依赖，其指定的是执行关系。\n.PHONY : clean 条件判断 使用条件判断，可以让make根据运行时的不同情况选择不同的执行分支。条件表达式可以是比较变量的值， 或是比较变量和常量的值。\nlibs_for_gcc = -lgnu normal_libs = foo: $(objects) ifeq ($(CC),gcc) $(CC) -o foo $(objects) $(libs_for_gcc) else $(CC) -o foo $(objects) $(normal_libs) endif 条件表达式使用：比较参数 arg1 和 arg2 的值。\nifeq (\u0026lt;arg1\u0026gt;, \u0026lt;arg2\u0026gt;) ifeq \u0026#39;\u0026lt;arg1\u0026gt;\u0026#39; \u0026#39;\u0026lt;arg2\u0026gt;\u0026#39; ifeq \u0026#34;\u0026lt;arg1\u0026gt;\u0026#34; \u0026#34;\u0026lt;arg2\u0026gt;\u0026#34; ifeq \u0026#34;\u0026lt;arg1\u0026gt;\u0026#34; \u0026#39;\u0026lt;arg2\u0026gt;\u0026#39; ifeq \u0026#39;\u0026lt;arg1\u0026gt;\u0026#39; \u0026#34;\u0026lt;arg2\u0026gt;\u0026#34; ifdef \u0026lt;variable-name\u0026gt;    条件关键字 描述     ifeq 值是否相同   ifneq 值是否不同   ifdef 测试变量值是否非空   ifndef 测试变量值是否为空    函数 调用：$(\u0026lt;function\u0026gt; \u0026lt;arguments\u0026gt;)，参数间以逗号 , 分隔，而函数名和参数之间以“空格”分隔。函数调用以 $ 开头，以圆括号 或花括号把函数名和参数括起。\n   函数 描述     $(subst \u0026lt;from\u0026gt;,\u0026lt;to\u0026gt;,\u0026lt;text\u0026gt;) 把字串 \u0026lt;text\u0026gt; 中的 \u0026lt;from\u0026gt; 字符串替换成 \u0026lt;to\u0026gt;   $(patsubst \u0026lt;pattern\u0026gt;,\u0026lt;replacement\u0026gt;,\u0026lt;text\u0026gt;) 查找 \u0026lt;text\u0026gt; 中的单词是否符合模式 \u0026lt;pattern\u0026gt; ，如果匹配的话，则以 \u0026lt;replacement\u0026gt; 替换。可使用通配符 %   $(strip \u0026lt;string\u0026gt;) 去掉 \u0026lt;string\u0026gt; 字串中开头和结尾的空字符。   $(findstring \u0026lt;find\u0026gt;,\u0026lt;in\u0026gt;) 在字串 \u0026lt;in\u0026gt; 中查找 \u0026lt;find\u0026gt; 字串。如果找到，那么返回 \u0026lt;find\u0026gt; ，否则返回空字符串。   $(filter \u0026lt;pattern...\u0026gt;,\u0026lt;text\u0026gt;) 以 \u0026lt;pattern\u0026gt; 模式过滤 \u0026lt;text\u0026gt; 字符串中的单词，保留符合模式 \u0026lt;pattern\u0026gt; 的单词。   $(filter-out \u0026lt;pattern...\u0026gt;,\u0026lt;text\u0026gt;) 以 \u0026lt;pattern\u0026gt; 模式过滤 \u0026lt;text\u0026gt; 字符串中的单词，去除符合模式 \u0026lt;pattern\u0026gt; 的单词。   $(sort \u0026lt;list\u0026gt;) 给字符串 \u0026lt;list\u0026gt; 中的单词排序（升序）。会去掉 \u0026lt;list\u0026gt; 中相同的单词   $(word \u0026lt;n\u0026gt;,\u0026lt;text\u0026gt;) 取字符串 \u0026lt;text\u0026gt; 中第 \u0026lt;n\u0026gt; 个单词。（从一开始）   $(wordlist \u0026lt;ss\u0026gt;,\u0026lt;e\u0026gt;,\u0026lt;text\u0026gt;) 从字符串 \u0026lt;text\u0026gt; 中取从 \u0026lt;ss\u0026gt; 开始到 \u0026lt;e\u0026gt; 的单词串。   $(words \u0026lt;text\u0026gt;) 统计 \u0026lt;text\u0026gt; 中字符串中的单词个数。   $(firstword \u0026lt;text\u0026gt;) 取字符串 \u0026lt;text\u0026gt; 中的第一个单词。   $(dir \u0026lt;names...\u0026gt;) 从文件名序列 \u0026lt;names\u0026gt; 中取出目录部分。目录部分是指最后一个反斜杠（ / ）之前的部分。如果没有反斜杠，那么返回 ./   $(notdir \u0026lt;names...\u0026gt;) 从文件名序列 \u0026lt;names\u0026gt; 中取出非目录部分。非目录部分是指最後一个反斜杠（ / ）之后的部分。   $(suffix \u0026lt;names...\u0026gt;) 从文件名序列 \u0026lt;names\u0026gt; 中取出各个文件名的后缀。   $(basename \u0026lt;names...\u0026gt;) 从文件名序列 \u0026lt;names\u0026gt; 中取出各个文件名的前缀部分。   $(addsuffix \u0026lt;suffix\u0026gt;,\u0026lt;names...\u0026gt;) 把后缀 \u0026lt;suffix\u0026gt; 加到 \u0026lt;names\u0026gt; 中的每个单词后面。   $(addprefix \u0026lt;prefix\u0026gt;,\u0026lt;names...\u0026gt;) 把前缀 \u0026lt;prefix\u0026gt; 加到 \u0026lt;names\u0026gt; 中的每个单词后面。   $(join \u0026lt;list1\u0026gt;,\u0026lt;list2\u0026gt;) 把 \u0026lt;list2\u0026gt; 中的单词对应地加到 \u0026lt;list1\u0026gt; 的单词后面。如果 \u0026lt;list1\u0026gt; 的单词个数要比 \u0026lt;list2\u0026gt; 的多，那么， \u0026lt;list1\u0026gt; 中的多出来的单词将保持原样。如果\u0026lt;list2\u0026gt; 的单词个数要比 \u0026lt;list1\u0026gt; 多，那么， \u0026lt;list2\u0026gt; 多出来的单词将被复制到\u0026lt;list1\u0026gt; 中。   $(foreach \u0026lt;var\u0026gt;,\u0026lt;list\u0026gt;,\u0026lt;text\u0026gt;) 把参数 \u0026lt;list\u0026gt; 中的单词逐一取出放到参数 \u0026lt;var\u0026gt; 所指定的变量中，然后再执行 \u0026lt;text\u0026gt; 所包含的表达式。每一次 \u0026lt;text\u0026gt; 会返回一个字符串，循环过程中，\u0026lt;text\u0026gt; 的所返回的每个字符串会以空格分隔，最后当整个循环结束时， \u0026lt;text\u0026gt; 所返回的每个字符串所组成的整个字符串（以空格分隔）将会是foreach函数的返回值。   $(if \u0026lt;condition\u0026gt;,\u0026lt;then-part\u0026gt;,\u0026lt;else-part\u0026gt;) 如果 \u0026lt;condition\u0026gt; 为真（非空字符串），那个 \u0026lt;then-part\u0026gt;会是整个函数的返回值，如果 \u0026lt;condition\u0026gt; 为假（空字符串），那么 \u0026lt;else-part\u0026gt; 会是整个函数的返回值，此时如果 \u0026lt;else-part\u0026gt; 没有被定义，那么，整个函数返回空字串。   $(call \u0026lt;expression\u0026gt;,\u0026lt;parm1\u0026gt;,\u0026lt;parm2\u0026gt;,...,\u0026lt;parmn\u0026gt;) 当make执行这个函数时， \u0026lt;expression\u0026gt; 参数中的变量，如 $(1) 、 $(2) 等，会被参数 \u0026lt;parm1\u0026gt; 、 \u0026lt;parm2\u0026gt; 、 \u0026lt;parm3\u0026gt; 依次取代。而 \u0026lt;expression\u0026gt; 的返回值就是 call 函数的返回值。   $(origin \u0026lt;variable\u0026gt;) 返回这个变量是哪里来的   $(shell cmd) shell函数把执行操作系统命令后的输出作为函数返回。make 会新生成一个Shell程序来执行命令。   $(error \u0026lt;text ...\u0026gt;) 产生一个致命的错误， \u0026lt;text ...\u0026gt; 是错误信息。注意，error函数不会在一被使用就会产生错误信息，所以如果你把其定义在某个变量中，并在后续的脚本中使用这个变量，那么也是可以的。   $(warning \u0026lt;text ...\u0026gt;) 并不会让make退出，只是输出一段警告信息，而make继续执行。    如果我们要取 \u0026lt;text\u0026gt; 中最后的一个单词，我们可以这样：$(word $(words \u0026lt;text\u0026gt;),\u0026lt;text\u0026gt;)\norigin 函数返回值：\n undefined 如果 \u0026lt;variable\u0026gt; 从来没有定义过，origin函数返回这个值 undefined default 如果 \u0026lt;variable\u0026gt; 是一个默认的定义，比如“CC”这个变量，这种变量我们将在后面讲述。 environment 如果 \u0026lt;variable\u0026gt; 是一个环境变量，并且当Makefile被执行时， -e 参数没有被打开。 file 如果 \u0026lt;variable\u0026gt; 这个变量被定义在Makefile中。 command line 如果 \u0026lt;variable\u0026gt; 这个变量是被命令行定义的。 override 如果 \u0026lt;variable\u0026gt; 是被override指示符重新定义的。 automatic 如果 \u0026lt;variable\u0026gt; 是一个命令运行中的自动化变量。  参考资料  跟我一起写Makefile  ","date":"2018-09-16T10:20:00+08:00","permalink":"https://stardustdl.github.io/posts/tools/proglang-makefile/","title":"Makefile"},{"content":"基本信息  介绍：Verilog HDL是一种硬件描述语言，用于从算法级、门级到开关级的多种抽象设计层次的 数字系统建模。被建模的数字系统对象的复杂性可以介于简单的门和完整的电子数字系统之 间。数字系统能够按层次描述，并可在相同描述中显式地进行时序建模。  基础知识 注释 // one-line comment /* multi-line comment */ 标识符 Verilog HDL中的标识符可以是任意一组字母、数字、$ 符号和 _ （下划线）符号的 组合，但标识符的第一个字符必须是字母或者下划线。另外，标识符是区分大小写的。 转义标识符可以在一条标识符中包含任何可打印字符。转义标识符以 \\ （反斜线）符号开头，以空白结尾（空白可以是一个空格、一个制表字符或换行符）。反斜线和结束空格并不是转义标识符的一部分。转义标识符与关键词并不完全相同。标识符 \\initial 与标识符 initial（这是个关键词）不同。\n值 基本值  0 ：逻辑 0 1 ：逻辑 1 x ：位置 z ：高阻  常量 整型 简单十进制表示 12,-15\n基数表示法 [size] 'base value\n size 定义以位计的常量的位长 base ：进制（o/O,b/B,d/D,h/H）  x（或z）在十六进制值中代表4位x（或z），在八进制中代表3位x（或z），在二进制中代表1位x（或z）。 基数格式计数形式的数通常为无符号数。这种形式的整型数的长度定义是可选的。如果没有定义一个整数型的长度，数的长度为相应值中定义的位数。 如果定义的长度比为常量指定的长度长，通常在左边填0补位。但是如果数最左边一位为 x或z，就相应地用x或z在左边补位。 如果长度定义得更小，那么最左边的位相应地被截断。 ？字符在数中可以代替值z在值z被解释为不分大小写的情况下提高可读性。\n实数 十进制计数法 2.0 0.1 科学计数法 23_5.1e2 5E-4 实数通过四舍五入被转换为最相近的整数。\n字符串 字符串是双引号内的字符序列。字符串不能分成多行书写。\n用8位ASCII值表示的字符可看作是无符号整数。因此字符串是 8位ASCII值的序列。反斜线 (\\ ) 用于对确定的特殊字符转义。\n参数 参数是一个常量。参数经常用于定义时延和变量的宽度。使用参数说明的参数只被赋值一次。参数值也可以在编译时被改变。改变参数值可以使用参数定义语句或通过在模块初始化 语句中定义参数值\nparameter param1=const_expr1, param2=const_expr2, ... , paramN=const_exprN; 数据类型 线网类型 表示结构化元件间的物理连线。它的值由驱动元件的值决定， 例如连续赋值或门的输出。如果没有驱动元件连接到线网，线网的缺省值为 z。\nnet_kind [msb:lsb] net1,net2,...,netN;   msb/lsb 是用于定义线网范围的常量表达式。如果没有定义范围，缺省的长度1位。\n msb 指定最高有效位对应下标 lsb 指定最低有效位对应下标    wire/tri 用于连接单元的连线是最常见的线网类型。\n  wor/trior 线或指如果某个驱动源为1，那么线网的值也为1。\n  wand/triand 线与网指如果某个驱动源为 0，那么线网的值为0。\n  trireg 此线网存储数值（类似于寄存器），并且用于电容节点的建模。当三态寄存器的所 有驱动源都处于高阻态，也就是说，值为 z时，三态寄存器线网保存作用在线网上的最后一个值。此外，三态寄存器线网的缺省初始值为 x。\n  tri0/tri1 这类线网可用于线逻辑的建模，即线网有多于一个驱动源。 tri0（tri1）线网的特征是，若无驱动源驱动，它的值为0（tri1的值为1）。\n  supply0/supply1 supply0用于对“地”建模，即低电平0；supply1网用于对电源建模，即高电平1。\n  向量线网 在定义向量线网时可选用关键词scalared或vectored。如果一个线网定义时使用了关键词 vectored, 那么就不允许位选择和部分选择该线网。换句话说，必须对线网整体赋值。而如果使用了scalared，则允许位选择和部分选择（这是缺省值）。\n寄存器类型 表示一个抽象的数据存储单元，它只能在 always 语句和 initial 语句中被赋值，并且它的值从一个赋值到另一个赋值被保存下来。寄存器类型的变量具有 x 的缺省值。\nreg 寄存器数据类型reg是最常见的数据类型。寄存器中的值通常被解释为无符号数。\nreg [msb:lsb] reg1,reg2,...,regN;  msb/lsb 是用于定义线网范围的常量表达式。如果没有定义范围，缺省的长度1位。  msb 指定最高有效位对应下标 lsb 指定最低有效位对应下标    存储器 存储器是一个寄存器数组。\nreg [msb:lsb] memory1[upper1:lower1], memory2[upper2:lower2]; 数组的维数不能大于 2。注意存储器属于寄存器数组类型。线网数据类型没有相应的存储器类型。 存储器赋值不能在一条赋值语句中完成，但是寄存器可以。因此在存储器被赋值时，需要定义一个索引。\ninteger 整数寄存器包含整数值。整数寄存器可以作为普通寄存器使用，典型应用为高层次行为建模。\ninteger int1,int2,...,intN[msb:lsb]; msb 和 lsb 是定义整数数组界限的常量表达式，数组界限的定义是可选的。一个整数最少容纳 32 位。但是具体实现可提供更多的位。 一个整数型寄存器可存储有符号数，并且算术操作符提供 2的补码运算结果。 整数不能作为位向量访问。一种截取位值的方法是将整数赋值给一般的 reg 类型变量，然后从中选取相应的位。\ntime time类型的寄存器用于存储和处理时间。\ntime time1,time2,...,timeN[msb:lsb]; msb 和 lsb 是表明范围界限的常量表达式。如果未定义界限，每个标识符存储一个至少 64位的时间值。时间类型的寄存器只存储无符号数。\nreal/realtime real real1,real2,...,realN; realtime real1,real2,...,realN; realtime 与 real 类型完全相同。real 说明的变量的缺省值为 0。不允许对 real 声明值域、位界限或字节界限。当将值 x 和 z 赋予 real 类型寄存器时，这些值作 0 处理。\n表达式 操作数 常数 如果表达式中是十进制整数，那么该整数被解释为有符号数。如果整数是基数型整数（定长或非定长），那么该整数作为无符号数对待。更为重要的是对基数表示或非基数表示的负整数处理方式不同。非基数表示形式的负整数作为有符号数处理，而基数表示形式的负整数值作为无符号数（即负号等价于求补）。 参数也可作为操作数。\n线网 可在表达式中使用标量线网（1位）和向量线网（多位）。线网中的值被解释为无符号数。\n寄存器 标量和向量寄存器可在表达式中使用。整型寄存器中的值被解释为有符号的二进制补码数，而 reg寄存器或时间寄存器中的值被 解释为无符号数。实数和实数时间类型寄存器中的值被解释为有符号浮点数。\n位选择 位选择从向量中抽取特定的位。\nnet_or_reg_vector[bit_select_expr] 部分选择 在部分选择中，向量的连续序列被选择。\nnet_or_reg_vector[msb_const_expr:lsb_const_expr] 存储器单元存储器单元 存储器单元从存储器中选择一个字。不允许对存储器变量值部分选择或位选择。在存储器中读取一个位或部分选择一个字的方法如下：将存储器单元赋值给寄存器变 量，然后对该寄存器变量采用部分选择或位选择操作。\nmemory[word_address] 函数调用 表达式中可使用函数调用。函数调用可以是系统函数调用（以 $字符开始）或用户定义的函数调用。\n操作符 算术操作符 + - * / %\n 整数除法截断任何小数部分。 取模操作符求出与第一个操作符符号相同的余数。 如果算术操作符中的任意操作数是 X或Z，那么整个结果为X。 算术表达式结果的长度由最长的操作数决定。在赋值语句下，算术操作结果的长度由操 作符左端目标长度决定。 在较大的表达式中，所有中间结果应取最大操作数的长度（赋值时，此规则也包括左端目标）  关系操作符 \u0026gt; \u0026lt; \u0026gt;= \u0026lt;=\n 关系操作符的结果为真（ 1）或假（0）。如果操作数中有一位为 X或Z，那么结果为X。  相等关系操作符 逻辑等：== != 全等：=== !==\n 如果比较结果为假，则结果为 0；否则结果为1。 在全等比较中，值 x和z严格按位比较。 也就是说，不进行解释，并且结果一定可知。 在逻辑比较中，值 x和z具有通常的意义，且 结果可以不为x。也就是说，在逻辑比较中，如果两个操作数之一包含 x或z，结果为未知的值（x）。 如果操作数的长度不相等，长度较小的操作数在左侧添0补位  逻辑操作符 \u0026amp;\u0026amp; || !\n 这些操作符在逻辑值0或1上操作。逻辑操作的结构为0或1。 对于向量操作, 非0向量作为1处理。 如果任意一个操作数包含x，结果也为x。  按位操作符 一元非：~ 二元：\u0026amp; | ^ ~^ ^~\n 这些操作符在输入操作数的对应位上按位操作，并产生向量结果。  归约操作符 \u0026amp; ~\u0026amp; | ~| ^ ~^\n归约操作符在 单一操作数 的所有位上操作，并产生 1位结果。\n移位操作符 \u0026lt;\u0026lt; \u0026gt;\u0026gt;\n移位操作符左侧操作数移动右侧操作数表示的次数，它是一个逻辑移位。空闲位添 0 补位。 如果右侧操作数的值为 x 或 z , 移位操作的结果为 x 。\n条件操作符 condition ? expr1 : expr2\n条件操作符根据条件表达式的值选择表达式。\n连接 {expr1,expr2,...,exprN} \n连接操作是将小表达式合并形成大表达式的操作。\n复制 {repetition_number{expr1,expr2,...,exprN}}\n{3{4\u0026#39;b1011}}; //位向量12\u0026#39;b1011_1011_1011 复制通过指定重复次数来执行操作。\n分类 常量表达式是在编译时就计算出常数值的表达式。通常，常量表达式可由下列要素构成：\n 常量文字 参数名 标量表达式是计算结果为 1位的表达式。如果希望产生标量结果 , 但是表达式产生的结果 为向量, 则最终结果为向量最右侧的位值。  编译指令 以 `（反引号）开始的某些标识符是编译器指令。特定的标识符如下：\n define, undef  定义宏（文本替换）和取消定义宏，注意使用宏时也需要加上反引号\n`define WORD 16//建立一个文本宏替代。  wire [`WORD:1] Bus; `undef WORD  ifdef, else, endif  条件编译\n`ifdef WINDOWS parameter WORD_SIZE=16 `else parameter WORD_SIZE=32 `endif  default_nettype  为隐式线网指定线网类型。也就是将那些没有被说明的连线定义线网类型。\n`default_nettype wire  include  嵌入内嵌文件的内容。文件既可以用相对路径名定义，也可以用 全路径名定义,\n`include \u0026#34;../../primitives.v\u0026#34;  resetall  将所有的编译指令重新设置为缺省值。\n`resetall  timescale  将时间单位与实际时间相关联。该指令用于定义时延的单位和时延精度（用于小数单位向整数单位转换）。time_unit 和 time_precision 由值 1、10、和100 以及单位s、ms、us、ns、ps和fs组成。\n//`timescale time_unit / time_precision `timescale 1ns/100ps 当一个设计中的多个模块带有自身的 ``timescale` 编译指令时，模拟器总是定位在所有模块的最小时延精度上，并且所有时延都相应地换算为最小时延精度\n unconnected_drive, nounconnected_drive  在模块实例化中，出现在这两个编译器指令间的任何未连接的输入端口或者为正偏电路 状态或者为反偏电路状态。\n`unconnected_drive pull1 .../*在这两个程序指令间的所有未连接的输入端口为正偏电路状态（连接到高电平）*/ `nounconnected_drive `unconnected_drive pull0 .../*在这两个程序指令间的所有未连接的输入端口为反偏电路状态（连接到低电平）*/ `nounconnected_drive  celldefine, endcelldefine  这两个程序指令用于将模块标记为单元模块。它们表示包含模块定义。\n`celldefine module FD1S3AX(D,CK,Z); ... endmodule `endcelldefine 模块 模块是 Verilog 的基本描述单位，用于描述某个设计的功能或结构及其与其他模块通信的 外部端口。\nmodule module_name (port_list); Declarations: reg, wire, parameter, input, output, inout, function, task, ... Statements: Initial statement Always statement Module instantiation Gate instantiation UDP instantiation Continuous assignment endmodule 时延 Verilog HDL模型中的所有时延都根据时间单位定义。表示方式为 #\u0026lt;time\u0026gt;\n数据流方式 连续赋值用于数据流行为建模。\n连续赋值语句 连续赋值语句将值赋给线网（连续赋值不能为寄存器赋值）。\nassign LHS_target = RHS_expression; 只要在右端表达式的操作数上有事件（事件为值的变化）发生时，表达式即被计算；如果结果值有变化，新结果就赋给左边的线网。\n连续赋值的目标类型如下：\n 标量线网 向量线网 向量的常数型位选择 向量的常数型部分选择 上述类型的任意的拼接运算结果  可以在一个连续赋值语句中编写多个赋值方式：\nassign Mux = (S == 0) ? A : \u0026#39;bz, Mux = (S == 1) ? B : \u0026#39;bz, Mux = (S == 2) ? C : \u0026#39;bz, Mux = (S == 3) ? D : \u0026#39;bz; // equals to  assign Mux = (S == 0) ? A : \u0026#39;bz; assign Mux = (S == 1) ? B : \u0026#39;bz; assign Mux = (S == 2) ? C : \u0026#39;bz; assign Mux = (S == 3) ? D : \u0026#39;bz; 线网说明赋值 连续赋值可作为线网说明本身的一部分。这样的赋值被称为线网说明赋值。是一种线网声明和连续赋值语句的简化写法。 不允许在同一个线网上出现多个线网说明赋值。如果多个赋值是必需的，则必须使用连续赋值语句。\nwire [3:0] Sum = 4\u0026#39;b0; 赋值时延 如果在连续赋值语句中没有定义时延，则右端表达式的值立即赋给左端表达式，时延为 0。\n定义时延：\nassign #6 Ask = Quiet || Late; 规定右边表达式结果的计算到其赋给左边目标需经过 6 个时间单位时延。例如，如果在时刻5，Late值发生变化，则赋值的右端表达式被计算，并且 Ask 在时刻11(=5+6) 被赋于新值。\n对于每个时延定义，总共能够指定三类时延值：\n 上升时延 下降时延 关闭时延  解释：如果右端从非 0 向量变化到 0 向量，那么就使用下降时延。如果右端值到达 z，那么使用下降时延，否则使用上升时延。\n这三类时延的语法如下：\nassign # (rise, fall, turn-off) LHS_target = RHS_expression; 仅使用一个数字（如 #5）定义时延时，则上述三类时延均设置为此值。\n线网时延 时延也可以在线网说明中定义，这个时延表明驱动源值改变与线网本身改变间的时延。和赋值语句时延一起使用时产生叠加效果。\nwire #5 Arb; 如果时延在线网说明赋值中出现，那么时延不是 线网时延，而是赋值时延。\n行为方式 (TODO:008)\n initial 语句 always 语句  结构方式 内置门原语 (TODO:005)\n开关级原语 (TODO:005)\n用户定义的原语 (TODO:006)\n模块实例 (TODO:009)\n其他 (TODO:010)\n验证 (TODO:011)\n参考资料 ","date":"2018-09-12T17:50:16+08:00","permalink":"https://stardustdl.github.io/posts/tools/proglang-verilog/","title":"Verilog HDL"},{"content":"题面 题目概述  时间限制：1000 ms 空间限制：128 MB 命题人：Stardust D.L. 验题人：GodCallMeGod, Pexure  题目描述 小 A 和你我一样，正坐在电脑前刷题。但茫茫多的 OJ 和茫茫多的题目，让他感到无从下手。幸运的是，小 A 得到了一个神奇的工具，能很快生成一个指定长度的题目列表，还能标识出题目的难度等级。小 A 用这个工具生成了一个长度为 $n$ 的题目列表，但这个题目列表中难度安排不太令人满意，为了提高刷题体验，也尽快提高问题求解能力，小 A 决定把其中一些题换掉，来让题目难度安排更加合理。 形式化的，设题目列表 $a$，$a_i(1\\le i\\le n)$ 表示第 $i$ 道题的难度（数值越大，难度越高），定义 对于题目列表的“难度渐进”值 $Q(a)$ 为：\n$$ Q(a)=\\sum_{i=2}^n \\min(1,a_i-a_{i-1}) $$\n小 A 希望将 某一些 $a_i$ 改成 $a_i'$（由于可以任意挑题目，所以这里选取的 $a_i'\\in \\mathbb{Z}$ 是任意的，即使是负值也可以），使得修改后的新序列 $a'$，$Q(a')$ 最大。为了尽快开始做题，小 A 希望被替换的题目数量越少越好。请求出最少替换几道题目能使得 $Q(a')$ 最大。\n输入 第一行一个整数 $T$，表示 $T$ 组测试数据。 之后对于每组测试数据： 第一行一个整数 $n$，表示题目列表长度。 第二行 $n$ 个整数 $a_i$，表示每道题目的难度。\n输出 $T$ 行，每行一个整数表示答案。\n样例 输入 4 3 1 1 2 4 1 2 2 5 10 46 42 22 45 14 33 3 21 9 5 20 38 35 11 86 31 47 3 6 71 93 42 74 95 3 94 47 89 46 98 10 输出 1 1 8 13 解释  第一组：将第一个 $1$ 改成 $0$ 第二组：将第二个 $2$ 改成 $3$ 或 $4$  数据范围  $1\\le T \\le 5$ $1\\le n\\le 3000$ $1\\le a_i \\le 10^5,a_i\\in \\mathbb{Z}$  命题思路 以最长上升子序列的 $O(n^2)$ 动态规划算法为核心，进行一定程度包装和扩展，实现对此算法的灵活应用。\n解题思路 首先简化题意，可以发现 $Q(a)$ 最大值为 $n-1$，当且仅当 $a$ 严格递增时达到最大值。所以问题变成：把一个序列改成严格单调递增的，至少需要改多少个数？\n解法 1 状态： $d_{i,j}$ 表示前 $i$ 个数，将 $a_i$ 修改为 $j$ ，使序列严格递增时，修改次数的最小值。 **转移**： $$ d_{i,j}=[j\\ne a_i]+\\min_{k \u0026lt; j}d_{i-1,k} $$\n 若 $j=a_i$，则不必修改，转移为 $d_{i,j}=\\min_{k \u0026lt; j}d_{i-1,k}$ 若 $j\\ne a_i$，则需要修改，转移为 $d_{i,j}=1+\\min_{k \u0026lt; j}d_{i-1,k}$ 临界值 $$ d_{1,j}=\\begin{cases} 0,\u0026amp;j=a_1\\\n1,\u0026amp;j\\ne a_1 \\end{cases} $$  而问题的答案即 $d_{n,x}$ 中的最小值。 此解法状态数 $O(n\\times\\max(n,m))$ （其中 $m$ 为 $a_i$ 的可能取值种数）状态转移 $O(m)$，故时间复杂度为 $O(nm^2)$。\n 由于数值范围较大，通过离散化可将 $m$ 降至与 $n$ 同阶，但由于此题的“严格递增”条件，普通的离散化可能会带来错解。这一点我们在之后解决。\n 解法 2  此方法与解法一“对偶”，但实现要容易得多。\n 状态： $d_{i,j}$ 表示前 $i$ 个数，修改 $0\\le j\\le i$ 次使序列严格递增时，$a_i$ 的最小值。 **转移**： $$ d_{i,j}=\\begin{cases} \\min (a_i,d_{i-1,j-1}+1)\u0026amp;d_{i-1,j} \u0026lt; a_i\\\nd_{i-1,j-1}+1,\u0026amp;d_{i-1,j} \\ge a_i \\end{cases} $$\n 若不修改 $a_i$ 则要求 $d_{i-1,j} \u0026lt; a_i$，故此时有转移 $d_{i,j}=a_i$。 若修改 $a_i$ 则由状态值定义，一定会改成前一个数 $+1$，即此时有转移 $d_{i,j}=d_{i-1,j-1}+1$ 未能转移的状态都是不可行解。 临界值 $$ d_{1,j}=\\begin{cases} a_1,\u0026amp;j=0\\\n-\\infty,\u0026amp;j=1\\\n\\end{cases} $$  而问题的答案即 $d_{n,x}$ 中最小的 $x$ 使得 $d_{n,x}$ 存在。 此解法状态数 $O(n^2)$，状态转移 $O(1)$，故时间复杂度为 $O(n^2)$。\n解法 3（标准解法）  其实此题的 $n$ 可提升至 $10^6$，$a_i$ 数值范围可无限制（例如 $10^{18}$）。但对于这样的数据，前两种做法显然无能为力。所以我们需要一个全新的思路。\n 我们考虑一个相似的问题：把一个序列改成单调 不降 的，至少需要改多少个数？即要保证 $$i \u0026lt; j \\Rightarrow a_i\\le a_j$$ 这个问题的解法是 保留最长不降子序列。最长非降子序列形成了一个阶梯式结构，可以将所有不属于最长非降子序列的数据改成最靠近的阶梯层。所以答案为 $n-\\text{len}(LNDS)$。\n 证明可以从最优解必须保留最长非降子序列，和不能改动更少的数使得满足条件两个角度出发。\n 对于求解最长非降子序列，将求解 LIS 的算法 的状态转移稍作改动即可： $$d_i=1+\\max_{j\u0026lt; i\\wedge a_j\\le a_i} d_j$$ 回到原题：一种比较自然的思路是保留最长上升子序列，即求 $n-len(LIS)$。 但这是 **错** 的，比如这组数据：\n1 2 2 3 有 $\\text{len}(LIS)=3$，但显然只改一个值并不能将其变成严格递增的。\n 样例数据并不能反映这一点，但有所暗示。\n 所以原序列的 LIS 并不一定能完全被保留。那么什么样的子序列才是可以被完全保留的？其实仅在这种情况下，保留 LIS 可能会出现错误：$x-1,x,x,\\cdots,x,x+1$，中间过多的 $x$ 使得 $x+1$ 不能被保留。 所以我们需要考虑位置信息。可以发现 $a_i$ 至少要比 $a_0$ 大 $i$。即要保证\n$$ i \u0026lt; j \\Rightarrow a_j\u0026gt;a_i \\Leftrightarrow a_j-a_i\\ge j-i \\Leftrightarrow a_j-j\\ge a_i-i $$\n至此，我们完成了对原问题的转化。定义序列 $b:b_i=a_i-i$ 。可以发现：$a$ 的可完全保留单调递增序列和 $b$ 的不降子序列是一一对应的。 所以原问题的答案就是 $n-\\text{len}(LNDS_b)$。 求解的时间复杂度集中在求解 $\\text{len}(LNDS_b)$，而这一步可以在 $O(n^2)$ 内完成。故总时间复杂度为 $O(n^2)$. 而求解 LIS，LNDS 的长度可以在 $O(n\\lg n)$ 内完成。故我们可以使用解法 3 在更短的时间内解决。\n 看起来算法 3 完美地解决了这个问题，而算法 1 没有任何优势，但其实不然，在 问题扩展 部分，我们会利用算法 3 推导过程中的思路来扩展算法 1，并用其解决一个更复杂的问题。\n 数据构造 此题要求卡掉 $n-len(LIS)$ 的做法，所以构造形如 1 2 2 3 的数据即可。\nimport random import os maxN = 3000 maxA = 100000 def nextN(): return random.randint(1, maxN) def randArr(n,l,r): ret = [] for i in range(n): ret.append(random.randint(l, r)) return ret def outputData(a): print(len(a), end = \u0026#39;\\n\u0026#39;) print(\u0026#34; \u0026#34;.join(str(i) for i in a), end = \u0026#39;\\n\u0026#39;) def randData(n): return randArr(n,1,maxA) def waLISData(n): while n \u0026lt; 1000: n = nextN() a = randArr(n//3, 1, n//3) a.sort() b = [] for i in a: num=random.randint(2,5) for x in range(num): b.append(i) while len(b) \u0026gt; n: b.pop() return b T = random.randint(3,5) print(T, end = \u0026#39;\\n\u0026#39;) for i in range(T): n = nextN() tp = random.randint(1, 4) if tp==1: outputData(randData(n)) else: outputData(waLISData(n)) 标准程序 #include \u0026lt;iostream\u0026gt;using namespace std; const int MAXN = 3000; namespace LNDS { int d[MAXN + 5]; int solve(int *a, int n) { d[0] = 1; int ans = 1; for (int i = 1; i \u0026lt; n; i++) { int \u0026amp;c = d[i]; c = 1; for (int j = 0; j \u0026lt; i; j++) { if (a[j] \u0026lt;= a[i]) c = max(c, d[j] + 1); } ans = max(ans, c); } return ans; } } // namespace LNDS int T, n; int a[MAXN + 5]; int main() { cin \u0026gt;\u0026gt; T; while (T--) { cin \u0026gt;\u0026gt; n; for (int i = 0; i \u0026lt; n; i++) { cin \u0026gt;\u0026gt; a[i]; a[i] -= i; } cout \u0026lt;\u0026lt; n - LNDS::solve(a, n) \u0026lt;\u0026lt; endl; } } 问题扩展 更复杂的修改费用 原问题中，每次修改的费用恒为 $1$，如果将修改费用定义为 $|a_i'-a_i|$，该如何求解呢？ 此时解法 3 不那么奏效：保留最长可行子序列，但可能有多种最长可行子序列，而且保留后相邻段之间的值该如何更改，解法 3 难以给出足够的信息。 但可以发现，解法 3 思路中的推导仍然成立，我们依旧将问题转化，求序列 $b:b_i=a_i-i$ 满足不降的最优解。两个问题的最优解值是相等的。 首先一个结论，在修改后的序列中出现的所有数，都是原序列中出现过的。其证明可用反证法。 进而我们只在处理中只关注某个数的位次（排名），仅在计算费用时使用原值，所以我们可对序列的值离散化，将 $m$ 降到 $n$ 同阶。\n 由于在转化后的问题中，我们可以让一段值相等，不再存在“严格递增”条件，离散化可能错解的问题被解决。\n 接下来，我们使用解法 1：设 $c_i$ 表示 ${b}$ 中第 $i$ 小的数。 状态： $d_{i,j}$ 表示前 $i$ 个数，将 $b_i$ 修改为 $c_j$ ，使序列不降时，修改费用的最小值。 **转移**： $$ d_{i,j}=|c_j-b_i|+\\min_{k \\le j}d_{i-1,k} $$\n而问题的答案即 $d_{n,x}$ 中的最小值。 此解法状态数 $O(n^2)$，状态转移 $O(n)$，故时间复杂度为 $O(n^3)$。 通过维护 $d_i$ 的前缀最小值可将状态转移降至 $O(1)$，故时间复杂度可优化为 $O(n^2)$。\n相关题目  {% post_link problem/hdu/hdu-5256 %} {% post_link problem/poj/poj-3666 %} {% post_link problem/codeforces/cf-713C %}  ","date":"2018-09-11T17:30:22+08:00","permalink":"https://stardustdl.github.io/posts/learning/ojops-problem-design/","title":"OJ-oriented Problem Solving 命题报告"},{"content":"基本信息  介绍：CSS 存储 HTML 样式，定义如何显示 HTML 元素。 在 HTML 中使用样式表，参见 {% post_link tool/progLang-HTML %}  层叠 样式表允许以多种方式规定样式信息。样式可以规定在单个的 HTML 元素中，在 HTML 页的头元素中，或在一个外部的 CSS 文件中。甚至可以在同一个 HTML 文档内部引用多个外部样式表。 当同一个 HTML 元素被不止一个样式定义时，层叠顺序如下，其中数字 4 拥有最高的优先权。\n 浏览器缺省设置 外部样式表 内部样式表（位于  标签内部） 内联样式（在 HTML 元素内部）  因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明： 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。\n通过 CSS 继承，子元素将继承最高级元素所拥有的属性\n语法 CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明。\nselector {declaration1; declaration2; ... declarationN } selector {property: value} h1 {color:red; font-size:14px;}  选择器：指定需要改变样式的 HTML 元素。 每条声明由一个属性和一个值组成。  如果要定义不止一个声明，则需要用分号将每个声明分开。 属性（property）是设置的样式属性（style attribute）。每个属性有一个值。 属性和值被冒号分开。 如果值为若干单词，则要给值加引号。     CSS 对大小写不敏感。不过存在一个例外：如果涉及到与 HTML 文档一起工作的话，class 和 id 名称对大小写是敏感的。\n 选择器 分组 允许对不同种类选择器定义相同的样式规则。 使用逗号分隔多个选择器以实现选择器的分组（并列关系）：\nh1,h2,h3,h4,h5,h6 { color: green; } 元素选择器 文档的元素就是最基本的选择器。\nhtml {color:black;} h1 {color:blue;} h2 {color:silver;} 通配选择器匹配所有元素：\n* {color:red;} 基于上下文关系 后代选择器 后代选择器允许你根据文档的上下文关系来确定某个标签的样式。\n使用空格分隔选择器以实现后代选择器（后代关系）： 希望列表中的 strong 元素变为斜体字，而不是通常的粗体字：\nli strong { font-style: italic; font-weight: normal; } 子元素选择器 与后代选择器相比，子元素选择器只能选择作为某元素子元素的元素。 使用 \u0026gt; 分隔选择器以实现子元素选择器（父子关系）：\nh1 \u0026gt; strong {color:red;} 相邻兄弟选择器 相邻兄弟选择器可选择紧接在另一元素后的元素，且二者有相同父元素。 使用 + 分隔选择器以实现相邻兄弟选择器（相邻兄弟关系）： 选择紧接在 h1 元素后出现的 p 元素，h1 和 p 元素拥有共同的父元素：\nh1 + p {margin-top:50px;} 基于属性 id 选择器 id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。 以 # 来定义 id 选择器。\n#red {color:red;} #green {color:green;} 通过加入元素类型前缀，可指定元素类型（但由于 id 唯一性，此做法意义不大）：\ndiv#red {color:red;} 类选择器 类选择器可以为标有特定 class 的 HTML 元素指定特定的样式。 以 . 来定义 id 选择器。\n.center {text-align: center} 在 HTML 中，一个 class 值中可能包含一个词列表，各个词之间用空格分隔。可以使用多类选择器匹配这种情况。 通过把两个类选择器链接在一起，仅可以选择同时包含这些类名的元素（类名的顺序不限）。\n.important.urgent {background:silver;} 匹配：\n\u0026lt;p class=\u0026#34;important urgent\u0026#34;\u0026gt; \u0026lt;/p\u0026gt; 通过加入元素类型前缀，可指定元素类型：\ntd.fancy { color: #f60; background: #666; } 匹配：\n\u0026lt;td class=\u0026#34;fancy\u0026#34;\u0026gt; 属性选择器 可以为拥有指定属性的 HTML 元素设置样式，而不仅限于 class 和 id 属性。\n简单属性选择  为带有 title 属性的所有元素设置样式：  [title] { color:red; }  根据多个属性进行选择，只需将属性选择器链接在一起即可。将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色：  a[href][title] {color:red;} 根据具体属性值  为 title=\u0026ldquo;W3School\u0026rdquo; 的所有元素设置样式：  [title=W3School] { border:5px solid blue; }  为包含指定值的 title 属性的所有元素设置样式。适用于由空格分隔的属性值：  [title~=hello] { color:red; }  为带有包含指定值的 lang 属性的所有元素设置样式（选择 lang 属性等于 en 或以 en- 开头的所有元素）。适用于由连字符分隔的属性值：  [lang|=en] { color:red; }  选择 abc 属性值以 \u0026ldquo;def\u0026rdquo; 开头的所有元素  [abc^=\u0026#34;def\u0026#34;]{}  选择 abc 属性值以 \u0026ldquo;def\u0026rdquo; 结尾的所有元素  [abc$=\u0026#34;def\u0026#34;]{}  选择 abc 属性值中包含子串 \u0026ldquo;def\u0026rdquo; 的所有元素  [abc*=\u0026#34;def\u0026#34;]{} 通过加入元素类型前缀，可指定元素类型：\ninput[type=\u0026#34;text\u0026#34;] { width:150px; display:block; margin-bottom:10px; background-color:yellow; font-family: Verdana, Arial; } 伪类 CSS 伪类用于向某些选择器添加特殊的效果。\nselector : pseudo-class {property: value} 伪\u0026gt; 类名称对大小写不敏感。\n锚伪类 通过伪类表示元素状态：链接的不同状态都可以不同的方式显示，这些状态包括：活动状态，已被访问状态，未被访问状态，和鼠标悬停状态。\na:link {color: #FF0000}\t/* 未访问的链接 */ a:visited {color: #00FF00}\t/* 已访问的链接 */ a:hover {color: #FF00FF}\t/* 鼠标移动到链接上 */ a:active {color: #0000FF}\t/* 选定的链接 */ 在 CSS 定义中，a:hover 必须被置于 a:link 和 a:visited 之后，才是有效的。\n在 CSS 定义中，a:active 必须被置于 a:hover 之后，才是有效的。\n:first-child 使用 :first-child 伪类来选择作为其父元素的第一个子元素的元素：\np:first-child {font-weight: bold;} 匹配：\n\u0026lt;div\u0026gt; \u0026lt;p\u0026gt;These are the necessary steps:\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; :lang :lang 伪类使你有能力为不同的语言定义特殊的规则。\n:lang 类为属性值为 no 的 q 元素定义引号的类型：\nq:lang(no){ quotes: \u0026#34;~\u0026#34; \u0026#34;~\u0026#34; } 伪元素 CSS 伪元素用于向某些选择器设置特殊效果。\nselector:pseudo-element {property:value;} :first-line \u0026ldquo;first-line\u0026rdquo; 伪元素用于向文本的首行设置特殊样式（只能用于块级元素）。\n:first-letter \u0026ldquo;first-letter\u0026rdquo; 伪元素用于向文本的首字母设置特殊样式（只能用于块级元素）：\n:before \u0026ldquo;:before\u0026rdquo; 伪元素可以在元素的内容前面插入新内容。\n:after \u0026ldquo;:after\u0026rdquo; 伪元素可以在元素的内容之后插入新内容。\n属性 背景 所有背景属性都不能继承。\n   属性 描述     background-color 背景色   background-image 背景图像   background-repeat 背景重复   background-position 背景定位   background-attachment 背景与可视区的关联（固定或滚动）   background-size 背景图片的尺寸   background-origin 背景图片的定位区域   background-clip 背景的绘制区域    文本    属性 描述     color 文本颜色   direction 文本方向   line-height 行高   letter-spacing 字符间距   text-align 对齐元素中的文本   text-decoration 向文本添加修饰   text-indent 缩进元素中文本的首行   text-transform 控制元素中的字母   unicode-bidi 文本方向   white-space 元素中空白的处理方式   word-spacing 字间距   hanging-punctuation 规定标点字符是否位于线框之外   punctuation-trim 规定是否对标点字符进行修剪   text-align-last 设置如何对齐最后一行或紧挨着强制换行符之前的行   text-emphasis 向元素的文本应用重点标记以及重点标记的前景色   text-justify 规定当 text-align 设置为 \u0026ldquo;justify\u0026rdquo; 时所使用的对齐方法   text-outline 规定文本的轮廓   text-overflow 规定当文本溢出包含元素时发生的事情   text-shadow 向文本添加阴影   text-wrap 规定文本的换行规则   word-break 规定非中日韩文本的换行规则   word-wrap 允许对长的不可分割的单词进行分割并换行到下一行    字体    属性 描述     font 简写属性。作用是把所有针对字体的属性设置在一个声明中。   font-family 字体系列   font-size 字体的尺寸   font-style 字体风格   font-variant 以小型大写字体或者正常字体显示文本   font-weight 字体的粗细    @font-face 规则：使用自己的字体：\n\u0026lt;style\u0026gt; @font-face{ font-family: myFirstFont; src: url(\u0026#39;Sansation_Light.ttf\u0026#39;); font-weight:bold; } div{ font-family:myFirstFont; } \u0026lt;/style\u0026gt; 列表    属性 描述     list-style 简写属性。用于把所有用于列表的属性设置于一个声明中。   list-style-image 将图象设置为列表项标志。   list-style-position 列表中列表项标志的位置。   list-style-type 列表项标志的类型。    表格    属性 描述     border-collapse 是否把表格边框合并为单一的边框   border-spacing 分隔单元格边框的距离   caption-side 表格标题的位置   empty-cells 是否显示表格中的空单元格   table-layout 显示单元、行和列的算法    轮廓    属性 描述     outline 在一个声明中设置所有的轮廓属性   outline-color 轮廓的颜色   outline-style 轮廓的样式   outline-width 轮廓的宽度    多列    属性 描述     column-count 规定元素应该被分隔的列数   column-fill 规定如何填充列   column-gap 规定列之间的间隔   column-rule 设置所有 column-rule-* 属性的简写属性   column-rule-color 规定列之间规则的颜色   column-rule-style 规定列之间规则的样式   column-rule-width 规定列之间规则的宽度   column-span 规定元素应该横跨的列数   column-width 规定列的宽度   columns 规定设置 column-width 和 column-count 的简写属性    定位    属性 描述     position 把元素放置到一个静态的、相对的、绝对的、或固定的位置中   top 定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移   right 定义了定位元素右外边距边界与其包含块右边界之间的偏移   bottom 定义了定位元素下外边距边界与其包含块下边界之间的偏移   left 定义了定位元素左外边距边界与其包含块左边界之间的偏移   overflow 设置当元素的内容溢出其区域时发生的事情   clip 设置元素的形状。元素被剪入这个形状之中，然后显示出来   vertical-align 设置元素的垂直对齐方式   z-index 设置元素的堆叠顺序   display 改变生成的框的类型（block,inline,none）    使用 float 属性实现元素浮动。\n尺寸    属性 描述     height 元素的高度   line-height 行高   max-height 元素的最大高度   max-width 元素的最大宽度   min-height 元素的最小高度   min-width 元素的最小宽度   width 元素的宽度    分类    属性 描述     clear 设置一个元素的侧面是否允许其他的浮动元素   cursor 规定当指向某元素之上时显示的指针类型   display 设置是否及如何显示元素   float 定义元素在哪个方向浮动   position 把元素放置到一个静态的、相对的、绝对的、或固定的位置中   visibility 设置元素是否可见或不可见    框模型 边距属性赋值顺序：上、右、下、左 边距属性均具有对应的 -bottom,-left,-right,-top 属性设置某个方向上的值。 边框属性除了 border-bottom 等属性外，还有 border-bottom-style 等属性。\n   属性 描述     padding 内边距   margin 外边距   border 边框   border-style 边框样式   border-width 边框宽度   border-color 边框颜色   border-image 使用图片来绘制边框   border-radius 圆角边框   box-shadow 向方框添加一个或多个阴影    值复制特性：\n 如果缺少左外边距的值，则使用右外边距的值。 如果缺少下外边距的值，则使用上外边距的值。 如果缺少右外边距的值，则使用上外边距的值。  外边框合并特性： 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。\n转换 2D    属性 描述     transform 向元素应用 2D 或 3D 转换   transform-origin 允许你改变被转换元素的位置    2D Transform 方法：\n   函数 描述     matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵   translate(x,y) 定义 2D 转换，沿着 X 和 Y 轴移动元素   translateX(n) 定义 2D 转换，沿着 X 轴移动元素   translateY(n) 定义 2D 转换，沿着 Y 轴移动元素   scale(x,y) 定义 2D 缩放转换，改变元素的宽度和高度   scaleX(n) 定义 2D 缩放转换，改变元素的宽度   scaleY(n) 定义 2D 缩放转换，改变元素的高度   rotate(angle) 定义 2D 旋转，在参数中规定角度   skew(x-angle,y-angle) 定义 2D 倾斜转换，沿着 X 和 Y 轴   skewX(angle) 定义 2D 倾斜转换，沿着 X 轴   skewY(angle) 定义 2D 倾斜转换，沿着 Y 轴    3D    属性 描述     transform 向元素应用 2D 或 3D 转换   transform-origin 允许你改变被转换元素的位置   transform-style 规定被嵌套元素如何在 3D 空间中显示   perspective 规定 3D 元素的透视效果   perspective-origin 规定 3D 元素的底部位置   backface-visibility 定义元素在不面对屏幕时是否可见    3D Transform 方法：\n   函数 描述     matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵   translate3d(x,y,z) 定义 3D 转化   translateX(x) 定义 3D 转化，仅使用用于 X 轴的值   translateY(y) 定义 3D 转化，仅使用用于 Y 轴的值   translateZ(z) 定义 3D 转化，仅使用用于 Z 轴的值   scale3d(x,y,z) 定义 3D 缩放转换   scaleX(x) 定义 3D 缩放转换，通过给定一个 X 轴的值   scaleY(y) 定义 3D 缩放转换，通过给定一个 Y 轴的值   scaleZ(z) 定义 3D 缩放转换，通过给定一个 Z 轴的值   rotate3d(x,y,z,angle) 定义 3D 旋转   rotateX(angle) 定义沿 X 轴的 3D 旋转   rotateY(angle) 定义沿 Y 轴的 3D 旋转   rotateZ(angle) 定义沿 Z 轴的 3D 旋转   perspective(n) 定义 3D 转换元素的透视视图    过渡    属性 描述     transition 简写属性，用于在一个属性中设置四个过渡属性   transition-property 规定应用过渡的 CSS 属性的名称   transition-duration 定义过渡效果花费的时间。默认是 0   transition-timing-function 规定过渡效果的时间曲线。默认是 \u0026ldquo;ease\u0026rdquo;   transition-delay 规定过渡效果何时开始。默认是 0    动画    属性 描述     @keyframes 规定动画   animation 所有动画属性的简写属性，除了 animation-play-state 属性   animation-name 规定 @keyframes 动画的名称   animation-duration 规定动画完成一个周期所花费的秒或毫秒。默认是 0   animation-timing-function 规定动画的速度曲线。默认是 \u0026ldquo;ease\u0026rdquo;   animation-delay 规定动画何时开始。默认是 0   animation-iteration-count 规定动画被播放的次数。默认是 1   animation-direction 规定动画是否在下一周期逆向地播放。默认是 \u0026ldquo;normal\u0026rdquo;   animation-play-state 规定动画是否正在运行或暂停。默认是 \u0026ldquo;running\u0026rdquo;   animation-fill-mode 规定对象动画时间之外的状态    @keyframes myfirst{ from {background: red;} to {background: yellow;} } div{ animation: myfirst 5s; } div{ animation-name: myfirst; animation-duration: 5s; animation-timing-function: linear; animation-delay: 2s; animation-iteration-count: infinite; animation-direction: alternate; animation-play-state: running; } 用户界面    属性 描述     appearance 允许您将元素设置为标准用户界面元素的外观   box-sizing 允许您以确切的方式定义适应某个区域的具体内容   icon 为创作者提供使用图标化等价物来设置元素样式的能力   nav-down 规定在使用 arrow-down 导航键时向何处导航   nav-index 设置元素的 tab 键控制次序   nav-left 规定在使用 arrow-left 导航键时向何处导航   nav-right 规定在使用 arrow-right 导航键时向何处导航   nav-up 规定在使用 arrow-up 导航键时向何处导航   outline-offset 对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓   resize 规定是否可由用户对元素的尺寸进行调整    参考资料  CSS 教程 CSS3 教程  ","date":"2018-09-08T10:30:40+08:00","image":"https://raw.githubusercontent.com/github/explore/80688e429a7d4ef2fca1e82350fe8e3517d3494d/topics/css/css.png","permalink":"https://stardustdl.github.io/posts/tools/proglang-css/","title":"Cascading Style Sheets"},{"content":"基本信息  介绍：一种描述网页的标记语言。 相关：XHTML（可扩展超文本标记语言，更严格更纯净的 HTML 版本）  语法  HTML 文档描述网页  HTML 文档包含 HTML 标签和纯文本   HTML 标记标签通常被称为 HTML 标签。  HTML 标签是由尖括号包围的关键词，比如 \u0026lt;html\u0026gt; HTML 标签通常是成对出现的，比如 \u0026lt;b\u0026gt; 和 \u0026lt;/b\u0026gt; 标签对中的第一个标签是开始标签，第二个标签是结束标签 开始和结束标签也被称为开放标签和闭合标签   HTML 元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码。  HTML 元素以开始标签起始 HTML 元素以结束标签终止 元素的内容是开始标签与结束标签之间的内容 某些 HTML 元素具有空内容（empty content） 空元素在开始标签中进行关闭（以开始标签的结束而结束） 大多数 HTML 元素可拥有属性   HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。  属性总是以名称/值对的形式出现，比如：name=\u0026quot;value\u0026quot;。 属性总是在 HTML 元素的开始标签中规定。   HTML 块元素：块级元素在浏览器显示时，通常会以新行来开始（和结束）。 HTML 内联元素：内联元素在显示时通常不会以新行开始。 颜色：#000000 = rgb(0,0,0) \u0026lt;!DOCTYPE\u0026gt; 指定 HTML 版本   特殊字符\n 文档结构 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 头部 \u0026lt;head\u0026gt; 元素是所有头部元素的容器。\u0026lt;head\u0026gt; 内的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息，等等。\n   标签 描述     \u0026lt;title\u0026gt; 文档的标题   \u0026lt;base\u0026gt; 为页面上的所有链接规定默认地址或默认目标   \u0026lt;link\u0026gt; 文档与外部资源之间的关系   \u0026lt;style\u0026gt; 样式信息   \u0026lt;meta\u0026gt; 元数据   \u0026lt;script\u0026gt; 客户端脚本    \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Title of the document\u0026lt;/title\u0026gt; \u0026lt;base href=\u0026#34;http://www.w3school.com.cn/images/\u0026#34; /\u0026gt; \u0026lt;base target=\u0026#34;_blank\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;mystyle.css\u0026#34; /\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; body {background-color:yellow} p {color:blue} \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; 常用标签 分隔  \u0026lt;hr /\u0026gt; 水平线 \u0026lt;br /\u0026gt; 换行  注释 \u0026lt;!-- This is a comment --\u0026gt; 语义    标签 描述     \u0026lt;header\u0026gt; 文档或节的页眉   \u0026lt;nav\u0026gt; 导航链接的容器   \u0026lt;section\u0026gt; 文档中的节   \u0026lt;article\u0026gt; 独立的自包含文章   \u0026lt;aside\u0026gt; 内容之外的内容（比如侧栏）   \u0026lt;footer\u0026gt; 文档或节的页脚   \u0026lt;details\u0026gt; 额外的细节   \u0026lt;summary\u0026gt; details 元素的标题   \u0026lt;bdi\u0026gt; 与其他文本不同的文本方向   \u0026lt;dialog\u0026gt; 对话框或窗口   \u0026lt;figure\u0026gt; 自包含内容，比如图示、图表、照片、代码清单   \u0026lt;main\u0026gt; 文档的主内容   \u0026lt;mark\u0026gt; 重要或强调的内容   \u0026lt;menuitem\u0026gt; 用户能够从弹出菜单调用的命令/菜单项目   \u0026lt;meter\u0026gt; 已知范围（尺度）内的标量测量   \u0026lt;progress\u0026gt; 任务进度   \u0026lt;time\u0026gt; 日期/时间   \u0026lt;wbr\u0026gt; 可能的折行    文本    标签 描述     \u0026lt;h1\u0026gt;-\u0026lt;h6\u0026gt; 标题   \u0026lt;p\u0026gt; 段落   \u0026lt;b\u0026gt; 粗体文本   \u0026lt;big\u0026gt; 大号字   \u0026lt;em\u0026gt; 着重文字   \u0026lt;i\u0026gt; 斜体字   \u0026lt;small\u0026gt; 小号字   \u0026lt;strong\u0026gt; 加重语气   \u0026lt;sub\u0026gt; 下标字   \u0026lt;sup\u0026gt; 上标字   \u0026lt;ins\u0026gt; 插入字   \u0026lt;del\u0026gt; 删除字   \u0026lt;code\u0026gt; 计算机代码   \u0026lt;kbd\u0026gt; 键盘码   \u0026lt;samp\u0026gt; 计算机代码样本   \u0026lt;tt\u0026gt; 打字机代码   \u0026lt;var\u0026gt; 变量   \u0026lt;pre\u0026gt; 预格式文本   \u0026lt;abbr\u0026gt; 缩写   \u0026lt;acronym\u0026gt; 首字母缩写   \u0026lt;address\u0026gt; 地址   \u0026lt;bdo\u0026gt; 文字方向   \u0026lt;blockquote\u0026gt; 长的引用   \u0026lt;q\u0026gt; 短的引用语   \u0026lt;cite\u0026gt; 引用、引证   \u0026lt;dfn\u0026gt; 一个定义项目   \u0026lt;a\u0026gt; 超链接    \u0026lt;a href=\u0026#34;url\u0026#34; target=\u0026#34;_blank\u0026#34; name=\u0026#34;name\u0026#34;\u0026gt;text\u0026lt;/a\u0026gt; 列表    标签 描述     \u0026lt;ul\u0026gt; 无序列表   \u0026lt;ol\u0026gt; 有序列表   \u0026lt;li\u0026gt; 项   \u0026lt;dl\u0026gt; 自定义列表   \u0026lt;dt\u0026gt; 自定义列表项头   \u0026lt;dd\u0026gt; 自定义列表项内容    表格    标签 描述     \u0026lt;table\u0026gt; 定义表格   \u0026lt;th\u0026gt; 表头   \u0026lt;tr\u0026gt; 行   \u0026lt;td\u0026gt; 单元格数据    \u0026lt;table border=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Heading\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Another Heading\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;row 1, cell 1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;row 1, cell 2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;row 2, cell 1\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;row 2, cell 2\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; 表单 \u0026lt;form\u0026gt; 元素。\n   标签 描述     \u0026lt;input\u0026gt; 多种类型   \u0026lt;select\u0026gt; 下拉列表   \u0026lt;textarea\u0026gt; 多行输入字段（文本域）   \u0026lt;button\u0026gt; 按钮   \u0026lt;datalist\u0026gt; 为 \u0026lt;input\u0026gt; 元素规定预定义选项列表       \u0026lt;input\u0026gt; 输入类型 描述     text 供文本输入的单行输入字段   password 密码字段   radio 单选按钮   checkbox 复选框   submit 提交表单数据至表单处理程序的按钮   button 按钮   color 颜色   date 日期   datetime 日期和时间（有时区）   datetime-local 日期和时间（无时区）   month 月份和年份   week 周和年   time 选择时间（无时区）   number 数字值   range 一定范围内的值   email 电子邮件地址的输入字段   search 搜索字段（搜索字段的表现类似常规文本字段）   tel 电话号码   url URL 地址    \u0026lt;form action=\u0026#34;action_page.php\u0026#34; method=\u0026#34;GET\u0026#34;\u0026gt; First name:\u0026lt;br/\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;firstname\u0026#34; value=\u0026#34;Mickey\u0026#34;\u0026gt;\u0026lt;br\u0026gt; Last name:\u0026lt;br/\u0026gt;\u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;lastname\u0026#34; value=\u0026#34;Mouse\u0026#34;\u0026gt;\u0026lt;br/\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;select name=\u0026#34;cars\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;volvo\u0026#34;\u0026gt;Volvo\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;saab\u0026#34;\u0026gt;Saab\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;fiat\u0026#34;\u0026gt;Fiat\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;audi\u0026#34;\u0026gt;Audi\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;input list=\u0026#34;browsers\u0026#34;\u0026gt; \u0026lt;datalist id=\u0026#34;browsers\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Internet Explorer\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Firefox\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Chrome\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Opera\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;Safari\u0026#34;\u0026gt; \u0026lt;/datalist\u0026gt; 媒体 绘图 HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。 画布是一个矩形区域，您可以控制其每一像素。 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。\n\u0026lt;canvas id=\u0026#34;myCanvas\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;100\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; 内联 SVG：\n\u0026lt;svg xmlns=\u0026#34;http://www.w3.org/2000/svg\u0026#34; version=\u0026#34;1.1\u0026#34; height=\u0026#34;190\u0026#34;\u0026gt; \u0026lt;polygon points=\u0026#34;100,10 40,180 190,60 10,60 160,180\u0026#34; style=\u0026#34;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;\u0026#34; /\u0026gt; \u0026lt;/svg\u0026gt;  Canvas  依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘   SVG  不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用    图像 \u0026lt;img src=\u0026#34;url\u0026#34; alt=\u0026#34;text\u0026#34;/\u0026gt; 音频 \u0026lt;audio controls=\u0026#34;controls\u0026#34; height=\u0026#34;100\u0026#34; width=\u0026#34;100\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;song.mp3\u0026#34; type=\u0026#34;audio/mp3\u0026#34; /\u0026gt; \u0026lt;source src=\u0026#34;song.ogg\u0026#34; type=\u0026#34;audio/ogg\u0026#34; /\u0026gt; \u0026lt;embed height=\u0026#34;100\u0026#34; width=\u0026#34;100\u0026#34; src=\u0026#34;song.mp3\u0026#34; /\u0026gt; \u0026lt;/audio\u0026gt; 视频 \u0026lt;video width=\u0026#34;320\u0026#34; height=\u0026#34;240\u0026#34; controls=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;source src=\u0026#34;movie.mp4\u0026#34; type=\u0026#34;video/mp4\u0026#34; /\u0026gt; \u0026lt;source src=\u0026#34;movie.ogg\u0026#34; type=\u0026#34;video/ogg\u0026#34; /\u0026gt; \u0026lt;source src=\u0026#34;movie.webm\u0026#34; type=\u0026#34;video/webm\u0026#34; /\u0026gt; \u0026lt;object data=\u0026#34;movie.mp4\u0026#34; width=\u0026#34;320\u0026#34; height=\u0026#34;240\u0026#34;\u0026gt; \u0026lt;embed src=\u0026#34;movie.swf\u0026#34; width=\u0026#34;320\u0026#34; height=\u0026#34;240\u0026#34; /\u0026gt; \u0026lt;/object\u0026gt; \u0026lt;/video\u0026gt; 网页 \u0026lt;iframe src=\u0026#34;demo_iframe.htm\u0026#34; width=\u0026#34;200\u0026#34; height=\u0026#34;200\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; 分块  \u0026lt;div\u0026gt; 块元素，可容纳其他元素 \u0026lt;span\u0026gt; 内联元素，可容纳其他元素  更多  \u0026lt;object\u0026gt; 插件 \u0026lt;embed\u0026gt; 外部（非 HTML）内容的容器  元素属性 共有属性：\n   属性名 功能     class 对元素分类   id 元素唯一标识符    脚本 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; document.write(\u0026#34;Hello World!\u0026#34;) \u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;url\u0026#34; /\u0026gt; 样式  在文档头部引用外部样式表  \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;mystyle.css\u0026#34;\u0026gt;  在文档头部使用内部样式表  \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; body {background-color: red} p {margin-left: 20px} \u0026lt;/style\u0026gt;  使用元素的 style 属性设置内联样式  参考资料  HTML 教程  ","date":"2018-09-06T14:16:00+08:00","image":"https://raw.githubusercontent.com/github/explore/80688e429a7d4ef2fca1e82350fe8e3517d3494d/topics/html/html.png","permalink":"https://stardustdl.github.io/posts/tools/proglang-html/","title":"Hyper Text Markup Language"},{"content":"基本信息  官网 介绍：Vim 是一个功能非常强大，且具有很强扩展性的编辑器。  安装 apt install vim 基础  i 插入模式（当前字符之前） h j k l 四方向移动 x 删除当前字符 dd 删除当前行 J 删除换行符 u 撤销 Ctrl+R 重做 U 撤销当前行的所有操作 a 插入模式（当前字符之后） I 移动前行第一个非空字符，进入插入模式 A 移动到行尾字符，进入插入模式 o 下方建立新行，进入插入模式 O 上方建立新行，进入插入模式  移动 计数+动作=多次执行\n词移动  w b 到前/后词首 e ge 到前/后词尾 W B 到前/后词首 E gE 到前/后词尾  行中移动  $ 行尾 ^ 第一个非空字符 O 行首  行中指定字符  fx Fx 向前/后字符x tx Tx 向前/后字符x前 ; 重复上个命令 , 反向重复上个命令  匹配括号  %  指定行  2G 第二行 G 文件末 gg 文件首 50% 移动到文本的50%位置  滚屏  Ctrl+U/D 上/下半屏 Ctrl+E/Y 上/下一行 Ctrl+F/B 上/下一屏 zz 光标到中间 zt 光标到顶部 zb 光标到底部  查找  /str 查找下一个 str，支持方向键访问历史，历史模式匹配 n 下一个匹配项 ?str 查找上一个 str N 反方向重复前一次查找 :set [no]ignorecase 大小写 * 查找当前单词的下一个（全字匹配）  g* 非全字匹配   # 查找当前单词的上一个（全字匹配）  g# 非全字匹配   :set [no]hlsearch 高亮 特殊记号：  \\\u0026gt; 匹配单次末尾 \\\u0026lt; 匹配单次开头 ^ 行首 $ 行尾 . 单个字符 反斜杠取消转义    标记  `` \u0026lsquo;' 跳转回上次跳转前的位置 Ctrl-O 跳到一个较老的地方 Ctrl-I 跳到一个较新的地方 :jumps 查看跳转位置列表 自定义标记：  ma 用 a 标记当前位置 `a 跳到 a 标记的位置 ‘a 跳到 a 标记的行的行首 :marks 查看标记列表   预定义标记：  ' 跳转前的光标位置 \u0026quot; 最后编辑的光标位置 [ 最后修改的开始位置 ] 最后修改的结束位置    文本对象  For more: text-objects\n  aw = A word is = Inner sentence as = A sentence  改动  ~ 改变当前字符大小写，并移动到下个字符（不是操作符，不能连接一个动作命令，但在可视模式中可范围作用）  删除等操作的文本会被存储到寄存器中\n d 删除操作符  dd 删除当前行   c 修改（删除+进入插入模式）操作符  cc 修改当前行（仅保留缩进）   x =dl，删除当前光标字符 X =dh，删除当前光标左边字符 D =d$ C =c$ s =cl S =cc rx 使用字符x替换当前字符  4rx 删除4个字符，插入x   . 重复上一次修改操作 p 当前光标处插入寄存器的内容，配合计数可复制多次  通过对第一个字符执行 xp 实现交换其与其后字符   P 当前光标前插入寄存器的内容 y 将当前文本存储到寄存器中  Y yy 拷贝一整行     在支持剪切板的vim中（clipboard）\n  在 y p 命令前加入 \u0026quot;* 实现对剪贴板的操作  操作符+动作模式/文本对象=区域操作\n模式 可视模式 选择一部分，然后按操作符\n v 普通可视模式 V 按行可视模式 Ctrl+V 区块可视模式 o O 移动到选中区域的另一端（或对角）  替换模式  R 替换模式（覆盖原文本）  编辑  Ctrl+P 猜测补全  离开和继续  Ctrl+Z :suspend 挂起，回到shell fg 从挂起状态恢复 :!{command} 执行单个外壳命令  :!ls   :mksession vimbook.vim 创建一个会话文件 :source vimbook.vim 还原会话  vim -S vimbook.vim    文件 命令后缀 ! 表示强制\n :quit :q 退出 :enter :e 装载当前文件 :edit filename 关闭当前文件，打开指定文件 :write :w 写入当前文件  :wall 全部存盘   :saveas a 另存为a :file a 改变当前文件名，但不保存（且原文件不受影响） vim a b c 打开多个文件（先进入第一个）  :next 进入下个文件  :wnext 等价于 :write \u0026amp; :next   :previous 进入上个文件  :wprevious   :last :first   :args 查看打开文件列表 :args a b c 打开多个文件（支持通配符，如 *.txt） Ctrl+^ 两个文件间快速跳转 标记：  \u0026quot; 上次离开此文件的位置 . 最后一次修改的位置    参考资料  vimcdoc  ","date":"2018-09-06T10:20:00+08:00","image":"https://github.com/vim/vim/raw/master/runtime/vimlogo.gif","permalink":"https://stardustdl.github.io/posts/tools/vim/","title":"Vim"},{"content":"基本信息  介绍：结构化查询语言，用于存取数据以及查询、更新和管理关系数据库系统。存在着很多不同版本的 SQL 语言，但是为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的关键词。但许多相似语义的内容其具体写法可能会有不同。  SQL 对大小写不敏感。 SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号）。 使用 SQL 需先了解具体数据库的描述方法。\n数据操作语言 SELECT SELECT 语句用于从表中选取数据。\nSELECTcolumnFROMtable_name 从名为 \u0026ldquo;Persons\u0026rdquo; 的数据库表，获取名为 \u0026ldquo;LastName\u0026rdquo; 和 \u0026ldquo;FirstName\u0026rdquo; 的列的内容  SELECTLastName,FirstNameFROMPersons 从 \u0026ldquo;Persons\u0026rdquo; 表中选取所有的列。  SELECT*FROMPersonsDISTINCT 关键词 DISTINCT 用于返回唯一不同的值。\n 从 Company\u0026quot; 列中仅选取唯一不同的值  SELECTDISTINCTCompanyFROMOrdersWHERE 如需有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。\n 选取居住在城市 \u0026ldquo;Beijing\u0026rdquo; 中的人  SELECT*FROMPersonsWHERECity=\u0026#39;Beijing\u0026#39;可用运算符：\n   操作符 描述     = 等于   \u0026lt;\u0026gt; 不等于   \u0026gt; 大于   \u0026lt; 小于   \u0026gt;= 大于等于   \u0026lt;= 小于等于   BETWEEN 在某个范围内   IN 规定多个可能取值   LIKE 搜索某种模式   AND 合取两个条件   OR 析取两个条件   NOT 条件取反    SELECT*FROMPersonsWHERE(FirstName=\u0026#39;Thomas\u0026#39;ORFirstName=\u0026#39;William\u0026#39;)ANDLastName=\u0026#39;Carter\u0026#39;LIKE LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。\n   通配符 描述     % 替代一个或多个字符   _ 仅替代一个字符   [charlist] 字符列中的任何单一字符   [^charlist] 或 [!charlist] 不在字符列中的任何单一字符     选取居住在以 \u0026ldquo;N\u0026rdquo; 开始的城市里的人  SELECT*FROMPersonsWHERECityLIKE\u0026#39;N%\u0026#39;SELECT*FROMPersonsWHERECityNOTLIKE\u0026#39;%lon%\u0026#39;SELECT*FROMPersonsWHERELastNameLIKE\u0026#39;C_r_er\u0026#39;SELECT*FROMPersonsWHERECityLIKE\u0026#39;[ALN]%\u0026#39;SELECT*FROMPersonsWHERECityLIKE\u0026#39;[!ALN]%\u0026#39;IN IN 操作符允许我们在 WHERE 子句中规定多个可能的取值。\nSELECTcolumn_name(s)FROMtable_nameWHEREcolumn_nameIN(value1,value2,...)BETWEEN AND 操作符 BETWEEN \u0026hellip; AND 会选取介于两个值之间的数据范围。这些值可以是数值、文本或者日期。\nSELECTcolumn_name(s)FROMtable_nameWHEREcolumn_nameBETWEENvalue1ANDvalue2不同的数据库对 BETWEEN\u0026hellip;AND 操作符的处理方式是有差异的。区间端点的选择是不确定的。\nORDER BY ORDER BY 语句用于对结果集进行排序。如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。\nSELECTCompany,OrderNumberFROMOrdersORDERBYCompanySELECTCompany,OrderNumberFROMOrdersORDERBYCompanyDESC主次关键字，以及主次关键字采用不同顺序：\nSELECTCompany,OrderNumberFROMOrdersORDERBYCompany,OrderNumberSELECTCompany,OrderNumberFROMOrdersORDERBYCompanyDESC,OrderNumberASCTOP TOP 子句用于规定要返回的记录的数目。\n 从 \u0026ldquo;Persons\u0026rdquo; 表中选取头两条记录  SELECTTOP2*FROMPersons 从 \u0026ldquo;Persons\u0026rdquo; 表中选取选取 50% 的记录。  SELECTTOP50PERCENT*FROMPersonsAS  表的 SQL Alias 语法  SELECTcolumn_name(s)FROMtable_nameASalias_name可以使用别名简化书写。\nSELECTpo.OrderID,p.LastName,p.FirstNameFROMPersonsASp,Product_OrdersASpoWHEREp.LastName=\u0026#39;Adams\u0026#39;ANDp.FirstName=\u0026#39;John\u0026#39; 列的 SQL Alias 语法  SELECTcolumn_nameASalias_nameFROMtable_name可以改变返回列表的列名。\nSELECTLastNameASFamily,FirstNameASNameFROMPersonsJOIN JOIN 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。\n数据库中的表可通过键将彼此联系起来。主键（Primary Key）是一个列，在这个列中的每一行的值都是唯一的。在表中，每个主键的值都是唯一的。这样做的目的是在不重复每个表中的所有数据的情况下，把表间的数据交叉捆绑在一起。\nSELECTPersons.LastName,Persons.FirstName,Orders.OrderNoFROMPersonsINNERJOINOrdersONPersons.Id_P=Orders.Id_PORDERBYPersons.LastName JOIN 或 INNER JOIN: 如果两个表中有至少一个匹配，则返回行 LEFT JOIN: 即使右表中没有匹配，也从左表返回所有的行 RIGHT JOIN: 即使左表中没有匹配，也从右表返回所有的行 FULL JOIN: 即使没有匹配，也从返回两表所有的行  UNION UNION 操作符用于合并两个或多个 SELECT 语句的结果集。请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 UNION ALL。另外，UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。\nSELECTcolumn_name(s)FROMtable_name1UNIONSELECTcolumn_name(s)FROMtable_name2UPDATE Update 语句用于修改表中的数据。\nUPDATEtable_nameSETcolumn_name=new_valueWHEREcolumn_name=a_value为 lastname 是 \u0026ldquo;Wilson\u0026rdquo; 的人添加 firstname：\nUPDATEPersonSETFirstName=\u0026#39;Fred\u0026#39;WHERELastName=\u0026#39;Wilson\u0026#39;更新多列：\nUPDATEPersonSETAddress=\u0026#39;Zhongshan 23\u0026#39;,City=\u0026#39;Nanjing\u0026#39;WHERELastName=\u0026#39;Wilson\u0026#39;DELETE DELETE 语句用于删除表中的行。\nDELETEFROMtable_nameWHEREcolumn=a_value删除所有行：\nDELETEFROMtable_nameDELETE*FROMtable_nameINSERT INTO INSERT INTO 语句用于向表格中插入新的行。\nINSERTINTOtable_nameVALUES(value1,value2,....)INSERTINTOtable_name(column1,column2,...)VALUES(value1,value2,....)SELECT INTO SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中。 SELECT INTO 语句常用于创建表的备份复件或者用于对记录进行存档。\n 把所有的列插入新表  SELECT*INTOnew_table_name[INexternaldatabase]FROMold_tablename 只把希望的列插入新表  SELECTcolumn_name(s)INTOnew_table_name[INexternaldatabase]FROMold_tablename可结合 WHERE 子句，JOIN 子句等。\n数据定义语言 CREATE DATABASE CREATE DATABASE 用于创建数据库。\nCREATEDATABASEdatabase_nameCREATE TABLE CREATE TABLE 语句用于创建数据库中的表。\nCREATETABLEtable_name(column_name1datatype,column_name2datatype,column_name3datatype,....)关于数据类型，不同数据库有一定差别，参见 SQL 数据类型。\nCREATE INDEX CREATE INDEX 语句用于在表中创建索引。 在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。用户无法看到索引，它们只能被用来加速搜索/查询。更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列（以及表）上面创建索引。\n 在表上创建一个简单的索引。允许使用重复的值：\u0026ldquo;column_name\u0026rdquo; 规定需要索引的列。  CREATEINDEXindex_nameONtable_name(column_name) 在表上创建一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。  CREATEUNIQUEINDEXindex_nameONtable_name(column_name) 以降序索引某个列中的值  CREATEINDEXPersonIndexONPerson(LastNameDESC)ALTER TABLE ALTER TABLE 语句用于在已有的表中添加、修改或删除列。\n 在表中添加列  ALTERTABLEtable_nameADDcolumn_namedatatype 删除表中的列  ALTERTABLEtable_nameDROPCOLUMNcolumn_name 改变表中列的数据类型  ALTERTABLEtable_nameALTERCOLUMNcolumn_namedatatypeDROP 通过使用 DROP 语句，可以轻松地删除索引、表和数据库。\n DROP INDEX index_name DROP TABLE table_name DROP DATABASE database_name TRUNCATE TABLE table_name 仅仅删除表格中的数据  AUTO INCREMENT Auto-increment 会在新记录插入表中时生成一个唯一的数字。\nCREATETABLEPersons(P_IdintNOTNULLAUTO_INCREMENT,LastNamevarchar(255)NOTNULL,FirstNamevarchar(255),Addressvarchar(255),Cityvarchar(255),PRIMARYKEY(P_Id))ALTERTABLEPersonsAUTO_INCREMENT=100数据约束 约束用于限制加入表的数据的类型。 可以在创建表时规定约束（通过 CREATE TABLE 语句，在数据类型后标注），或者在表创建之后也可以（通过 ALTER TABLE 语句）。 约束可命名，用于取消约束。\nNOT NULL NOT NULL 约束强制列不接受 NULL 值。\nUNIQUE UNIQUE 约束唯一标识数据库表中的每条记录。 UNIQUE 和 PRIMARY KEY 约束均为列或列集合提供了唯一性的保证。PRIMARY KEY 拥有自动定义的 UNIQUE 约束。 请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。\nPRIMARY KEY PRIMARY KEY 约束唯一标识数据库表中的每条记录。 主键必须包含唯一的值。主键列不能包含 NULL 值。 每个表都应该有一个主键，并且每个表只能有一个主键。\nFOREIGN KEY 一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY。\nCREATETABLEOrders(Id_OintNOTNULLPRIMARYKEY,OrderNointNOTNULL,Id_PintFOREIGNKEYREFERENCESPersons(Id_P))CREATETABLEOrders(Id_OintNOTNULL,OrderNointNOTNULL,Id_Pint,PRIMARYKEY(Id_O),CONSTRAINTfk_PerOrdersFOREIGNKEY(Id_P)REFERENCESPersons(Id_P))ALTERTABLEOrdersADDFOREIGNKEY(Id_P)REFERENCESPersons(Id_P)ALTERTABLEOrdersADDCONSTRAINTfk_PerOrdersFOREIGNKEY(Id_P)REFERENCESPersons(Id_P)ALTERTABLEOrdersDROPFOREIGNKEYfk_PerOrdersALTERTABLEOrdersDROPCONSTRAINTfk_PerOrdersCHECK CHECK 约束用于限制列中的值的范围。 如果对单个列定义 CHECK 约束，那么该列只允许特定的值。 如果对一个表定义 CHECK 约束，那么此约束会在特定的列中对值进行限制。\nDEFAULT DEFAULT 约束用于向列中插入默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。\n参考资料  SQL 教程  ","date":"2018-09-03T18:51:10+08:00","permalink":"https://stardustdl.github.io/posts/tools/proglang-sql/","title":"Structured Query Language"},{"content":"基本信息  官网 介绍：PHP 是一种创建动态交互性站点的强有力的服务器端脚本语言。PHP 脚本在服务器上执行，然后向浏览器发送回纯 HTML 结果。 安装：使用支持 PHP 的 Web 主机，安装 PHP 和 MySQL  语法  PHP 脚本可放置于文档中的任何位置。 PHP 脚本以 \u0026lt;?php 开头，以 ?\u0026gt; 结尾： PHP 文件的默认文件扩展名是 \u0026ldquo;.php\u0026rdquo;。 PHP 文件通常包含 HTML 标签以及一些 PHP 脚本代码。 语句以分号结尾（;） 注释  // one-line  # one-line  /* multi-line */  所有用户定义的函数、类和关键词（例如 if、else、echo 等等）都对大小写不敏感。所有变量都对大小写敏感。  变量  变量规则：  变量以 $ 符号开头，其后是变量的名称 变量名称必须以字母或下划线开头 变量名称不能以数字开头 变量名称只能包含字母数字字符和下划线（A-z、0-9 以及 _） 变量名称对大小写敏感（$y 与 $Y 是两个不同的变量）   变量会在首次为其赋值时被创建 作用域  函数之外声明的变量拥有 global 作用域，只能在函数以外进行访问。 函数内部声明的变量拥有 local 作用域，只能在函数内部进行访问。 static 关键词用于声明静态局部变量。 global 关键词用于访问函数内的全局变量。 PHP 同时在名为 $GLOBALS[index] 的数组中存储了所有的全局变量。下标存有变量名。这个数组在函数内也可以访问，并能够用于直接更新全局变量。    $x=5; $y=10; function myTest() { global $x,$y; $y=$x+$y; } myTest(); echo $y; // 输出 15 输出  echo 能够输出一个以上的字符串，无返回值。有无括号均可使用：echo 或 echo()。 print 只能输出一个字符串，并始终返回 1。有无括号均可使用：print 或 print()。  字符串中加入对变量，数组某位置的引用：\n$txt1=\u0026#34;Learn PHP\u0026#34;; $txt2=\u0026#34;W3School.com.cn\u0026#34;; $cars=array(\u0026#34;Volvo\u0026#34;,\u0026#34;BMW\u0026#34;,\u0026#34;SAAB\u0026#34;); echo $txt1; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;Study PHP at $txt2\u0026#34;; echo \u0026#34;My car is a {$cars[0]}\u0026#34;; 数据类型  字符串：字符串可以是引号内的任何文本。可以使用单引号或双引号 整数  整数必须有至少一个数字（0-9） 整数不能包含逗号或空格 整数不能有小数点 整数正负均可 可以用三种格式规定整数：十进制、十六进制（前缀是 0x）或八进制（前缀是 0）   浮点数：浮点数是有小数点或指数形式的数字。10.3 2.4e3 逻辑值（布尔值）：true false 数组：array(\u0026quot;Volvo\u0026quot;,\u0026quot;BMW\u0026quot;,\u0026quot;SAAB\u0026quot;) 对象：对象是存储数据和有关如何处理数据的信息的数据类型。首先必须声明对象的类。 NULL：特殊的 NULL 值表示变量无值。NULL 是数据类型 NULL 唯一可能的值。  NULL 值标示变量是否为空。也用于区分空字符串与空值数据库。 可以通过把值设置为 NULL，将变量清空：     使用 var_dump 函数查看变量类型和变量名。\n 常量 常量是单个值的标识符（名称）。在脚本中无法改变该值。有效的常量名以字符或下划线开头（常量名称前面没有 $ 符号）。与变量不同，常量贯穿整个脚本是自动全局的。 如需设置常量，请使用 define() 函数 - 它使用三个参数：\n 首个参数定义常量的名称 第二个参数定义常量的值 可选的第三个参数规定常量名是否对大小写不敏感。默认是 false。  define(\u0026#34;GREETING\u0026#34;, \u0026#34;Welcome to W3School.com.cn!\u0026#34;,true); 数组 array() 函数用于创建数组。count()返回数组的长度（元素数）。\n 索引数组 - 带有数字索引的数组  $cars=array(\u0026#34;Volvo\u0026#34;,\u0026#34;BMW\u0026#34;,\u0026#34;SAAB\u0026#34;); $cars=array(); $cars[0]=\u0026#34;Volvo\u0026#34;; $cars[1]=\u0026#34;BMW\u0026#34;; $cars[2]=\u0026#34;SAAB\u0026#34;; $arrlength=count($cars); for($x=0;$x\u0026lt;$arrlength;$x++) { echo $cars[$x]; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; }  关联数组 - 带有指定键的数组  $age=array(\u0026#34;Peter\u0026#34;=\u0026gt;\u0026#34;35\u0026#34;,\u0026#34;Ben\u0026#34;=\u0026gt;\u0026#34;37\u0026#34;,\u0026#34;Joe\u0026#34;=\u0026gt;\u0026#34;43\u0026#34;); $age=array(); $age[\u0026#39;Peter\u0026#39;]=\u0026#34;35\u0026#34;; $age[\u0026#39;Ben\u0026#39;]=\u0026#34;37\u0026#34;; $age[\u0026#39;Joe\u0026#39;]=\u0026#34;43\u0026#34;; foreach($age as $x=\u0026gt;$x_value) { echo \u0026#34;Key=\u0026#34; . $x . \u0026#34;, Value=\u0026#34; . $x_value; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; }  多维数组 - 包含一个或多个数组的数组  $cars = array ( array(\u0026#34;Volvo\u0026#34;,22,18), array(\u0026#34;BMW\u0026#34;,15,13), array(\u0026#34;Saab\u0026#34;,5,2), array(\u0026#34;Land Rover\u0026#34;,17,15) ); 超全局变量 超全局变量是在全部作用域中始终可用的内置变量。\n $GLOBALS 用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）  名为 $GLOBALS[index] 的数组中存储了所有全局变量。变量的名字就是数组的键。   $_SERVER 保存关于报头、路径和脚本位置的信息。 $_REQUEST 用于收集 HTML 表单提交的数据。 $_POST 广泛用于收集提交 method=\u0026ldquo;post\u0026rdquo; 的 HTML 表单后的表单数据。$_POST 也常用于传递变量。 $_GET 可用于收集提交 HTML 表单 (method=\u0026ldquo;get\u0026rdquo;) 之后的表单数据。也可以收集 URL 中的发送的数据。 $_FILES $_ENV $_COOKIE $_SESSION  表达式 运算符  + - * / % ++ -- == != \u0026lt;\u0026gt; \u0026gt; \u0026lt; \u0026gt;= \u0026lt;= === !== 全等：相等且类型相同：100==\u0026quot;100\u0026quot; 但 100!==\u0026quot;100\u0026quot; and or xor \u0026amp;\u0026amp; || ! 逻辑运算符 = += -= *= /= %= 串运算符  . 串连接 .= 串连接赋值   数组运算符  + 联合（但不覆盖重复的键） == != \u0026lt;\u0026gt; 拥有相同的键/值对 === !== 拥有相同的键/值对，且顺序相同类型相同    语句 选择语句 if (condition) {} elseif (condition) {} else {} switch (expression) { case label1: break; case label2: break; default: } 迭代语句 while (condition) {} do {} while (condition); for (init;condition;step) {} foreach ($array as $value) {} 函数 自定义函数 函数名能够以字母或下划线开头，且对大小写不敏感。可以通过参数向函数传递信息。参数类似变量。参数被定义在函数名之后，括号内部。您可以添加任意多参数，只要用逗号隔开即可。\nfunction functionName($arg1=\u0026#34;default\u0026#34;,$arg2) { return arg1 . arg2; } 内置函数 (TODO)\n参考资料  PHP 教程  ","date":"2018-09-03T10:20:00+08:00","image":"https://raw.githubusercontent.com/github/explore/ccc16358ac4530c6a69b1b80c7223cd2744dea83/topics/php/php.png","permalink":"https://stardustdl.github.io/posts/tools/proglang-php/","title":"PHP Hypertext Preprocessor"},{"content":"基本信息  介绍：XML 被设计用来传输和存储数据，具有自我描述性。  语法 XML 文档形成一种树结构。\n 所有元素都须有关闭标签。 标签对大小写敏感 必须正确地嵌套 必须包含根元素 属性值须加引号 空格会被保留  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;root name=\u0026#34;_root\u0026#34;\u0026gt; \u0026lt;child\u0026gt; \u0026lt;subchild\u0026gt;.....\u0026lt;/subchild\u0026gt; \u0026lt;/child\u0026gt; \u0026lt;/root\u0026gt; 元数据（有关数据的数据）应当存储为属性，而数据本身应当存储为元素。\n特殊字符    原字符 转义     \u0026lt; \u0026amp;lt;   \u0026gt; \u0026amp;ge;   \u0026amp; \u0026amp;amp;   ' \u0026amp;apos;   \u0026quot; \u0026amp;quot;    注释 \u0026lt;!-- comment --\u0026gt; 元素命名  名称可以含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字符 “xml”（或者 XML、Xml）开始 名称不能包含空格  命名空间 定义 XML 命名空间属性被放置于元素的开始标签之中，并使用以下的语法：\nxmlns:namespace-prefix=\u0026#34;namespaceURI\u0026#34; 当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联。\n使用 \u0026lt;f:table xmlns:f=\u0026#34;http://www.w3school.com.cn/furniture\u0026#34;\u0026gt; \u0026lt;f:name\u0026gt;African Coffee Table\u0026lt;/f:name\u0026gt; \u0026lt;f:width\u0026gt;80\u0026lt;/f:width\u0026gt; \u0026lt;f:length\u0026gt;120\u0026lt;/f:length\u0026gt; \u0026lt;/f:table\u0026gt; 默认命名空间：\n\u0026lt;table xmlns=\u0026#34;http://www.w3.org/TR/html4/\u0026#34;\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Apples\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;Bananas\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; CDATA 术语 CDATA 指的是不应由 XML 解析器进行解析的文本数据（Unparsed Character Data）。 CDATA 部分中的所有内容都会被解析器忽略。 CDATA 部分由 \u0026lt;![CDATA[ 开始，由 ]]\u0026gt; 结束。\nXML 语法描述（验证）  DTD XML Schema  XML 样式  CSS 样式  \u0026lt;?xml-stylesheet type=\u0026#34;text/css\u0026#34; href=\u0026#34;style.css\u0026#34;?\u0026gt;  XSLT (eXtensible Stylesheet Language Transformations) 样式  \u0026lt;?xml-stylesheet type=\u0026#34;text/xsl\u0026#34; href=\u0026#34;style.xsl\u0026#34;?\u0026gt; 参考资料  XML 教程  ","date":"2018-09-02T18:16:01+08:00","permalink":"https://stardustdl.github.io/posts/tools/proglang-xml/","title":"eXtensible Markup Language"},{"content":"本文介绍使用栈实现队列和使用队列实现栈的方法。为使问题更加有意义，我们将尽量选择一个较优的实现方法。\n问题引入  栈：先进后出的线性结构，仅允许对栈顶进行添加（push），删除（pop），访问（peek）操作，空间复杂度线性，单次操作时间复杂度为常数 队列：先进先出线性结构，仅允许对队尾进行添加（enqueue）操作，以及对队首进行删除（dequeue），访问（peek）操作，空间复杂度线性，单次操作时间复杂度为常数 需要解决的问题，在使用常数个额外空间的条件下：  使用两个栈尽可能高效地实现一个队列 使用两个队列尽可能高效地实现一个栈    解决方法 使用栈实现队列 思路 考虑到栈先进后出与队列先进先出的特点，使用一个栈 $A$ 作为队列尾，数据从这里流入；使用另一个栈 $B$ 作为队列头，数据从这里流出。我们要求先流入的数据先流出， 通过将栈 $A$ 中的元素不断弹出，并压入栈 $B$，利用先进后出特性，$B$ 的出栈顺序即 $A$ 出栈顺序的逆序，而 $A$ 出栈顺序为其入栈顺序的逆序，故 $B$ 的出栈顺序为 $A$ 的入栈顺序，即达到先进先出的效果。\n 栈能将输入逆序这一点很重要，之后我们还将用到。\n 复杂度分析  空间复杂度：栈的空间复杂度是线性的，而且这里队列中的每一个数据仅会在两个栈中的某一个中存在，故此实现的空间复杂度为线性 时间复杂度：注意到每个数据从入队到出队只会经历：进入 $A$，离开 $A$，进入 $B$，离开 $B$ 四次移动，且每次移动复杂度为常数，故均摊复杂度为常数。  使用队列实现栈 思路  这里遇到了个难题：利用栈可以很容易地支持翻转操作，但队列无法直接对输入序列进行顺序的改变。\n 队列中一个重要特点是，我们可以通过不断删除队列头，并将其放入队列尾，实现在不影响顺序的前提下对队列中每个元素的访问，访问一遍后，我们仍可以很容易恢复到最初的队列状态。 但这一操作的弊端是，我们访问某个元素，必须将其前面的所有元素出队，这一操作的时间复杂度是最坏情况下是线性的。\n 既然我们能访问所有元素了，那只要访问最后一个就是先入后出了，很简单嘛，可是队列“滚”的次数太多了（为线性）\u0026hellip;\n 为下文叙述方便，将上述操作定义为过程“循环出入队”，即将队首出队后入队，实现队列滚动。时间复杂度由以上分析，为 $O(|Q|))$。 我们使用一个类似缓冲池的技巧：设两个队列 $Q_s,Q_a$，$Q_a$ 用于存储靠近栈顶的一部分元素，$Q_s$ 用于存储其余的元素。其中 $Q_a$ 有可变的容量上限 $cap(Q_a)$，$Q_s$ 容量无限制。\n 你可以把 $Q_s$ 看成内存（主存），把 $Q_a$ 看成 CPU 中的高速缓存\n 接下来，我们依次实现栈的三个操作：\n 入栈操作   若 $Q_a$ 不满，直接入队到 $Q_a$ 。时间复杂度：$O(1)$ 若 $Q_a$ 满，将 $Q_a$ 出队，并将队列头入队到 $Q_s$。然后将待入栈元素入队到 $Q_a$。时间复杂度：$O(1)$  出栈操作   若 $Q_a$ 非空，对 $Q_a$ 循环出入队，使得原队尾在队头，返回队尾，并出队。时间复杂度：$O(|Q_a|)$ 若 $Q_a$ 空，对 $Q_s$ 循环出入队，使得原队尾部的 $|Q_a|+1$ 个元素出队，返回队尾，其余元素进入 $Q_a$，顺序不变。时间复杂度：$O(|Q_s|)$  访问栈顶操作   若 $Q_a$ 非空，对 $Q_a$ 循环出入队，使得原队尾在队头，返回队尾，并恢复最初顺序，时间复杂度：$O(|Q_a|)$ 若 $Q_a$ 空，对 $Q_s$ 循环出入队，使得原队尾部的 $|Q_a|$ 个元素出队，返回队尾，所有元素进入 $Q_a$，顺序不变。时间复杂度：$O(|Q_s|)$  为让这个实现变得有效，我们先来分析其时间复杂度来自哪里：\n每个元素从入栈到出栈经历了：\n 压入：$O(1)$ （可选）从 $Q_a$ 到 $Q_s$：$O(1)$ （可选）从 $Q_s$ 到 $Q_a$：$O(|Q_s|/|Q_a|)$（最坏情况） 弹出 以下两种二选一：  从 $Q_s$ 出队：$O(1)$ 从 $Q_a$ 出队：$O(|Q_a|)$    接下来考虑最坏情况，那么每个元素经历入队出队共计 $O(|Q_s|/|Q_a|+|Q_a|)$. 由 $|Q_s|/|Q_a|+|Q_a| \\ge 2\\sqrt{|Q_s|}$ 当且仅当 $|Q_s|/|Q_a|=|Q_a|$ 即 $|Q_a|=\\sqrt{|Q_s|}$。故最低为 $O(\\sqrt{|Q_s|})$ 故当我们将 $Q_a$ 的容量限制在 $\\sqrt{|Q_s|}$ 时，对于 $n$ 个元素的栈，有 $|Q_s|\\le n$ 总复杂度估计为 $O(n\\sqrt n)$. 平均每次操作复杂度$O(n\\sqrt n/(2n))=O(\\sqrt n)$，由此可见，性能的确有较大提高。\n 如果你像上面那样类比了计算机中的组件，那么我们的算法所做的，就可以看成从内存中读取一段，放入高速缓存中，利用高命中率来减少我们对相对低速的内存的访问\n 复杂度分析  空间复杂度：队列的空间复杂度是线性的，而且这里栈中的每一个数据仅会在两个队列中的某一个中存在，故此实现的空间复杂度为线性 时间复杂度：通过思路中的分析，单次操作均摊复杂度为 $O(\\sqrt{n})$。  扩展阅读与参考资料  时间复杂度下限的讨论 队列实现栈的 C# 代码实现  ","date":"2018-08-28T17:30:22+08:00","permalink":"https://stardustdl.github.io/posts/learning/the-mutual-realization-of-stack-and-queue/","title":"栈与队列的相互实现"},{"content":" 书籍名：C Traps and Pitfalls 作者：Andrew Koenig 出版时间：1989-1-11 基本介绍：Andrew Koenig 是AT\u0026amp;T公司Shannon实验室大规模编程研究部门中的成员，同时也是C++标准委员会的项目编辑。作者以自己1985年在Bell实验室时发表的一篇论文为基础，结合自己的工作经验扩展成为这本对C程序员具有珍贵价值的经典著作。写作本书的出发点不是要批判C语言，而是要帮助C程序员绕过编程过程中的陷阱和障碍。本书写于 ANSI C 正式发布前。   第一章 词法陷阱  = 不同于 == \u0026amp;,| 不同于 \u0026amp;\u0026amp;,|| 词法分析中的贪心法：每一个符号应包含尽可能多的字符 如果整型常量以 0 开头，则被视为八进制，以 0x 开头，被视为十六进制。 字符串末尾有 \\0 即 $0$  第二章 语法陷阱 函数声明 声明的形式：类型+一组类似表达式的声明符 表示对声明符求值应返回一个指定类型的结果。\nint a; //a 整型 a 整型 int *a; //*a 整型 a 指向整型的指针 int *g(); //*(g()) 整型 g 返回整形指针的函数 int (*h)(); //(*h)() 整型 h 指向返回整型的函数的指针 int (*f)(int); //(*f)(int) 整型 f 指向有一个整型参数，返回整型的函数的指针 声明省去标识符，即得到对应的类型转化符。\n(int) (int *) (int *()) (int (*)()) (int (*)(int)) 使用 typedef 简化类型表示\ntypedef int (*func)(int); //func=(int (*)(int)) 运算符优先级  () [] -\u0026gt; . 单目 双目 算术 * / % \u0026gt; + - 移位 关系 \u0026lt; \u0026lt;= \u0026gt; \u0026gt;= \u0026gt; == != 位逻辑 \u0026amp; \u0026gt; ^ \u0026gt; | 逻辑 \u0026amp;\u0026amp; \u0026gt; || 三目（?:） 赋值 ,  其他  语句结束的分号 switch 结构中的 break 函数调用：f 为函数地址，f() 为函数调用 else 与同一对括号内最近的未匹配 if 匹配  第三章 语义陷阱  C语言中只有一维数组，但数组中的元素的类型没有限制。 数组名不用于 sizeof 的操作数时，其都被转换成一个指向其起始元素的指针。 C语言中会将参数中的数组声明转化为对应的指针声明  第四章 连接  如果一个声明语句出现在所有函数体之外，那么它就被称为外部对象 a 的定义。 带 extern 的声明语句，并不是对 a 的定义，其显式地说明了 a 的存储空间是在程序其他地方分配的。对于连接器，此为对外部变量的引用。对于这种语句，即使其出现在函数体内，含义仍相同。 static 将声明的变量或函数的作用域限制在当前源文件内 旧的 C语言 要求变量定义必须在源文件头部。 可用头文件定义一些对外部变量的引用，在某个源文件中给出定义，其他源文件使用头文件访问这些变量。  第五章 库函数  getchar 函数返回整数，EOF 往往不在 char 的表示范围内。 输出缓冲：setbuf(stdout,buf)，若 buf 使用局部变量，可能在缓冲清空前， buf 就已经被释放了。  可以使用 setbuf(stdout,NULL) 取消缓冲    第六章 预处理器  宏只是对程序的文本起作用，支持对字符串进行变换，但不作用与程序中的对象。 宏定义中空格有意义（宏调用中不存在此情况）  #define f (x) ((x)-1) //f=(x)((x)-1) 不带参数 #define f(x) ((x)-1) //f(x)=((x)-1) 带参数  宏不是函数，表达式可能被多次求值，若传入表达式存在副作用，则结果可能出乎意料。 宏可能产生非常庞大的表达式 宏不是语句 宏不是类型定义  第七章 可移植性缺陷  内存位置 0：仅用于赋值或比较运算，其他操作都是非法的，不同编译器和机器对此位置的限制不同。 除法截断 q=a/b, r=a%b  C 语言定义只保证了 $qb+r=a$，以及 $a\\ge 0 \\wedge b\u0026gt;0$ 时，$|r|\u0026lt;|b|\\wedge r\\ge 0$ 大部分编译器保证了，若改变 $a$ 的符号，这会改变 $q$ 的符号，但不会改变其绝对值 除法运算结果是向 $0$ 取整（即绝对值向下取整），如 $-5/-2=\\lfloor \\frac{-5}{-2} \\rfloor=2,-5/2=\\lceil \\frac{-5}{2} \\rceil=-2$，这保证了 a%b 一定与 a 同号    附录 printf 函数格式串 每个格式项以 % 打头，后接一个格式码指明类型，其之间可能夹一些可选字符（修饰符）。顺序如下：\n%\u0026lt;标志\u0026gt;\u0026lt;宽度修饰符\u0026gt;.\u0026lt;精度修饰符\u0026gt;\u0026lt;长度修饰符\u0026gt;\u0026lt;格式码\u0026gt;\n格式码  d 带符号整数，十进制 u 无符号整数，十进制 o 整数，八进制 x 整数，十六进制（abcdef）  X 整数，十六进制（ABCDEF）   s 字符串，直到 \\0 c 字符 g 浮点数，去掉尾缀0，保留六位有效数字，可能采用科学计数法（1e1）  G 浮点数，去掉尾缀0，保留六位有效数字，可能采用科学计数法（1E1）   e 浮点数，指数形式（1e1），小数点后六位有效数字  E 浮点数，指数形式（1E1），小数点后六位有效数字   f 浮点数，禁用指数形式，小数点后六位有效数字 % 一个 % 字符 p 指针 n 指出已经打印的字符数，将被存储在传入的整型指针处  printf(\u0026quot;hello\\n%n\u0026quot;,\u0026amp;n) 则 $n=6$    修饰符  长度修饰符：l。对应 long 宽度修饰符：\u0026lt;int\u0026gt;。指定最小输出宽度，默认右对齐 精度修饰符：.\u0026lt;int\u0026gt;。控制数值表示中将要出现的数字位数，或用于限制将要输出的字符串中应出现的字符数。在宽度修饰符后。  对于 d,o,x,u,X 指定打印数字最少位数（不包含符号），若不足，在前面补0 对于 e,E,f 指定小数点后应出现的数字位数，除非标识符另有说明，仅当精度大于 0 时，打印的数值中才会实际出现小数点 对于 g,G 指定打印数值中的有效数字位数，除非标识符另有说明，非有效数字的0将被去掉，如果小数点后不跟数字则小数点也会被删除 对于 s，指定要打印的最大字符数 对于 c,% 精度修饰符将被忽略    标志 在 % 和宽度修饰符之间插入标志字符，微调效果。\n - 改为左对齐 + 强制打印符号 空白字符 若数值是非负数，则在其前插入一个空白字符。 # 微调  对浮点数格式：要求小数点必须被打印，对于 g,G 数值尾缀0不会被去掉    可变域宽 支持间接指定域宽和精度：使用 * 替换宽度修饰符，精度修饰符，则参数列表中需添加指定的宽度，精度值。对于给定域宽为负数的情况，相当于把符号作为标志字符 - 处理。\n","date":"2018-08-26T10:30:40+08:00","permalink":"https://stardustdl.github.io/posts/reading/c-traps-and-pitfalls/","title":"C Traps and Pitfalls"},{"content":" 书籍名：The C Programming Language (Second Edition) 作者：Brian W. Kernighan / Dennis M. Ritchie 出版时间：1988-4-1 基本介绍：《C程序设计语言》原著 即为C语言的设计者Dennis M．Ritchie和著名的计算机科学家Brian W．Kernighan合著的 一本介绍C语言的权威经典著作。原著第1版中介绍的C语言成为后来广泛使用的C语言版本—— 标准C的基础。人们熟知的“Hello, World”程序就是由《C程序设计语言》首次引入的。原著第2版根据1987年制定的ANSIC标准做了适当的修订。   第二章  枚举 enum id{A=1,B=2,...} 字符串支持连接 \u0026quot;abc\u0026quot; \u0026quot;def\u0026quot;=\u0026quot;abcdef\u0026quot; ctype 中的函数与字符表无关 使用 unsigned 的变量在隐式转换时和具体实现有关要十分注意，可能不是预期的。 float 不会自动提升为 double 伪随机数算法 $[0,32767]$ 的伪随机整数  unsigned long int _next=1; int rand(){ _next=_next*1103515245+12345; return (unsigned int)(_next/65536)%32768; } void srand(unsigned int seed){_next=seed;}  逗号表达式从左到右求值，最右侧的表达式为其结果值。函数参数中的逗号不是逗号表达式，C语言没有定义其运算顺序 对于一个运算，左右表达式的运算先后是不确定的。  第三章  Shell-Sort  void shellsort(int v[],int n){ for(int gap=n\u0026gt;\u0026gt;1;gap;gap\u0026gt;\u0026gt;=1) for(int i=gap;i\u0026lt;n;i++) for(int j=i-gap;j\u0026gt;=0 \u0026amp;\u0026amp; v[j]\u0026gt;v[j+gap];j-=gap) swap(v[j],v[j+gap]); } 第四章  external,internal 关键字修饰变量 register 关键字，寄存器变量地址不可访问 static 关键字修饰全局变量，使变量限定在当前编译文件中  预处理 宏定义  行末使用 \\ 使用多行定义 undef 取消宏定义 替换文本中 #加在参数名前，则将会生成和参数书写完全相同的字符串  #define debug(expr) printf(#expr \u0026#34; = %g\\n\u0026#34;,expr)  ## 运算符  #define paste(a,b) a ## b paste(name,1) =\u0026gt; name1 条件  #if #endif #elif #else #ifdef = #if defined id #ifndef = #if !defined id #line constval [\u0026quot;filename\u0026quot;] #error ... #praga ...  第五章  void* 作为通用指针 指针实现数组一般快于下标实现数组 指针支持和整数加减，与指针相减和比较运算（位置比较） 数组和指针不完全等价，数组本身不可变，但指针可以  void strcpy(char* s,char *t){ while(*s++=*t++); } *p++=val;//push val=*--p;//pop  以下表达等价  f(int c[2][13]) f(int c[][13]) f(int (*c)[13]) 第六章  union 类型：同一起点，不同类型变量，自动对齐，只能对第一个元素初始化 位字段：二进制标志位集合，后面的数字指定位长，仅能使用 int，不支持 \u0026amp;  struct{ unsigned int a:1; unsigned int b:1; }flgs; 第七章  exit(exitcode) printf 函数格式化：%? ? 表示转换说明  - 左对齐 数字 最小字段宽度或精度 . 用于区分最小字段宽度和精度 h/l 整数作为 short/long d/i 十进制整数 o 无符号八进制整数 x/X 无符号十六进制整数，指定大小写 u 无符号十进制整数 c 字符 f double 十进制小数 e/E double 十进制小数 科学记数法 g/G double 十进制小数 根据指数决定使用哪一种表示方式 p void* 类型 使用 * 指定宽度或精度，将使用下一参数（int）得到   变长参数  #include \u0026lt;stdarg.h\u0026gt;void f(char *a,...){ va_list ap; va_start(ap,fmt); for(char* p=fmt;*p;p++){ } va_end(ap); }  scanf 函数 返回成功赋值的个数，文件结尾返回 EOF  文件 FILE* fp=fopen(name,mode=\u0026#34;r[+]\u0026#34;,\u0026#34;w[+]\u0026#34;,\u0026#34;a[+]\u0026#34;[,\u0026#34;b\u0026#34;]) //以下是宏而不是函数 int getc(FILE *fp); int putc(int c,FILE* fp)=c; fscanf(FILE* fp,...) fprintf(FILE* fp,...) //清空缓冲区并关闭文件 int fclose(FILE *fp) int fflush(FILE *fp) int ferror(FILE *fp) int feof(FILE *fp) char* fgets(char*line,int maxvalue,FILE *fp)=success? line:NULL; char* fputs(char*line,FILE *fp)=success? line:EOF; fgetc,fputc int ungetc(int c,FILE *fp)=success?c:EOF; //写回一个字符，只能接受一个 int remove(const char* filename);//删除文件，成功返回0 int rename(const char* filename);//重命名文件，成功返回0 FILE* tmpfile();//wb+创建临时文件  size_t fread(void*ptr,size_t size,size_t nobj,FILE *stream) 读取最多nobj个长度为size的对象，并保存到ptr数组中，返回读取到的个数。 size_t fwrite(const void*ptr,size_t size,size_t nobj,FILE *stream) 从ptr数组读取nobj个长度为size的对象，并输出，返回输出的个数。 int fseek(FILE* stream, long offset,int origin) 从origin偏移offset个位置。origin=SEEK_SET,SEEK_CUR,SEEK_END，文本流只能是offest只能是0或ftell得到的值。 long ftell(FILE *stream) 得到当前位置，错误返回-1L void rewind(FILE *stream) 回到起点，清除错误状态 int fgetpos(FILE *stream,fpos_t *pos) 记录当前位置到pos int fsetpos(FILE *stream,const fpos_t *pos) 标准文件指针 stdin,stdout,stderr  字符串函数  strcat(s,t) strncat(s,t,n) strcmp(s,t) strncmp(s,t,n) strcpy(s,t) strncpy(s,t,n) strlen(s) strchr(s,c) 正向查找，返回指针 strrchr(s,c) 反向查找，返回指针 memcpy(s,t,n) memmove(s,t,n) memcmp(s,t,n) memchr(s,c,n) memset(s,c,n)  更多函数  void* malloc(size_t n) n字节长度 void* calloc(size_t n,size_t size) n个指定字节长度元素的空间 free(p) 仅限使用上面两个函数申请的空间 ldexp(x,n) $=x\\cdot 2^n$ frexp(x,int* exp) $x=a\\cdot 2^n$，其中 $a \\in [1/2,1]$，返回$a$，$exp=n$ modf(x,double *ip) 返回小数部分，$ip$=整数部分，符号均和 $x$ 相同 fmod(x,y) 浮点余数 double atof(char*) int atoi(char*) long atol(char*) abort() ateexit(void (*func)(void)) 登记一个程序正常终止时调用的函数  ","date":"2018-08-26T09:30:40+08:00","permalink":"https://stardustdl.github.io/posts/reading/the-c-programming-language/","title":"The C Programming Language"}]
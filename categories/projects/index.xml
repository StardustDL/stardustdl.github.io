<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Projects on StardustDL's Blog</title><link>https://stardustdl.github.io/categories/projects/</link><description>Recent content in Projects on StardustDL's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 21 Dec 2021 14:14:53 +0800</lastBuildDate><atom:link href="https://stardustdl.github.io/categories/projects/index.xml" rel="self" type="application/rss+xml"/><item><title>Codesim</title><link>https://stardustdl.github.io/posts/projects/codesim/</link><pubDate>Tue, 21 Dec 2021 14:14:53 +0800</pubDate><guid>https://stardustdl.github.io/posts/projects/codesim/</guid><description>Codesim A similarity measurer on two programming assignments on Online Judge.
GitHub The code similarity measuring algorithm originates from
Jiang Y, Xu C. Needle: Detecting code plagiarism on student submissions[C]//Proceedings of ACM Turing Celebration Conference-China. 2018: 27-32.
Goals From PA1&amp;rsquo;s goals and Needle&amp;rsquo;s paper
We want to measure similarity between two programming assignments $A$ and $B$ on Online Judge to find possible plagiarism. We assume that each input program is a single-file C++ program that can be compiled by g++ -std=c++17 -pedantic.</description></item><item><title>Projects</title><link>https://stardustdl.github.io/posts/projects/</link><pubDate>Tue, 21 Dec 2021 14:14:53 +0800</pubDate><guid>https://stardustdl.github.io/posts/projects/</guid><description/></item><item><title>AcBlog 静态博客生成器使用说明</title><link>https://stardustdl.github.io/posts/projects/acblog-staticgen/</link><pubDate>Wed, 15 Jul 2020 08:23:46 +0800</pubDate><guid>https://stardustdl.github.io/posts/projects/acblog-staticgen/</guid><description>AcBlog 是一个还在开发中的开源博客系统，支持纯静态部署。
AcBlog 前端使用 WebAssembly 实现，支持 SPA，纯静态部署，后端支持静态和动态部署。以下是静态生成器生成的网站示例。
AcBlog GitHub Pages AcBlog Gitee Pages 创建存储库 对于纯静态部署的博客，参照项目主页的文件结构建立存储库：
app 目录下的内容将被直接复制到网站根目录 posts 目录下的内容为所有的文章（以 .md 为后缀），生成器将读取并用于生成静态后端 assets 目录下的内容将被直接复制到生成器输出目录，可用于存储文章中使用的图片等文件 acblog.json 包含了提供给生成器的相关配置 blog.json 包含了博客的相关信息 .github/workflows/deploy.yml 脚本用于自动构建并推送 GitHub Pages 编写说明 acblog.json 配置文件 { &amp;#34;acblog&amp;#34;: { &amp;#34;Properties&amp;#34;: { &amp;#34;Raw&amp;#34;: { &amp;#34;remote.origin.generator.baseAddress&amp;#34;: &amp;#34;博客网址&amp;#34;, } } } } 一般情况下，只需要填写博客网址，以供站点地图和 ATOM feed (RSS) 的生成使用。
生成的站点地图默认位于 博客网址/data/Site/sitemap.xml 生成的 ATOM feed 默认位于 博客网址/data/Site/atom.xml blog.json { &amp;#34;Name&amp;#34;: &amp;#34;Blog name&amp;#34;, &amp;#34;Description&amp;#34;: &amp;#34;Blog description&amp;#34;, &amp;#34;StartYear&amp;#34;: 2020, &amp;#34;Onwer&amp;#34;: &amp;#34;onwer&amp;#34;, // 主页背景图地址，将图片放到 app 目录下，在这里填写文件名即可 &amp;#34;Cover&amp;#34;: &amp;#34;cover.</description></item><item><title>ImagingS 开发笔记</title><link>https://stardustdl.github.io/posts/projects/images-dev/</link><pubDate>Sat, 04 Jul 2020 22:17:52 +0800</pubDate><guid>https://stardustdl.github.io/posts/projects/images-dev/</guid><description>Project Source Demo Video
来源 最初的想法来自 计算机图形学的课程项目作业，其要求基于 Python + Qt 实现一个支持简单图元绘制的 GUI+CLI 程序。
之前一般仅使用 Python 写一些简单的小型项目。曾写过一个较大项目，但即使使用了类型标注，也很快随着项目复杂度的提升，遇到了维护瓶颈，大大影响开发效率，遂中断了开发。
这次是第一次使用 Python 开发图形用户界面的软件，也是第一次使用 Qt，考虑到这个项目的需求较为明确并且有足够的扩展可能，决定将此项目作为一个 Python 较大单人项目的练手，并规避以前 Python 项目遇到的一些问题。
Idea 根据课程项目的模板代码，发现此项目非常适合 OOP 模式设计。结合以前的 WPF 学习经历，决定依照 WPF 的设计思路，试图在 ImagingS 中复刻 WPF 的呈现模型。
图元 Geometry 对象描述图元及其绘制算法 绘图 Drawing 将各种图元绘制到 DrawingContext 上 绘图上下文 DrawingContext 提供具体绘图的抽象，统一 GUI 绘图和图片文件绘图。 通过这三个层次，将呈现系统的两部分：定义与呈现分离。
设计 核心的 API 集中在以下几个类中，其中与绘制抽象相关的大部分类均能在 WPF 绘制模型中找到对应。
图元类：各种图元的基类，定义了绘制算法（strokePoints）和变换。 class Geometry(PropertySerializable, ABC): def __init__(self) -&amp;gt; None: pass def transform(self) -&amp;gt; Optional[Transform]: pass def strokePoints(self, pen: Pen) -&amp;gt; Iterable[Point]: pass def fillPoints(self) -&amp;gt; Iterable[Point]: pass def inStroke(self, pen: Pen, point: Point) -&amp;gt; bool: pass def inFill(self, point: Point) -&amp;gt; bool: pass def transformed(self) -&amp;gt; Geometry: pass def bounds(self) -&amp;gt; Rect: pass 绘制类：所有可绘制元素的基类，定义了绘制函数（render）。对于图元对象，实现了 GeometryDrawing 来实际完成图元的绘制任务。 class Drawing(PropertySerializable, IdObject, ABC): def __init__(self) -&amp;gt; None: pass @abstractmethod def render(self, context: RenderContext) -&amp;gt; None: pass @property @abstractmethod def bounds(self) -&amp;gt; Rect: pass 绘图上下文类：对实际绘制的目标的抽象 class RenderContext(ABC): @abstractmethod def _point(self, position: Point, color: Color) -&amp;gt; None: pass @abstractmethod def bounds(self) -&amp;gt; Rect: pass def point(self, position: Point, color: Color) -&amp;gt; None: pass def points(self, positions: Iterable[Point], brush: Brush) -&amp;gt; None: pass 变换类：所有变换的基类，定义了如何将一个点变换到另一个点 class Transform(PropertySerializable, IdObject, ABC): def __init__(self) -&amp;gt; None: pass @abstractmethod def transform(self, origin: Point) -&amp;gt; Point: pass 文档类：定义了当前文档所包含的画刷，图元，画布大小等信息，实现了序列化操作 class Document(PropertySerializable, IdObject): def __init__(self) -&amp;gt; None: pass @property def brushes(self) -&amp;gt; IdObjectList[Brush]: pass @property def drawings(self) -&amp;gt; DrawingGroup: pass @property def size(self) -&amp;gt; Size: pass def save(self, file, format: DocumentFormat = DocumentFormat.</description></item></channel></rss>
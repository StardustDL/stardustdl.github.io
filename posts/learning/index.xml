<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Learning on StardustDL's Blog</title><link>https://stardustdl.github.io/posts/learning/</link><description>Recent content in Learning on StardustDL's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 08 Jul 2021 10:37:56 +0800</lastBuildDate><atom:link href="https://stardustdl.github.io/posts/learning/index.xml" rel="self" type="application/rss+xml"/><item><title>Python 项目打包与分发</title><link>https://stardustdl.github.io/posts/learning/python-packaging/</link><pubDate>Thu, 08 Jul 2021 10:37:56 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/python-packaging/</guid><description>工具 pip, setuptools, twine python -m pip install --upgrade pip build twine 项目组织结构 packaging_tutorial/ ├── LICENSE ├── pyproject.toml ├── README.md ├── setup.cfg ├── src/ │ └── example_package/ │ ├── __init__.py │ └── example.py └── tests/ 配置文件 pyproject.toml [build-system] requires = [ &amp;#34;setuptools&amp;gt;=51&amp;#34;, &amp;#34;wheel&amp;#34; ] build-backend = &amp;#34;setuptools.build_meta&amp;#34; setup.cfg [metadata] name = example-pkg version = 0.0.1 author = Example Author author_email = author@example.com description = A small example package long_description = file: README.</description></item><item><title>Rust 函数式编程</title><link>https://stardustdl.github.io/posts/learning/rust-functional/</link><pubDate>Tue, 06 Jul 2021 20:50:46 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/rust-functional/</guid><description>闭包 fn generate_workout(intensity: u32,random_number: u32){letexpensive_closure=|num|{println!(&amp;#34;calculating slowly...&amp;#34;);thread::sleep(Duration::from_secs(2));num};ifintensity&amp;lt;25{println!(&amp;#34;Today, do {} pushups!&amp;#34;,expensive_closure(intensity));println!(&amp;#34;Next, do {} situps!&amp;#34;,expensive_closure(intensity));}else{ifrandom_number==3{println!(&amp;#34;Take a break today! Remember to stay hydrated!&amp;#34;);}else{println!(&amp;#34;Today, run for {} minutes!&amp;#34;,expensive_closure(intensity));}}}闭包支持类型推断，可以不标注类型信息。
letexpensive_closure=|num: u32|-&amp;gt; u32 {println!(&amp;#34;calculating slowly...&amp;#34;);thread::sleep(Duration::from_secs(2));num};fn add_one_v1(x: u32)-&amp;gt; u32 {x+1}letadd_one_v2=|x: u32|-&amp;gt; u32 {x+1};letadd_one_v3=|x|{x+1};letadd_one_v4=|x|x+1;推断有歧义的闭包会报错。
letexample_closure=|x|x;lets=example_closure(String::from(&amp;#34;hello&amp;#34;));letn=example_closure(5);闭包类型 struct Cacher&amp;lt;T&amp;gt;whereT: Fn(u32)-&amp;gt; u32,{calculation: T,value: Option&amp;lt;u32&amp;gt;,}捕获环境 FnOnce 消耗捕获的变量，获取其所有权 FnMut 通过可变引用捕获变量 Fn 通过不可变引用捕获变量 // FnOnce letequal_to_x=move|z|z==x;迭代器 pubtraitIterator{type Item;fn next(&amp;amp;mutself)-&amp;gt; Option&amp;lt;Self::Item&amp;gt;;// methods with default implementations elided }创建迭代器 struct Counter{count: u32,}implCounter{fn new()-&amp;gt; Counter{Counter{count: 0}}}implIteratorforCounter{type Item=u32;fn next(&amp;amp;mutself)-&amp;gt; Option&amp;lt;Self::Item&amp;gt;{ifself.</description></item><item><title>Rust 泛型</title><link>https://stardustdl.github.io/posts/learning/rust-generic-types/</link><pubDate>Tue, 06 Jul 2021 19:50:46 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/rust-generic-types/</guid><description>泛型 泛型函数 fn largest&amp;lt;T: PartialOrd +Copy&amp;gt;(list: &amp;amp;[T])-&amp;gt; T{letmutlargest=list[0];for&amp;amp;iteminlist{ifitem&amp;gt;largest{largest=item;}}largest}泛型结构 struct Point&amp;lt;T&amp;gt;{x: T,y: T,}fn main(){letinteger=Point{x: 5,y: 10};letfloat=Point{x: 1.0,y: 4.0};}struct Point&amp;lt;T,U&amp;gt;{x: T,y: U,}fn main(){letboth_integer=Point{x: 5,y: 10};letboth_float=Point{x: 1.0,y: 4.0};letinteger_and_float=Point{x: 5,y: 4.0};}泛型枚举 enum Option&amp;lt;T&amp;gt;{Some(T),None,}enum Result&amp;lt;T,E&amp;gt;{Ok(T),Err(E),}泛型方法 struct Point&amp;lt;T&amp;gt;{x: T,y: T,}// 通用实现（对所有类型） impl&amp;lt;T&amp;gt;Point&amp;lt;T&amp;gt;{fn x(&amp;amp;self)-&amp;gt; &amp;amp;T{&amp;amp;self.x}}// 特定实现（对指定类型） implPoint&amp;lt;f32&amp;gt;{fn distance_from_origin(&amp;amp;self)-&amp;gt; f32 {(self.x.powi(2)+self.y.powi(2)).sqrt()}}fn main(){letp=Point{x: 5,y: 10};println!(&amp;#34;p.x = {}&amp;#34;,p.x());}泛型结合生存期 usestd::fmt::Display;fn longest_with_an_announcement&amp;lt;&amp;#39;a,T&amp;gt;(x: &amp;amp;&amp;#39;astr,y: &amp;amp;&amp;#39;astr,ann: T,)-&amp;gt; &amp;amp;&amp;#39;astrwhereT: Display,{println!(&amp;#34;Announcement! {}&amp;#34;,ann);ifx.len()&amp;gt;y.len(){x}else{y}}特征：定义共享行为 定义特征 pubtraitSummary{fn summarize(&amp;amp;self)-&amp;gt; String;}实现特征 pubstruct NewsArticle{pubheadline: String,publocation: String,pubauthor: String,pubcontent: String,}implSummaryforNewsArticle{fn summarize(&amp;amp;self)-&amp;gt; String {format!(&amp;#34;{}, by {} ({})&amp;#34;,self.</description></item><item><title>Rust 集合</title><link>https://stardustdl.github.io/posts/learning/rust-collections/</link><pubDate>Tue, 06 Jul 2021 17:50:46 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/rust-collections/</guid><description>变长列表 // 创建 letv: Vec&amp;lt;i32&amp;gt;=Vec::new();letv=vec![1,2,3];// 修改 letmutv=Vec::new();v.push(5);// 访问 letthird: &amp;amp;i32 =&amp;amp;v[2];println!(&amp;#34;The third element is {}&amp;#34;,third);matchv.get(2){Some(third)=&amp;gt;println!(&amp;#34;The third element is {}&amp;#34;,third),None=&amp;gt;println!(&amp;#34;There is no third element.&amp;#34;),}// 遍历 letv=vec![100,32,57];foriin&amp;amp;v{println!(&amp;#34;{}&amp;#34;,i);}letmutv=vec![100,32,57];foriin&amp;amp;mutv{*i+=50;}在有引用的情况下无法对列表进行修改。
UTF-8 字符串 // 创建 letmuts=String::new();// 更新 letmuts=String::from(&amp;#34;foo&amp;#34;);s.push_str(&amp;#34;bar&amp;#34;);s.push(&amp;#39;l&amp;#39;);// 合并 lets1=String::from(&amp;#34;Hello, &amp;#34;);lets2=String::from(&amp;#34;world!&amp;#34;);lets3=s1+&amp;amp;s2;// note s1 has been moved here and can no longer be used // 格式化 lets1=String::from(&amp;#34;tic&amp;#34;);lets2=String::from(&amp;#34;tac&amp;#34;);lets3=String::from(&amp;#34;toe&amp;#34;);lets=format!(&amp;#34;{}-{}-{}&amp;#34;,s1,s2,s3);// do not take onwership 字符串内部对 Vec&amp;lt;u8&amp;gt; 进行包装。不支持直接索引。
切片 lethello=&amp;#34;Здравствуйте&amp;#34;;// each of these characters was 2 bytes lets=&amp;amp;hello[0..4];// s == Зд lets=&amp;amp;hello[0.</description></item><item><title>Rust 模块与项目</title><link>https://stardustdl.github.io/posts/learning/rust-modules/</link><pubDate>Tue, 06 Jul 2021 16:50:46 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/rust-modules/</guid><description>包 Packages 一个 Cargo 特性支持构建，测试，和分享 Crates。包含了 Cargo.toml 来描述如何构建 Crates。包至少包含0或1个库Crate，可以包含任意多的二进制Crate，但至少要有一个Crate。
src/ main.rs 二进制Crate的根（名称为包名） lib.rs 库Crate的根（名称为包名） bin/ 更多二进制Crate（其中的每个文件为一个Crate） 构建配置 # https://doc.rust-lang.org/cargo/reference/profiles.html [profile.dev] opt-level = 0 [profile.release] opt-level = 3 共享相同依赖开发多个包：Cargo Workspaces。
文档注释 /// Adds one to the number given. /// /// # Examples /// /// ``` /// let arg = 5; /// let answer = my_crate::add_one(arg); /// /// assert_eq!(6, answer); /// ``` /// # Panics / Errors / Safety pubfn add_one(x: i32)-&amp;gt; i32 {x+1}使用 cargo doc --open 启动文档预览，使用 cargo test 进行文档测试。</description></item><item><title>Rust 所有权特性</title><link>https://stardustdl.github.io/posts/learning/rust-onwership/</link><pubDate>Tue, 06 Jul 2021 11:50:46 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/rust-onwership/</guid><description>规则 每个值都有一个称为其所有者的变量 同一时刻只能有一个所有者 当所有者离开作用域时，值被舍弃（调用 drop 函数） 变量与数据的交互 移动语义 Rust 从不自动进行变量的深层复制，而是使用移动语义。
lets1=String::from(&amp;#34;abc&amp;#34;);lets2=s1;// s1 is invalid 克隆语义 使用 clone 函数实现明确的深层复制。
lets1=String::from(&amp;#34;hello&amp;#34;);lets2=s1.clone();复制语义 诸如整数等类型数据，具有编译时已知的大小，并完全存储在栈上，能够快速复制，浅层复制与深层复制没有实际区别，不需要使用 clone 函数（实现 Copy 特征以标记这类数据）。
letx=5;lety=x;引用 lets1: String =String::from(&amp;#34;hello&amp;#34;);letref_s1: &amp;amp;String =&amp;amp;s1;letmutmut_s1: String =String::from(&amp;#34;hello&amp;#34;);letref_s1: &amp;amp;mutString=&amp;amp;mutmut_s1;&amp;amp; 表示引用变量，不取得变量的所有权，默认以不可变方式进行引用，&amp;amp;mut 表示可变方式引用。 传入引用变量的函数，称为借用了这个变量。
在同一作用域下，对同一个对象的引用，只允许以下组合方式：
一个或多个不可变引用 一个可变引用，没有不可变引用 切片 切片指对一个序列中的一段连续元素的引用，不取得变量的所有权。
leta=[1,2,3,4,5];letslice=&amp;amp;a[1..3];assert_eq!(slice,&amp;amp;[2,3]);字符串切片 lets=String::from(&amp;#34;hello world&amp;#34;);lethello: &amp;amp;str =&amp;amp;s[0..5];letworld: &amp;amp;str =&amp;amp;s[6..11];letslice: &amp;amp;str =&amp;amp;s[..2];letslice: &amp;amp;str =&amp;amp;s[3..];letslice: &amp;amp;str =&amp;amp;s[..];字符串字面值的类型为字符串切片（&amp;amp;str）。
生存期 借用检查器会检查生存期长短关系，来保证借用安全。
fn main(){{letx=5;// ----------+-- &amp;#39;b // | letr=&amp;amp;x;// --+-- &amp;#39;a | // | | println!</description></item><item><title>Rust 语言基础使用</title><link>https://stardustdl.github.io/posts/learning/rust-startup/</link><pubDate>Tue, 06 Jul 2021 09:42:46 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/rust-startup/</guid><description>安装 https://www.rust-lang.org/tools/install
安装管理器 rustup 编译器 rustc 构建系统与包管理器 cargo 常用命令 创建项目 cargo new {name} 可编译检查 cargo check 编译 cargo build (--release) 运行 cargo run 更新依赖包小版本 cargo upgrade （大版本需要手动修改） 变量 letimmutable_var: i32 =5;letmutmutable_var: i32 =5;constCONST: u32 =100_000;数值字面值
十进制 98_222 十六进制 0xff 八进制 0o77 二进制 0b1111_0000 字节 b'A' 类型 数值类型 i8, i16, i32, i64, i128, isize, u8, u16, u32, u64, u128, usize, f32, f64 布尔类型 bool 字符类型 char 四字节 元组类型 (T1, T2, .</description></item><item><title>C++ 模板实现编译期计算数列</title><link>https://stardustdl.github.io/posts/learning/cpp-template-seq/</link><pubDate>Thu, 23 Jul 2020 13:23:31 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/cpp-template-seq/</guid><description>虽然 C++ 模板最初被 Bjarne Stroustrup 称为参数化类型，但是实际上其工作方式更像一个受限制的高级版宏，”模板“这个名称更加合适。
这里使用 C++ 模板的非类型参数特性来实现一些数列的编译期计算。
阶乘数列 $$ F_i = \begin{cases} 1 &amp;amp; i = 0 \\ iF_{i-1} &amp;amp; i &amp;gt; 0 \end{cases} $$
template &amp;lt;int num&amp;gt; class Factorial { public: static const int value = num * Factorial&amp;lt;num - 1&amp;gt;::value; }; template &amp;lt;&amp;gt; class Factorial&amp;lt;0&amp;gt; { public: static const int value = 1; }; int main() { cout &amp;lt;&amp;lt; Factorial&amp;lt;10&amp;gt;::value &amp;lt;&amp;lt; endl; } 为什么这是编译期运算呢？可以从两个方面了解。
关闭编译器所有优化。
g++ -S fac.</description></item><item><title>NJU ICS Programming Assignment 代码分析 - NANOS-LITE</title><link>https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nanos-lite/</link><pubDate>Mon, 05 Nov 2018 17:30:22 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nanos-lite/</guid><description>概述 框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言 Nanos-lite是南京大学操作系统Nanos的裁剪版。可运行在 x86-nemu 的 AM 上。
框架代码结构 nanos-lite/ # NANOS-LITE 项目 include/ # 头文件 src/ # 源文件 device.c # 设备抽象 fs.c # 文件系统 files.h # ramdisk 中的文件描述 initrd.S # ramdisk设备 irq.c # 中断异常处理 loader.c # 加载器 main.c # 主程序 mm.c # 存储管理 proc.c # 进程调度 ramdisk.c # ramdisk驱动程序 syscall.c # 系统调用处理 syscall.h # 系统调用相关宏 Makefile navy-apps/ nemu/ nexus-am/ include/ common.</description></item><item><title>NJU ICS Programming Assignment 代码分析 - NAVY-APPS</title><link>https://stardustdl.github.io/posts/learning/nju-icspa-analytics-navy-apps/</link><pubDate>Mon, 05 Nov 2018 17:30:22 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/nju-icspa-analytics-navy-apps/</guid><description>概述 框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言 Navy-Apps 提供一系列运行在 Nanos-lite 上的用户程序，也包含了 Newlib 库。
框架代码结构 nanos-lite/ navy-apps/ apps/ # 用户程序 am-apps/ Makefile init/ litenes/ lua/ nterm/ nwm/ pal/ # 仙剑奇侠传 slider/ fsimg/ # 根文件系统 libs/ # 库 libc/ # Newlib C库 libos/ # 系统调用的用户层封装 syscall.h # 系统调用类型 tests/ # 一些测试 nemu/ nexus-am/ libs/libos/syscall.h 与 nanos-lite/syscall.h 相同。 libs/ libc/ Newlib 项目, 它是一个专门为嵌入式系统提供的 C 库, 库中的函数对运行时环境的要求极低. 这对Nanos-lite来说是非常友好的, 我们不需要为了配合C库而在Nanos-lite中实现额外的功能.</description></item><item><title>64位有符号数乘法取模问题</title><link>https://stardustdl.github.io/posts/learning/multimod-64bit-method/</link><pubDate>Thu, 25 Oct 2018 17:30:22 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/multimod-64bit-method/</guid><description>问题引入 给定 $64$ 位有符号整数 $a,b,m$ （类型为 int64_t），希望求出 $a\times b \bmod m$ 的数值。
int64_t multimod(int64_t a, int64_t b, int64_t m); 给出一个尽可能高效的正确 multimod 实现。使得它对于任意在 $[0,2^{63}-1]$ 范围内的 $a,b,m$ 均能正确求出 $a\times b \bmod m$ 的数值，且在任何时候不触发有符号整数溢出。
解决方法 运行环境 Windows 10 （64 位） 上 Hyper-V 平台，Debian 9 虚拟机 （64 位）
CPU 型号：Intel(R) Core(TM) i7-7700HQ CPU 主频：2.80 GHz 基础设施 为使实验顺利，实验前先准备了测试程序和时间测量程序。
测试程序 使用 Python 自动生成测试用例，运行程序，检查输出。
import os import random import sys def getNum(): return random.randint(0,2**63-1) if __name__==&amp;#34;__main__&amp;#34;: cnt = 10**4; passed = 0 failed = 0 if len(sys.</description></item><item><title>NJU ICS Programming Assignment 代码分析 - NEXUS-AM</title><link>https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nexus-am/</link><pubDate>Tue, 23 Oct 2018 17:30:22 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nexus-am/</guid><description>概述 框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言 一方面, 应用程序的运行都需要运行时环境的支持; 另一方面, 只进行纯粹计算任务的程序在TRM上就可以运行, 更复杂的应用程序对运行时环境必定还有其它的需求。将这些需求收集起来，抽象成统一的API提供给程序, 这样我们就得到了一个可以支撑各种程序运行在各种机器上的库。具体地, 每个机器都按照它们的特性实现这组API; 应用程序只需要直接调用这组API即可, 无需关心自己将来运行在哪个机器上. 由于这组统一抽象的API代表了程序运行对机器的需求, 所以我们把这组API称为抽象计算机.
NEXUS-AM(Abstract machine) 把程序和机器解耦。作为一个向程序提供运行时环境的库, AM根据程序的需求把库划分成以下模块
AM = TRM + IOE + CTE + VME + MPE TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力 IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力 CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力 VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力 MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力 框架代码结构 nanos-lite/ navy-apps/ nemu/ nexus-am/ # NEXUS-AM 项目 am/ # AM 相关 arch/ # 不同机器的 AM 实现 native/ x86-nemu/ build/ # AM 构建输出文件夹 apps/ # 直接运行在AM上的应用 hello/ # Hello World 程序 dhrystone/ # 性能测试程序 1 coremark/ # 性能测试程序 2 microbench/ # 性能测试程序 3 slider/ # 幻灯片播放程序 typing/ # 打字小游戏 litenes/ # 超级玛丽 libs/ # 可以直接运行在AM上的库 compiler-rt/ fixmath/ imgui/ klib/ # kernel library, 提供一些兼容 libc 的基础功能 tests/ # 直接运行在AM上的测试 cputest/ # CPU 实现测试（指令译码与执行） timetest/ # 时钟设备测试 keytest/ # 键盘设备测试 videotest/ # VGA 设备测试 .</description></item><item><title>NJU ICS Programming Assignment 代码分析 - NEMU</title><link>https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nemu/</link><pubDate>Fri, 05 Oct 2018 19:30:22 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nemu/</guid><description>概述 框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言 由于 NJU ICS PA 框架代码较多且缺少足够说明，讲义多为基础引入内容，为方便后续程序编写，根据实际作业过程中的理解整理出此文。 本文主要包含对 NJU ICS 课程编程作业的框架代码中 NEMU 部分的理解和分析，跟随课程及讲义进度更新，以个人使用为主，可能存在错误。
部分内容框架代码并不包含（如扩展的 Debug 宏），均为我为编码而添加的内容。采用 a_b 方式命名的多为原内容，采用 aB 方式命名的多为补充内容。由于此项目是 NJU ICS PA 的一部分，其中会包含与相关项目的互操作内容。
NEMU (NJU EMUlator) 是在 Linux 上的一个 n86（x86 子集）模拟器，模拟了基本计算机系统的功能（内存，CPU等）。包含了：
内存 CPU，寄存器 调试器（监视器） 框架代码结构 nanos-lite/ navy-apps/ nexus-am/ nemu/ # NEMU 项目 build/ # 构建输出文件夹 nemu # NEMU 主程序（可执行文件） include/ # 头文件 src/ # 源码文件 tools/ # 工具文件 runall.</description></item><item><title>OJ-oriented Problem Solving 命题报告</title><link>https://stardustdl.github.io/posts/learning/ojops-problem-design/</link><pubDate>Tue, 11 Sep 2018 17:30:22 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/ojops-problem-design/</guid><description>题面 题目概述 时间限制：1000 ms 空间限制：128 MB 命题人：Stardust D.L. 验题人：GodCallMeGod, Pexure 题目描述 小 A 和你我一样，正坐在电脑前刷题。但茫茫多的 OJ 和茫茫多的题目，让他感到无从下手。幸运的是，小 A 得到了一个神奇的工具，能很快生成一个指定长度的题目列表，还能标识出题目的难度等级。小 A 用这个工具生成了一个长度为 $n$ 的题目列表，但这个题目列表中难度安排不太令人满意，为了提高刷题体验，也尽快提高问题求解能力，小 A 决定把其中一些题换掉，来让题目难度安排更加合理。 形式化的，设题目列表 $a$，$a_i(1\le i\le n)$ 表示第 $i$ 道题的难度（数值越大，难度越高），定义 对于题目列表的“难度渐进”值 $Q(a)$ 为：
$$ Q(a)=\sum_{i=2}^n \min(1,a_i-a_{i-1}) $$
小 A 希望将 某一些 $a_i$ 改成 $a_i'$（由于可以任意挑题目，所以这里选取的 $a_i'\in \mathbb{Z}$ 是任意的，即使是负值也可以），使得修改后的新序列 $a'$，$Q(a')$ 最大。为了尽快开始做题，小 A 希望被替换的题目数量越少越好。请求出最少替换几道题目能使得 $Q(a')$ 最大。
输入 第一行一个整数 $T$，表示 $T$ 组测试数据。 之后对于每组测试数据： 第一行一个整数 $n$，表示题目列表长度。 第二行 $n$ 个整数 $a_i$，表示每道题目的难度。
输出 $T$ 行，每行一个整数表示答案。</description></item><item><title>栈与队列的相互实现</title><link>https://stardustdl.github.io/posts/learning/the-mutual-realization-of-stack-and-queue/</link><pubDate>Tue, 28 Aug 2018 17:30:22 +0800</pubDate><guid>https://stardustdl.github.io/posts/learning/the-mutual-realization-of-stack-and-queue/</guid><description>本文介绍使用栈实现队列和使用队列实现栈的方法。为使问题更加有意义，我们将尽量选择一个较优的实现方法。
问题引入 栈：先进后出的线性结构，仅允许对栈顶进行添加（push），删除（pop），访问（peek）操作，空间复杂度线性，单次操作时间复杂度为常数 队列：先进先出线性结构，仅允许对队尾进行添加（enqueue）操作，以及对队首进行删除（dequeue），访问（peek）操作，空间复杂度线性，单次操作时间复杂度为常数 需要解决的问题，在使用常数个额外空间的条件下： 使用两个栈尽可能高效地实现一个队列 使用两个队列尽可能高效地实现一个栈 解决方法 使用栈实现队列 思路 考虑到栈先进后出与队列先进先出的特点，使用一个栈 $A$ 作为队列尾，数据从这里流入；使用另一个栈 $B$ 作为队列头，数据从这里流出。我们要求先流入的数据先流出， 通过将栈 $A$ 中的元素不断弹出，并压入栈 $B$，利用先进后出特性，$B$ 的出栈顺序即 $A$ 出栈顺序的逆序，而 $A$ 出栈顺序为其入栈顺序的逆序，故 $B$ 的出栈顺序为 $A$ 的入栈顺序，即达到先进先出的效果。
栈能将输入逆序这一点很重要，之后我们还将用到。
复杂度分析 空间复杂度：栈的空间复杂度是线性的，而且这里队列中的每一个数据仅会在两个栈中的某一个中存在，故此实现的空间复杂度为线性 时间复杂度：注意到每个数据从入队到出队只会经历：进入 $A$，离开 $A$，进入 $B$，离开 $B$ 四次移动，且每次移动复杂度为常数，故均摊复杂度为常数。 使用队列实现栈 思路 这里遇到了个难题：利用栈可以很容易地支持翻转操作，但队列无法直接对输入序列进行顺序的改变。
队列中一个重要特点是，我们可以通过不断删除队列头，并将其放入队列尾，实现在不影响顺序的前提下对队列中每个元素的访问，访问一遍后，我们仍可以很容易恢复到最初的队列状态。 但这一操作的弊端是，我们访问某个元素，必须将其前面的所有元素出队，这一操作的时间复杂度是最坏情况下是线性的。
既然我们能访问所有元素了，那只要访问最后一个就是先入后出了，很简单嘛，可是队列“滚”的次数太多了（为线性）&amp;hellip;
为下文叙述方便，将上述操作定义为过程“循环出入队”，即将队首出队后入队，实现队列滚动。时间复杂度由以上分析，为 $O(|Q|))$。 我们使用一个类似缓冲池的技巧：设两个队列 $Q_s,Q_a$，$Q_a$ 用于存储靠近栈顶的一部分元素，$Q_s$ 用于存储其余的元素。其中 $Q_a$ 有可变的容量上限 $cap(Q_a)$，$Q_s$ 容量无限制。
你可以把 $Q_s$ 看成内存（主存），把 $Q_a$ 看成 CPU 中的高速缓存</description></item></channel></rss>
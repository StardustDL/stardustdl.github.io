<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="概述  框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言  一方面, 应用程序的运行都需要运行时环境的支持; 另一方面, 只进行纯粹计算任务的程序在TRM上就可以运行, 更复杂的应用程序对运行时环境必定还有其它的需求。将这些需求收集起来，抽象成统一的API提供给程序, 这样我们就得到了一个可以支撑各种程序运行在各种机器上的库。具体地, 每个机器都按照它们的特性实现这组API; 应用程序只需要直接调用这组API即可, 无需关心自己将来运行在哪个机器上. 由于这组统一抽象的API代表了程序运行对机器的需求, 所以我们把这组API称为抽象计算机.
NEXUS-AM(Abstract machine) 把程序和机器解耦。作为一个向程序提供运行时环境的库, AM根据程序的需求把库划分成以下模块
AM = TRM + IOE + CTE + VME + MPE  TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力 IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力 CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力 VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力 MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力  框架代码结构 nanos-lite/ navy-apps/ nemu/ nexus-am/ # NEXUS-AM 项目 am/ # AM 相关 arch/ # 不同机器的 AM 实现 native/ x86-nemu/ build/ # AM 构建输出文件夹 apps/ # 直接运行在AM上的应用 hello/ # Hello World 程序 dhrystone/ # 性能测试程序 1 coremark/ # 性能测试程序 2 microbench/ # 性能测试程序 3 slider/ # 幻灯片播放程序 typing/ # 打字小游戏 litenes/ # 超级玛丽 libs/ # 可以直接运行在AM上的库 compiler-rt/ fixmath/ imgui/ klib/ # kernel library, 提供一些兼容 libc 的基础功能 tests/ # 直接运行在AM上的测试 cputest/ # CPU 实现测试（指令译码与执行） timetest/ # 时钟设备测试 keytest/ # 键盘设备测试 videotest/ # VGA 设备测试 ."><title>NJU ICS Programming Assignment 代码分析 - NEXUS-AM</title><link rel=canonical href=https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nexus-am/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="NJU ICS Programming Assignment 代码分析 - NEXUS-AM"><meta property="og:description" content="概述  框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言  一方面, 应用程序的运行都需要运行时环境的支持; 另一方面, 只进行纯粹计算任务的程序在TRM上就可以运行, 更复杂的应用程序对运行时环境必定还有其它的需求。将这些需求收集起来，抽象成统一的API提供给程序, 这样我们就得到了一个可以支撑各种程序运行在各种机器上的库。具体地, 每个机器都按照它们的特性实现这组API; 应用程序只需要直接调用这组API即可, 无需关心自己将来运行在哪个机器上. 由于这组统一抽象的API代表了程序运行对机器的需求, 所以我们把这组API称为抽象计算机.
NEXUS-AM(Abstract machine) 把程序和机器解耦。作为一个向程序提供运行时环境的库, AM根据程序的需求把库划分成以下模块
AM = TRM + IOE + CTE + VME + MPE  TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力 IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力 CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力 VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力 MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力  框架代码结构 nanos-lite/ navy-apps/ nemu/ nexus-am/ # NEXUS-AM 项目 am/ # AM 相关 arch/ # 不同机器的 AM 实现 native/ x86-nemu/ build/ # AM 构建输出文件夹 apps/ # 直接运行在AM上的应用 hello/ # Hello World 程序 dhrystone/ # 性能测试程序 1 coremark/ # 性能测试程序 2 microbench/ # 性能测试程序 3 slider/ # 幻灯片播放程序 typing/ # 打字小游戏 litenes/ # 超级玛丽 libs/ # 可以直接运行在AM上的库 compiler-rt/ fixmath/ imgui/ klib/ # kernel library, 提供一些兼容 libc 的基础功能 tests/ # 直接运行在AM上的测试 cputest/ # CPU 实现测试（指令译码与执行） timetest/ # 时钟设备测试 keytest/ # 键盘设备测试 videotest/ # VGA 设备测试 ."><meta property="og:url" content="https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nexus-am/"><meta property="og:site_name" content="StardustDL's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="NJU"><meta property="article:published_time" content="2018-10-23T17:30:22+08:00"><meta property="article:modified_time" content="2018-10-23T17:30:22+08:00"><meta name=twitter:title content="NJU ICS Programming Assignment 代码分析 - NEXUS-AM"><meta name=twitter:description content="概述  框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言  一方面, 应用程序的运行都需要运行时环境的支持; 另一方面, 只进行纯粹计算任务的程序在TRM上就可以运行, 更复杂的应用程序对运行时环境必定还有其它的需求。将这些需求收集起来，抽象成统一的API提供给程序, 这样我们就得到了一个可以支撑各种程序运行在各种机器上的库。具体地, 每个机器都按照它们的特性实现这组API; 应用程序只需要直接调用这组API即可, 无需关心自己将来运行在哪个机器上. 由于这组统一抽象的API代表了程序运行对机器的需求, 所以我们把这组API称为抽象计算机.
NEXUS-AM(Abstract machine) 把程序和机器解耦。作为一个向程序提供运行时环境的库, AM根据程序的需求把库划分成以下模块
AM = TRM + IOE + CTE + VME + MPE  TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力 IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力 CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力 VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力 MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力  框架代码结构 nanos-lite/ navy-apps/ nemu/ nexus-am/ # NEXUS-AM 项目 am/ # AM 相关 arch/ # 不同机器的 AM 实现 native/ x86-nemu/ build/ # AM 构建输出文件夹 apps/ # 直接运行在AM上的应用 hello/ # Hello World 程序 dhrystone/ # 性能测试程序 1 coremark/ # 性能测试程序 2 microbench/ # 性能测试程序 3 slider/ # 幻灯片播放程序 typing/ # 打字小游戏 litenes/ # 超级玛丽 libs/ # 可以直接运行在AM上的库 compiler-rt/ fixmath/ imgui/ klib/ # kernel library, 提供一些兼容 libc 的基础功能 tests/ # 直接运行在AM上的测试 cputest/ # CPU 实现测试（指令译码与执行） timetest/ # 时钟设备测试 keytest/ # 键盘设备测试 videotest/ # VGA 设备测试 ."><link rel="shortcut icon" href=/favicon.png><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-111573521-1','auto'),ga('send','pageview'))</script></head><body class="article-page has-toc"><script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.documentElement.dataset.scheme='dark':document.documentElement.dataset.scheme='light'})()</script><div class="container main-container flex
extended"><div id=article-toolbar><a href=https://stardustdl.github.io/ class=back-home><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="15 6 9 12 15 18"/></svg><span>Back</span></a></div><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/learning/>Learning</a></header><h2 class=article-title><a href=/posts/learning/nju-icspa-analytics-nexus-am/>NJU ICS Programming Assignment 代码分析 - NEXUS-AM</a></h2><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Oct 23, 2018</time></footer></div></header><section class=article-content><h1 id=概述>概述</h1><ul><li><a class=link href=https://github.com/NJU-ProjectN/nexus-am target=_blank rel=noopener>框架代码库</a></li><li>CPU 架构：x64</li><li>操作系统: GNU/Linux</li><li>编译器: GCC</li><li>编程语言：C 语言</li></ul><p>一方面, 应用程序的运行都需要运行时环境的支持; 另一方面, 只进行纯粹计算任务的程序在TRM上就可以运行, 更复杂的应用程序对运行时环境必定还有其它的需求。将这些需求收集起来，抽象成统一的API提供给程序, 这样我们就得到了一个可以支撑各种程序运行在各种机器上的库。具体地, 每个机器都按照它们的特性实现这组API; 应用程序只需要直接调用这组API即可, 无需关心自己将来运行在哪个机器上. 由于这组统一抽象的API代表了程序运行对机器的需求, 所以我们把这组API称为抽象计算机.</p><p>NEXUS-AM(Abstract machine) 把程序和机器解耦。作为一个向程序提供运行时环境的库, AM根据程序的需求把库划分成以下模块</p><pre><code>AM = TRM + IOE + CTE + VME + MPE
</code></pre><ul><li>TRM(Turing Machine) - 图灵机, 最简单的运行时环境, 为程序提供基本的计算能力</li><li>IOE(I/O Extension) - 输入输出扩展, 为程序提供输出输入的能力</li><li>CTE(Context Extension) - 上下文扩展, 为程序提供上下文管理的能力</li><li>VME(Virtual Memory Extension) - 虚存扩展, 为程序提供虚存管理的能力</li><li>MPE(Multi-Processor Extension) - 多处理器扩展, 为程序提供多处理器通信的能力</li></ul><h2 id=框架代码结构>框架代码结构</h2><pre><code>nanos-lite/
navy-apps/
nemu/
nexus-am/                   # NEXUS-AM 项目
    am/                     # AM 相关
        arch/               # 不同机器的 AM 实现
            native/
            x86-nemu/
        build/              # AM 构建输出文件夹
    apps/                   # 直接运行在AM上的应用
        hello/              # Hello World 程序
        dhrystone/          # 性能测试程序 1
        coremark/           # 性能测试程序 2
        microbench/         # 性能测试程序 3
        slider/             # 幻灯片播放程序
        typing/             # 打字小游戏
        litenes/            # 超级玛丽
    libs/                   # 可以直接运行在AM上的库
        compiler-rt/
        fixmath/
        imgui/
        klib/               # kernel library, 提供一些兼容 libc 的基础功能
    tests/                  # 直接运行在AM上的测试
        cputest/            # CPU 实现测试（指令译码与执行）
        timetest/           # 时钟设备测试
        keytest/            # 键盘设备测试
        videotest/          # VGA 设备测试
        ...
    Makefile                # AM 构建命令
    Makefile.check          # AM 上项目的构建命令
</code></pre><h1 id=makefilecheck>Makefile.check</h1><p>通过设置 <code>ARCH</code> 变量，指定默认 AM：</p><ul><li><code>native</code></li><li><code>x86-nemu</code></li></ul><h1 id=am>am/</h1><h2 id=特定-am-实现代码结构>特定 AM 实现代码结构</h2><p>此为大致结构，不一定完全按照此结构。</p><pre><code>img/
    build
    run
include/            # 头文件
    arch.h          # 基础头文件
src/                # 源码文件
    devices/        # 设备接口实现
        input.c     # 输入设备（键盘）
        timer.c     # 时钟设备
        video.c     # VGA 设备
    cte.c           # 对 CTE API 部分的实现。
    ioe.c           # 对 IOE API 部分的实现。
    trm.c           # 对 TRM API 部分的实现。
    vme.c           # 对 VME API 部分的实现。
    trap.S
</code></pre><ul><li><code>input.c</code> 中需要实现对寄存器 <code>_DEVREG_INPUT_KBD</code> 的支持</li></ul><h2 id=amh>am.h</h2><p>定义了 AM 基础 API。</p><h3 id=枚举>枚举</h3><p>定义了事件类型枚举，指示事件类型。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>enum</span> <span class=p>{</span>
  <span class=n>_EVENT_NULL</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
  <span class=n>_EVENT_ERROR</span><span class=p>,</span>
  <span class=n>_EVENT_IRQ_TIMER</span><span class=p>,</span>
  <span class=n>_EVENT_IRQ_IODEV</span><span class=p>,</span>
  <span class=n>_EVENT_PAGEFAULT</span><span class=p>,</span>
  <span class=n>_EVENT_YIELD</span><span class=p>,</span>     <span class=c1>// 自陷
</span><span class=c1></span>  <span class=n>_EVENT_SYSCALL</span><span class=p>,</span>   <span class=c1>// 系统调用
</span><span class=c1></span><span class=p>};</span>
</code></pre></div><h3 id=结构体>结构体</h3><h4 id=_context>_Context</h4><p>规定了上下文结构体 <code>_Context</code>。
因为不同机器之间上下文信息的差异过大，所以在AM中, <code>_Context</code> 的具体成员也是由不同的机器自己定义的。因此, 在操作系统中, 对 <code>_Context</code> 成员的直接引用, 都属于机器相关的行为, 会损坏操作系统的可移植性. 不过大多数情况下, 操作系统并不需要单独访问 <code>_Context</code> 结构中的成员. 必要的时候, CTE也可以提供一些统一的接口, 来让操作系统通过这些接口来访问, 从而保证操作系统的相关代码与机器无关.</p><h4 id=_area>_Area</h4><p>一段内存区域。</p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td><code>start</code></td><td>起点</td></tr><tr><td><code>end</code></td><td>终点（不包含）</td></tr></tbody></table><h4 id=_device>_Device</h4><p>设备。</p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td><code>id</code></td><td>唯一ID</td></tr><tr><td><code>name</code></td><td>名字(非必须)</td></tr><tr><td><code>read</code></td><td>读操作</td></tr><tr><td><code>write</code></td><td>写操作</td></tr></tbody></table><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>size_t</span> <span class=p>(</span><span class=o>*</span><span class=n>read</span><span class=p>)</span> <span class=p>(</span><span class=n>uintptr_t</span> <span class=n>reg</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>size</span><span class=p>);</span>
<span class=n>size_t</span> <span class=p>(</span><span class=o>*</span><span class=n>write</span><span class=p>)(</span><span class=n>uintptr_t</span> <span class=n>reg</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>buf</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>size</span><span class=p>);</span>
</code></pre></div><ul><li><code>read()/write()</code> 分别是设备读/写操作的实现, 用于从设备的 <code>reg</code> 寄存器中读出 <code>size</code> 字节的内容到缓冲区 <code>buf</code> 中, 或者往设备的 <code>reg</code> 寄存器中写入缓冲区 <code>buf</code> 中的 <code>size</code> 字节的内容</li></ul><p>需要注意的是, 这里的reg寄存器并不是设备寄存器, 因为设备寄存器的编号是机器相关的. 在IOE中, 我们希望采用一种机器无关的"抽象寄存器", 这个reg其实是一个功能编号, 我们约定在不同的机器中, 同一个功能编号的含义也是相同的, 这样就实现了设备寄存器的抽象.</p><h4 id=_event>_Event</h4><p>事件，指示程序流切换的原因。</p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td><code>event</code></td><td>事件类型编号，使用上述枚举</td></tr><tr><td><code>cause</code></td><td>描述信息</td></tr><tr><td><code>ref</code></td><td></td></tr><tr><td><code>msg</code></td><td>事件信息字符串</td></tr></tbody></table><h3 id=trm>TRM</h3><ul><li><code>void _trm_init()</code> 初始化 TRM</li><li><code>_Area _heap</code> 结构用于指示堆区的起始和末尾</li><li><code>void _putc(char ch)</code> 输出一个字符</li><li><code>void _halt(int code)</code> 结束程序的运行</li></ul><h3 id=ioe>IOE</h3><ul><li><code>int _ioe_init()</code> 初始化 IOE</li><li><code>_Device *_device(int n)</code> 返回编号为 <code>n</code> 的设备的数据结构. 机器中的可用设备从 <code>1</code> 开始按顺序编号, 若不存在编号为 <code>n</code> 的设备, 则返回 <code>NULL</code>。<ul><li>可以使用这个 API 枚举机器中的每一个设备。</li></ul></li></ul><h3 id=cte>CTE</h3><ul><li><code>int _cte_init(_Context* (*handler)(_Event ev, _Context *ctx))</code> 用于进行CTE相关的初始化操作. 其中它还接受一个来自操作系统的事件处理回调函数的指针, 当发生事件时, CTE将会把事件和相关的上下文作为参数, 来调用这个回调函数, 交由操作系统进行后续处理.</li><li><code>void _yield()</code> 用于进行自陷操作, 会触发一个编号为 <code>_EVENT_YIELD</code> 事件.</li></ul><h3 id=vme>VME</h3><p>(TODO)</p><h3 id=mpe>MPE</h3><p>(TODO)</p><h2 id=amdevh>amdev.h</h2><p>使用宏定义常见设备 ID ：</p><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td><code>_DEV_INPUT</code></td><td>输入设备</td></tr><tr><td><code>_DEV_TIMER</code></td><td>时钟设备</td></tr><tr><td><code>_DEV_VIDEO</code></td><td>VGA 设备</td></tr></tbody></table><p>使用宏定义了一些用于设备访问的抽象寄存器并定义了相关结构体：</p><ul><li><code>_DEVREG_INPUT_KBD</code> 键盘控制器<ul><li>从中读出 <code>_KbdReg</code> 结构体, <code>keydown = 1</code> 为按下按键, <code>keydown = 0</code> 为释放按键. <code>keycode</code> 为按键的<strong>断码</strong>, 没有按键时, <code>keycode</code> 为 <code>_KEY_NONE</code> .</li></ul></li><li><code>_DEVREG_TIMER_UPTIME</code> 系统启动时间<ul><li>从中读出 <code>_UptimeReg</code> 结构体, <code>(hi &lt;&lt; 32LL) | lo</code> 是系统启动的毫秒数.</li></ul></li><li><code>_DEVREG_TIMER_DATE</code> 实时时钟(RTC)<ul><li>从中读出 <code>_DateReg</code> 结构体, 包含年月日时分秒</li></ul></li><li><code>_DEVREG_VIDEO_INFO</code> 显示控制器信息<ul><li>从中读出 <code>_VideoInfoReg</code> 结构体, 其中 <code>width</code> 为屏幕宽度, <code>height</code> 为屏幕高度. 另外假设AM运行过程中, 屏幕大小不会发生变化.</li></ul></li><li><code>_DEVREG_VIDEO_FBCTL</code> 帧缓冲控制器<ul><li>向其写入 <code>_FBCtlReg</code> 结构体, 向屏幕 <code>(x, y)</code> 坐标处绘制 <code>w*h</code> 的矩形图像. 图像像素按行优先方式存储在 <code>pixels</code> 中, 每个像素用32位整数以 <code>00RRGGBB</code> 的方式描述颜色.</li></ul></li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define _DEVREG_INPUT_KBD     1
</span><span class=cp></span>  <span class=p>...</span>
  <span class=k>enum</span> <span class=p>{</span>
    <span class=n>_KEY_NONE</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
    <span class=n>_KEYS</span><span class=p>(</span><span class=n>_KEY_NAME</span><span class=p>)</span>
  <span class=p>};</span>
  <span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>keydown</span><span class=p>;</span> <span class=c1>// is keydown ? 1 : 0
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>keycode</span><span class=p>;</span> <span class=c1>// key code _KEY_XXX
</span><span class=c1></span>  <span class=p>}</span> <span class=n>_KbdReg</span><span class=p>;</span>

<span class=c1>// ----------- _DEV_TIMER: AM Real Time Clock (0000ac03) -------------
</span><span class=c1></span><span class=cp>#define _DEVREG_TIMER_UPTIME  1
</span><span class=cp></span>  <span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
    <span class=kt>uint32_t</span> <span class=n>hi</span><span class=p>;</span> <span class=c1>// high 32bit of uptime (ms)
</span><span class=c1></span>    <span class=kt>uint32_t</span> <span class=n>lo</span><span class=p>;</span> <span class=c1>//  low 32bit of uptime (ms)
</span><span class=c1></span>  <span class=p>}</span> <span class=n>_UptimeReg</span><span class=p>;</span>

<span class=cp>#define _DEVREG_TIMER_DATE    2
</span><span class=cp></span>  <span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>year</span><span class=p>,</span> <span class=n>month</span><span class=p>,</span> <span class=n>day</span><span class=p>;</span>     <span class=c1>// date
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>hour</span><span class=p>,</span> <span class=n>minute</span><span class=p>,</span> <span class=n>second</span><span class=p>;</span> <span class=c1>// time
</span><span class=c1></span>  <span class=p>}</span> <span class=n>_RTCReg</span><span class=p>;</span>

<span class=c1>// ----------- _DEV_VIDEO: AM Video Controller (0000ac04) ------------
</span><span class=c1></span><span class=cp>#define _DEVREG_VIDEO_INFO    1
</span><span class=cp></span>  <span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
    <span class=kt>int32_t</span> <span class=n>width</span><span class=p>,</span> <span class=n>height</span><span class=p>;</span> <span class=c1>// screen size: @width * @height
</span><span class=c1></span>  <span class=p>}</span> <span class=n>_VideoInfoReg</span><span class=p>;</span>

<span class=cp>#define _DEVREG_VIDEO_FBCTL   2
</span><span class=cp></span>  <span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
    <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>;</span>         <span class=c1>// draw to (@x, @y)
</span><span class=c1></span>    <span class=kt>uint32_t</span> <span class=o>*</span><span class=n>pixels</span><span class=p>;</span> <span class=c1>// @pixels: @w*@h pixels to draw
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>w</span><span class=p>,</span> <span class=n>h</span><span class=p>;</span>         <span class=c1>//   @pixels[i * w + j] is 00RRGGBB 
</span><span class=c1></span>    <span class=kt>int</span> <span class=n>sync</span><span class=p>;</span>         <span class=c1>// @sync ? sync screen : do nothing
</span><span class=c1></span>  <span class=p>}</span> <span class=n>_FBCtlReg</span><span class=p>;</span>
</code></pre></div><h2 id=amtraceh>amtrace.h</h2><p>(TODO)</p><h2 id=x86-nemu>x86-nemu/</h2><h3 id=x86-nemu-编译与运行流程>x86-NEMU 编译与运行流程</h3><blockquote><p>在让NEMU运行客户程序之前, 我们需要将客户程序的代码编译成可执行文件. 需要说明的是, 我们不能使用gcc的默认选项直接编译, 因为默认选项会根据GNU/Linux的运行时环境将代码编译成运行在GNU/Linux下的可执行文件. 但此时的NEMU并不能为客户程序提供GNU/Linux的运行时环境, 在NEMU中无法正确运行上述可执行文件, 因此我们不能使用gcc的默认选项来编译用户程序.</p></blockquote><p>解决这个问题的方法是<strong>交叉编译</strong>, 我们需要在GNU/Linux下根据AM的运行时环境编译出能够在 <code>x86-nemu</code> 这个新环境中运行的可执行文件. 为了不让链接器 <code>ld</code> 使用默认的方式链接, 我们还需要提供描述 <code>x86-nemu</code> 的运行时环境的链接脚本. AM的框架代码已经把相应的配置准备好了:</p><ol><li>gcc 将 <code>x86-nemu</code> 的AM实现的源文件编译成目标文件, 然后通过 ar 将这些目标文件作为一个库, 打包成一个归档文件</li><li>gcc 把应用程序源文件编译成目标文件</li><li>必要的时候通过 gcc 和 ar 把程序依赖的运行库 (如 <code>nexus-am/libs/klib</code>) 也打包成归档文件</li><li>执行脚本文件 <code>nexus-am/am/arch/x86-nemu/img/build</code>, 在脚本文件中<ol><li>将程序入口 <code>nexus-am/am/arch/x86-nemu/img/boot/start.S</code> 编译成目标文件</li><li>最后让 ld 根据链接脚本 <code>nexus-am/am/arch/x86-nemu/img/loader.ld</code>, 将上述目标文件和归档文件链接成可执行文件</li></ol></li></ol><p>根据这一链接脚本的指示, 可执行程序重定位后的节从 <code>0x100000</code> 开始, 首先是 <code>.text</code> 节, 其中又以 <code>nexus-am/am/arch/x86-nemu/img/boot/start.o</code> 中自定义的 <code>entry</code> 节开始, 然后接下来是其它目标文件的 <code>.text</code> 节. 这样, 可执行程序的 <code>0x100000</code> 处总是放置 <code>nexus-am/am/arch/x86-nemu/img/boot/start.S</code> 的代码, 而不是其它代码, 保证客户程序总能从 <code>0x100000</code> 开始正确执行. 链接脚本也定义了其它节(包括 <code>.rodata, .data, .bss</code> )的链接顺序, 还定义了一些关于位置信息的符号, 包括每个节的末尾, 栈顶位置, 堆区的起始和末尾.</p><p>我们对编译得到的可执行文件的行为进行简单的梳理:</p><ol><li>第一条指令从 <code>nexus-am/am/arch/x86-nemu/img/boot/start.S</code> 开始, 设置好栈顶之后就跳转到 <code>nexus-am/am/arch/x86-nemu/src/trm.c</code> 的 <code>_trm_init()</code> 函数处执行.</li><li>在 <code>_trm_init()</code> 中调用 <code>main()</code> 函数执行程序的主体功能.</li><li>从 <code>main()</code> 函数返回后, 调用 <code>_halt()</code> 结束运行.</li></ol><h3 id=include>include/</h3><h4 id=archh>arch.h</h4><p>定义了宏 <code>PMEM_SIZE</code> 指定物理内存大小。</p><h5 id=结构体-_context>结构体 _Context</h5><p>x86-nemu 上的上下文结构体。其顺序根据上下文构造过程决定（需参考 <code>int pusha</code> 指令以及 <code>trap.S</code> 实现）。
上下文构造过程：</p><ul><li><code>int</code> 指令</li><li><code>trap.S</code> 中指令<ul><li><code>pusha</code> 指令</li></ul></li></ul><p>在还原上下文时，仍需要根据上述顺序还原。</p><p>系统调用事件的参数被 CTE 保存到上下文中。为方便处理系统调用事件，定义以下宏对应系统调用参数（根据 <code>navy-apps/libs/libos/src/nanos.c</code> 中的 <code>_syscall_</code>）。系统调用类型参见 <code>nanos-lite/syscall.h</code>。</p><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td><code>GPR1</code></td><td>系统调用 ID</td></tr><tr><td><code>GPR2</code></td><td>第一个参数</td></tr><tr><td><code>GPR3</code></td><td>第二个参数</td></tr><tr><td><code>GPR4</code></td><td>第三个参数</td></tr><tr><td><code>GPRx</code></td><td>系统调用返回值</td></tr></tbody></table><h4 id=x86-nemuh>x86-nemu.h</h4><p>包含了 <code>arch.h</code>.</p><h4 id=x86h>x86.h</h4><p>定义了大量宏常量。</p><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td><code>NR_IRQ</code></td><td>IDT 大小</td></tr></tbody></table><p>定义了辅助函数（使用内联汇编实现）：</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>uint8_t inb(int port)</code></td><td>从端口读取一字节值</td></tr><tr><td><code>uint16_t inw(int port)</code></td><td>从端口读取双字节值</td></tr><tr><td><code>uint32_t inl(int port)</code></td><td>从端口读取四字节值</td></tr><tr><td><code>void outb(int port, uint8_t data)</code></td><td>从端口写入一字节值</td></tr><tr><td><code>void outw(int port, uint16_t data)</code></td><td>从端口写入双字节值</td></tr><tr><td><code>void outl(int port, uint32_t data)</code></td><td>从端口写入四字节值</td></tr><tr><td><code>void set_idt(GateDesc *idt, int size)</code></td><td>设置 IDTR 寄存器</td></tr></tbody></table><h4 id=结构体-gatedesc>结构体 GateDesc</h4><p>指示中断操作的门描述符(Gate Descriptor)类型。与 NEMU 中定义的对应结构体结构相同。</p><p>定义了宏 <code>GATE(type, cs, entry, dpl)</code> 简化 GateDesc 构造。</p><h3 id=src>src/</h3><h4 id=devices>devices/</h4><p>对应于 NEMU 中的设备实现设备访问接口。利用端口映射 I/O 和内存映射 I/O。参见 {% post_link solving/nju-icspa-analytics-nemu#device.c %}。</p><ul><li>键盘访问端口 <code>I8042_DATA_PORT</code></li><li>时钟访问端口 <code>RTC_PORT</code></li><li>VGA 访问端口 <code>SCREEN_PORT</code> 和内存 <code>VMEM</code></li></ul><p>对每个设备，需要实现 <code>amdev.h</code> 中特定抽象寄存器的操作。在设备初始化函数 <code>deviceName_init()</code> 中，可以进行一些初始化操作。</p><h4 id=ctec>cte.c</h4><p>定义了 IDT 数组 <code>idt</code>.</p><p><code>_yield()</code> 实现：</p><ul><li>在 x86-nemu 中, 我们约定自陷操作通过 <code>0x81</code> 号中断（<code>int $0x81</code>）触发（在 <code>trap.S</code> 中规定）.</li></ul><p><code>_cte_init</code> 实现：</p><ul><li>初始化 IDT<ul><li>设置 <code>vectrap</code> 与 <code>vecsys</code></li></ul></li><li>设置 IDTR 寄存器（使用 <code>set_idt</code>）</li><li>注册 <code>user_handler</code></li></ul><h5 id=函数-irq_handle>函数 irq_handle</h5><p>硬件级别（NEMU）中断处理函数。根据上下文生成 _Event，调用注册的用户回调函数。</p><h4 id=traps>trap.S</h4><p>给出了 <code>vecsys vectrap irq0 vecnull</code> 等调用 CTE 处理过程的函数。</p><h5 id=函数-asm_trap>函数 asm_trap</h5><p>构造上下文，调用函数 <code>irq_handle</code>。</p><h1 id=libs>libs/</h1><h2 id=klib>klib/</h2><p>Kernal Library. 提供一些兼容 libc 的基础功能。</p><h3 id=includeklibh>include/klib.h</h3><p>定义了 klib 中定义的的函数。</p><p>框架代码编译到 native 的时候默认链接到 glibc，可以使用宏 <code>__NATIVE_USE_KLIB__</code> 使这些调用链接到这里实现的 klib.</p><h3 id=src-1>src/</h3><h4 id=stdioc>stdio.c</h4><p>标准输入输出。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>vsnprintf</code></td><td>变长参数列表输出到字符串，限制最大字符数</td></tr><tr><td><code>vsprintf</code></td><td>变长参数列表输出到字符串</td></tr><tr><td><code>snprintf</code></td><td>输出到字符串，限制最大字符数</td></tr><tr><td><code>sprintf</code></td><td>输出到字符串</td></tr><tr><td><code>printf</code></td><td>输出到串口设备</td></tr></tbody></table><h4 id=stringc>string.c</h4><p>字符串操作。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>strlen</code></td><td></td></tr><tr><td><code>strcpy</code></td><td></td></tr><tr><td><code>strncpy</code></td><td></td></tr><tr><td><code>strcat</code></td><td></td></tr><tr><td><code>strcmp</code></td><td></td></tr><tr><td><code>strncmp</code></td><td></td></tr><tr><td><code>memset</code></td><td></td></tr><tr><td><code>memcpy</code></td><td></td></tr><tr><td><code>memcmp</code></td><td></td></tr></tbody></table><h4 id=stdlibc>stdlib.c</h4><p>标准库函数。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>rand</code></td><td></td></tr><tr><td><code>srand</code></td><td></td></tr></tbody></table><h4 id=ioc>io.c</h4><p>常用的输入输出功能。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=c1>// 返回系统启动后经过的毫秒数
</span><span class=c1></span><span class=kt>uint32_t</span> <span class=nf>uptime</span><span class=p>();</span>
<span class=c1>// 在 rtc 结构中返回当前时间, PA中不会用到
</span><span class=c1></span><span class=kt>void</span> <span class=nf>get_timeofday</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>rtc</span><span class=p>);</span>
<span class=c1>// 返回按键的键盘码, 若无按键, 则返回 _KEY_NONE 
</span><span class=c1></span><span class=kt>int</span> <span class=nf>read_key</span><span class=p>();</span>
<span class=c1>// 将 pixels 指定的矩形像素绘制到屏幕中以 (x, y) 和 (x+w, y+h) 两点连线为对角线的矩形区域
</span><span class=c1></span><span class=kt>void</span> <span class=nf>draw_rect</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=o>*</span><span class=n>pixels</span><span class=p>,</span> <span class=kt>int</span> <span class=n>x</span><span class=p>,</span> <span class=kt>int</span> <span class=n>y</span><span class=p>,</span> <span class=kt>int</span> <span class=n>w</span><span class=p>,</span> <span class=kt>int</span> <span class=n>h</span><span class=p>);</span>
<span class=c1>// 将之前的绘制内容同步到屏幕上
</span><span class=c1></span><span class=kt>void</span> <span class=nf>draw_sync</span><span class=p>();</span>
<span class=c1>// 返回屏幕的宽度
</span><span class=c1></span><span class=kt>int</span> <span class=nf>screen_width</span><span class=p>();</span>
<span class=c1>// 返回屏幕的高度
</span><span class=c1></span><span class=kt>int</span> <span class=nf>screen_height</span><span class=p>();</span>
</code></pre></div><h4 id=cppc>cpp.c</h4><p>(TODO)</p><h1 id=apps>apps/</h1><p>直接运行在AM上的应用。</p><h2 id=microbench>microbench/</h2><p>性能测试程序 3。microbench提供了两个不同规模的测试集test和ref. 其中ref测试集规模较大, 用于跑分测试, 默认会编译ref测试集; test测试集规模较小, 用于正确性测试, 需要在运行make时显式指定编译test测试集:</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh>make <span class=nv>INPUT</span><span class=o>=</span>TEST
</code></pre></div><h1 id=tests>tests/</h1><p>直接运行在AM上的测试。</p><p>使用测试方法：</p><ol><li>进入测试项目目录</li><li>使用 <code>make run</code> 运行测试<ul><li>可使用 <code>ARCH=native</code> 指定 AM</li></ul></li></ol><h2 id=cputest>cputest/</h2><p>包含一些测试 CPU 指令实现的测试。
使用 <code>make ALL=testname run</code> 指定测试。</p><h1 id=引用资料>引用资料</h1><ul><li><a class=link href=https://legacy.gitbook.com/book/nju-ics/ics2018-programming-assignment/details target=_blank rel=noopener>ICS2018 PA 讲义</a></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/nju/>NJU</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script></article><aside class=related-contents--wrapper><h2 class=section-title>Related contents</h2><div class=related-contents><div class="flex article-list--tile"><article><a href=/posts/learning/nju-icspa-analytics-navy-apps/><div class=article-details><h2 class=article-title>NJU ICS Programming Assignment 代码分析 - NAVY-APPS</h2></div></a></article><article><a href=/posts/learning/nju-icspa-analytics-nanos-lite/><div class=article-details><h2 class=article-title>NJU ICS Programming Assignment 代码分析 - NANOS-LITE</h2></div></a></article><article><a href=/posts/learning/nju-icspa-analytics-nemu/><div class=article-details><h2 class=article-title>NJU ICS Programming Assignment 代码分析 - NEMU</h2></div></a></article><article><a href=/posts/learning/cpp-template-seq/><div class=article-details><h2 class=article-title>C++ 模板实现编译期计算数列</h2></div></a></article><article><a href=/posts/learning/multimod-64bit-method/><div class=article-details><h2 class=article-title>64位有符号数乘法取模问题</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=StardustDL/stardustdl.github.io issue-term=pathname label=comment crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>function setUtterancesTheme(b){let a=document.querySelector('.utterances iframe');a&&a.contentWindow.postMessage({type:'set-theme',theme:`github-${b}`},'https://utteranc.es')}addEventListener('message',a=>{if(a.origin!=='https://utteranc.es')return;setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener('onColorSchemeChange',a=>{setUtterancesTheme(a.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2021 StardustDL's Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.4.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ul><li><a href=#框架代码结构>框架代码结构</a></li></ul><ul><li><a href=#特定-am-实现代码结构>特定 AM 实现代码结构</a></li><li><a href=#amh>am.h</a><ul><li><a href=#枚举>枚举</a></li><li><a href=#结构体>结构体</a></li><li><a href=#trm>TRM</a></li><li><a href=#ioe>IOE</a></li><li><a href=#cte>CTE</a></li><li><a href=#vme>VME</a></li><li><a href=#mpe>MPE</a></li></ul></li><li><a href=#amdevh>amdev.h</a></li><li><a href=#amtraceh>amtrace.h</a></li><li><a href=#x86-nemu>x86-nemu/</a><ul><li><a href=#x86-nemu-编译与运行流程>x86-NEMU 编译与运行流程</a></li><li><a href=#include>include/</a></li><li><a href=#src>src/</a></li></ul></li></ul><ul><li><a href=#klib>klib/</a><ul><li><a href=#includeklibh>include/klib.h</a></li><li><a href=#src-1>src/</a></li></ul></li></ul><ul><li><a href=#microbench>microbench/</a></li></ul><ul><li><a href=#cputest>cputest/</a></li></ul></nav></div></section></aside></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script></body></html>
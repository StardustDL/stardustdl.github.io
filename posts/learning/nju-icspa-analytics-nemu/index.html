<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="概述  框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言  由于 NJU ICS PA 框架代码较多且缺少足够说明，讲义多为基础引入内容，为方便后续程序编写，根据实际作业过程中的理解整理出此文。 本文主要包含对 NJU ICS 课程编程作业的框架代码中 NEMU 部分的理解和分析，跟随课程及讲义进度更新，以个人使用为主，可能存在错误。
 部分内容框架代码并不包含（如扩展的 Debug 宏），均为我为编码而添加的内容。采用 a_b 方式命名的多为原内容，采用 aB 方式命名的多为补充内容。由于此项目是 NJU ICS PA 的一部分，其中会包含与相关项目的互操作内容。
 NEMU (NJU EMUlator) 是在 Linux 上的一个 n86（x86 子集）模拟器，模拟了基本计算机系统的功能（内存，CPU等）。包含了：
 内存 CPU，寄存器 调试器（监视器）  框架代码结构 nanos-lite/ navy-apps/ nexus-am/ nemu/ # NEMU 项目 build/ # 构建输出文件夹 nemu # NEMU 主程序（可执行文件） include/ # 头文件 src/ # 源码文件 tools/ # 工具文件 runall."><title>NJU ICS Programming Assignment 代码分析 - NEMU</title><link rel=canonical href=https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nemu/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="NJU ICS Programming Assignment 代码分析 - NEMU"><meta property="og:description" content="概述  框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言  由于 NJU ICS PA 框架代码较多且缺少足够说明，讲义多为基础引入内容，为方便后续程序编写，根据实际作业过程中的理解整理出此文。 本文主要包含对 NJU ICS 课程编程作业的框架代码中 NEMU 部分的理解和分析，跟随课程及讲义进度更新，以个人使用为主，可能存在错误。
 部分内容框架代码并不包含（如扩展的 Debug 宏），均为我为编码而添加的内容。采用 a_b 方式命名的多为原内容，采用 aB 方式命名的多为补充内容。由于此项目是 NJU ICS PA 的一部分，其中会包含与相关项目的互操作内容。
 NEMU (NJU EMUlator) 是在 Linux 上的一个 n86（x86 子集）模拟器，模拟了基本计算机系统的功能（内存，CPU等）。包含了：
 内存 CPU，寄存器 调试器（监视器）  框架代码结构 nanos-lite/ navy-apps/ nexus-am/ nemu/ # NEMU 项目 build/ # 构建输出文件夹 nemu # NEMU 主程序（可执行文件） include/ # 头文件 src/ # 源码文件 tools/ # 工具文件 runall."><meta property="og:url" content="https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nemu/"><meta property="og:site_name" content="StardustDL's Blog"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:tag" content="NJU"><meta property="article:published_time" content="2018-10-05T19:30:22+08:00"><meta property="article:modified_time" content="2018-10-05T19:30:22+08:00"><meta name=twitter:title content="NJU ICS Programming Assignment 代码分析 - NEMU"><meta name=twitter:description content="概述  框架代码库 CPU 架构：x64 操作系统: GNU/Linux 编译器: GCC 编程语言：C 语言  由于 NJU ICS PA 框架代码较多且缺少足够说明，讲义多为基础引入内容，为方便后续程序编写，根据实际作业过程中的理解整理出此文。 本文主要包含对 NJU ICS 课程编程作业的框架代码中 NEMU 部分的理解和分析，跟随课程及讲义进度更新，以个人使用为主，可能存在错误。
 部分内容框架代码并不包含（如扩展的 Debug 宏），均为我为编码而添加的内容。采用 a_b 方式命名的多为原内容，采用 aB 方式命名的多为补充内容。由于此项目是 NJU ICS PA 的一部分，其中会包含与相关项目的互操作内容。
 NEMU (NJU EMUlator) 是在 Linux 上的一个 n86（x86 子集）模拟器，模拟了基本计算机系统的功能（内存，CPU等）。包含了：
 内存 CPU，寄存器 调试器（监视器）  框架代码结构 nanos-lite/ navy-apps/ nexus-am/ nemu/ # NEMU 项目 build/ # 构建输出文件夹 nemu # NEMU 主程序（可执行文件） include/ # 头文件 src/ # 源码文件 tools/ # 工具文件 runall."><link rel="shortcut icon" href=/favicon.png><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-111573521-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body class="article-page keep-sidebar"><script>(function(){const a='StackColorScheme';localStorage.getItem(a)||localStorage.setItem(a,"auto")})()</script><script>(function(){const b='StackColorScheme',a=localStorage.getItem(b),c=window.matchMedia('(prefers-color-scheme: dark)').matches===!0;a=='dark'||a==='auto'&&c?document.body.dataset.scheme='dark':document.body.dataset.scheme='light'})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/assets/images/avatar_hu55fbf1db337484ccbc1a7220a4594f60_220509_300x0_resize_box_2.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
<span class=emoji>🍥</span></figure><h1 class=site-name><a href=https://stardustdl.github.io/>StardustDL's Blog</a></h1><h2 class=site-description></h2></header><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>Home</span></a></li><li><a href=/about><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>About</span></a></li><li><a href=/archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>Archives</span></a></li><li><a href=/search><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg><span>Search</span></a></li><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg><span>Dark Mode</span></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/learning/>Learning</a></header><h2 class=article-title><a href=/posts/learning/nju-icspa-analytics-nemu/>NJU ICS Programming Assignment 代码分析 - NEMU</a></h2><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Oct 05, 2018</time></footer></div></header><section class=article-content><h1 id=概述>概述</h1><ul><li><a class=link href=https://github.com/NJU-ProjectN/nemu target=_blank rel=noopener>框架代码库</a></li><li>CPU 架构：x64</li><li>操作系统: GNU/Linux</li><li>编译器: GCC</li><li>编程语言：C 语言</li></ul><p>由于 NJU ICS PA 框架代码较多且缺少足够说明，讲义多为基础引入内容，为方便后续程序编写，根据实际作业过程中的理解整理出此文。
本文主要包含对 NJU ICS 课程编程作业的框架代码中 NEMU 部分的理解和分析，跟随课程及讲义进度更新，以个人使用为主，可能存在错误。</p><blockquote><p>部分内容框架代码并不包含（如扩展的 Debug 宏），均为我为编码而添加的内容。采用 <code>a_b</code> 方式命名的多为原内容，采用 <code>aB</code> 方式命名的多为补充内容。由于此项目是 NJU ICS PA 的一部分，其中会包含与相关项目的互操作内容。</p></blockquote><p>NEMU (NJU EMUlator) 是在 Linux 上的一个 n86（x86 子集）模拟器，模拟了基本计算机系统的功能（内存，CPU等）。包含了：</p><ul><li>内存</li><li>CPU，寄存器</li><li>调试器（监视器）</li></ul><h2 id=框架代码结构>框架代码结构</h2><pre><code>nanos-lite/
navy-apps/
nexus-am/
nemu/               # NEMU 项目
    build/          # 构建输出文件夹
        nemu        # NEMU 主程序（可执行文件）
    include/        # 头文件
    src/            # 源码文件
    tools/          # 工具文件
    runall.sh       # 测试 AM cputest 测试集 （nexus-am/tests/cputest）
    Makefile        # NEMU 构建命令
    Makefile.git    # NEMU Git 记录命令
</code></pre><h1 id=include>include/</h1><h2 id=nemuh>nemu.h</h2><p>基础头文件。包含了 <code>commom.h</code>，<code>memory/memory.h</code>，<code>cpu/reg.h</code></p><h2 id=macroh>macro.h</h2><p>定义了一些字符串连接宏 <code>concat</code> 等。</p><h2 id=commonh>common.h</h2><p>定义了一些类型别名。</p><table><thead><tr><th>类型别名</th><th>原类型</th><th>描述</th></tr></thead><tbody><tr><td><code>rtlreg_t</code></td><td><code>uint32_t</code></td><td>RTL寄存器</td></tr><tr><td><code>vaddr_t</code></td><td><code>uint32_t</code></td><td>虚拟地址</td></tr><tr><td><code>paddr_t</code></td><td><code>uint32_t</code></td><td>物理地址</td></tr><tr><td><code>ioaddr_t</code></td><td><code>uint16_t</code></td><td>I/O 端口地址</td></tr></tbody></table><ul><li><code>relreg_t</code> 多用于寄存器访问</li><li><code>vaddr_t</code> <code>paddr_t</code> 多用于内存访问</li><li><code>ioaddr_t</code> 多用于设备 I/O 端口访问</li></ul><p>定义了一些控制编译方式的宏。</p><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td><code>DEBUG</code></td><td>启用调试</td></tr><tr><td><code>DIFF_TEST</code></td><td>启用 diff-test</td></tr><tr><td><code>HAS_IOE</code></td><td>启用输入输出扩展</td></tr></tbody></table><ul><li><code>DIFF_TEST</code> 可启用一个差异测试工具，参见 <code>tools/qemu-diff</code> 部分。</li><li><code>HAS_IOE</code> 启用输入输出设备，参见设备部分。</li></ul><h2 id=debugh>debug.h</h2><p>定义了便于调试的宏。</p><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td><code>Log_write(format, ...)</code></td><td>仅记录日志</td></tr><tr><td><code>printflog(format, ...)</code></td><td>显示文本并记录日志</td></tr><tr><td><code>Log(format, ...)</code></td><td>对 <code>printflog</code> 的扩展，包含当前文件，行，函数</td></tr><tr><td><code>Info(format, ...)</code></td><td>对 <code>Log</code> 的扩展，日志级别：提示</td></tr><tr><td><code>Warning(format, ...)</code></td><td>对 <code>Log</code> 的扩展，日志级别：警告</td></tr><tr><td><code>Error(format, ...)</code></td><td>对 <code>Log</code> 的扩展，日志级别：错误</td></tr><tr><td><code>panic(format, ...)</code></td><td>强制退出，显示文本并记录日志</td></tr><tr><td><code>Assert(cond [, format, ...])</code></td><td>设置断言，失败时强制退出，显示文本并记录日志</td></tr><tr><td><code>TODO()</code></td><td>标识待完成项，执行时会触发 <code>panic</code></td></tr></tbody></table><h2 id=cpu>cpu/</h2><h3 id=regh>reg.h</h3><p>定义了寄存器结构，和辅助寄存器的一些宏和函数。</p><ul><li>外部数组 <code>regsl, regsw, regsb</code> 不同寄存器名。实现在 <code>src/cpu/reg.c</code></li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>extern</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>regsl</span><span class=p>[];</span>
<span class=k>extern</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>regsw</span><span class=p>[];</span>
<span class=k>extern</span> <span class=k>const</span> <span class=kt>char</span><span class=o>*</span> <span class=n>regsb</span><span class=p>[];</span>
</code></pre></div><h4 id=结构体-cpu_state>结构体 CPU_state</h4><p>寄存器结构，包含了所有寄存器，均为无符号整数。</p><ul><li>对于 8 个通用寄存器，内部以 <code>gpr</code> 数组为基础结构，提供 <code>eax</code> 等别名方便访问。寄存器按照 i386 指令中寄存器标号顺序排列。可使用 <code>_16,_8[0],_8[1]</code> 访问寄存器低位部分。</li><li><code>eip</code> 当前执行指令位置寄存器</li><li><code>eflags</code> 标志位寄存器（使用匿名结构体，可直接访问 <code>CF,OF,ZF,SF</code>）<ul><li><code>eflags</code> 初始化为 <code>0x2</code></li></ul></li><li><code>cs,ss,ds,es,fs,gs</code> 程序段寄存器（仅为支持 diff-test）<ul><li><code>cs</code> 初始化为 <code>8</code></li></ul></li><li><code>idtr</code> 48 位寄存器，存放 IDT (Interrupt Descriptor Table, 中断描述符表)的首地址和长度<ul><li><code>limit</code> 16位，长度，单位：字节</li><li><code>base</code> 32位，IDT 基地址</li></ul></li></ul><table><thead><tr><th>函数/宏</th><th>描述</th></tr></thead><tbody><tr><td><code>reg_l(index)</code></td><td>获取指定下标处寄存器32位值</td></tr><tr><td><code>reg_w(index)</code></td><td>获取指定下标处寄存器低16位值</td></tr><tr><td><code>reg_b(index)</code></td><td>获取指定下标处寄存器低8位值</td></tr><tr><td><code>reg_name(index,width)</code></td><td>根据下标和位宽获得寄存器名</td></tr></tbody></table><blockquote><p>寄存器存储在变量 <code>cpu</code> 中。</p></blockquote><h4 id=枚举>枚举</h4><p>定义了形如 <code>R_NAME</code> 的寄存器枚举，其顺序与寄存器结构中的顺序一致。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>enum</span> <span class=p>{</span> <span class=n>R_EAX</span><span class=p>,</span> <span class=n>R_ECX</span><span class=p>,</span> <span class=n>R_EDX</span><span class=p>,</span> <span class=n>R_EBX</span><span class=p>,</span> <span class=n>R_ESP</span><span class=p>,</span> <span class=n>R_EBP</span><span class=p>,</span> <span class=n>R_ESI</span><span class=p>,</span> <span class=n>R_EDI</span> <span class=p>};</span>
<span class=k>enum</span> <span class=p>{</span> <span class=n>R_AX</span><span class=p>,</span> <span class=n>R_CX</span><span class=p>,</span> <span class=n>R_DX</span><span class=p>,</span> <span class=n>R_BX</span><span class=p>,</span> <span class=n>R_SP</span><span class=p>,</span> <span class=n>R_BP</span><span class=p>,</span> <span class=n>R_SI</span><span class=p>,</span> <span class=n>R_DI</span> <span class=p>};</span>
<span class=k>enum</span> <span class=p>{</span> <span class=n>R_AL</span><span class=p>,</span> <span class=n>R_CL</span><span class=p>,</span> <span class=n>R_DL</span><span class=p>,</span> <span class=n>R_BL</span><span class=p>,</span> <span class=n>R_AH</span><span class=p>,</span> <span class=n>R_CH</span><span class=p>,</span> <span class=n>R_DH</span><span class=p>,</span> <span class=n>R_BH</span> <span class=p>};</span>
</code></pre></div><h3 id=decodeh>decode.h</h3><p>定义了用于指令译码的结构和函数。</p><h4 id=结构体-operand>结构体 Operand</h4><p>操作数。</p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td><code>type</code></td><td>类型（见下方枚举）</td></tr><tr><td><code>width</code></td><td>位宽</td></tr><tr><td><code>val</code></td><td>实际值</td></tr><tr><td><code>str</code></td><td>原串（用于调试输出）</td></tr><tr><td><code>reg</code></td><td>寄存器下标</td></tr><tr><td><code>addr</code></td><td>内存地址</td></tr><tr><td><code>imm</code></td><td>立即数</td></tr><tr><td><code>simm</code></td><td>带符号立即数</td></tr></tbody></table><h4 id=结构体-decodeinfo>结构体 DecodeInfo</h4><p>单条命令译码结果。</p><table><thead><tr><th>成员</th><th>描述</th><th>对应x86指令部分</th></tr></thead><tbody><tr><td><code>opcode</code></td><td>指令码</td><td>opcode</td></tr><tr><td><code>seq_eip</code></td><td>序列 EIP 位置</td><td></td></tr><tr><td><code>is_operand_size_16</code></td><td>标识操作数是否为 16 位</td><td>operand-size prefix</td></tr><tr><td><code>ext_opcode</code></td><td>额外指令码</td><td>ModR/M 中 opcode</td></tr><tr><td><code>is_jmp</code></td><td>标识是否为跳转语句</td><td></td></tr><tr><td><code>jmp_eip</code></td><td>跳转目标（绝对地址），仅对于跳转语句</td><td></td></tr><tr><td><code>src</code></td><td>源操作数</td><td></td></tr><tr><td><code>src2</code></td><td>第二个源操作数</td><td></td></tr><tr><td><code>dest</code></td><td>目标操作数</td><td></td></tr><tr><td><code>assembly</code></td><td></td><td></td></tr><tr><td><code>asm_buf</code></td><td></td><td></td></tr><tr><td><code>p</code></td><td></td><td></td></tr></tbody></table><ul><li><code>seq_eip</code> 随译码过程改变，最终停留在需要译码的下一个位置，可根据这一值实现 eip 更新。</li><li><code>is_operand_size_16</code> 多用于实现单命令存在 16 位，32 位两个版本的情况</li><li><code>ext_opcode</code> 用于实现 <code>sub /5</code> 这种根据第二个指令码 <code>/5</code> 区分不同指令的情况，在译码中使用 <code>make_group</code> 实现。</li><li><code>is_jmp</code> 多在运行时指定（如 <code>rtl_j</code> 函数），如果标记，则不会再根据 <code>seq_eip</code> 更新 eip</li></ul><table><thead><tr><th>函数/宏</th><th>描述</th></tr></thead><tbody><tr><td><code>id_src</code></td><td><code>(&decoding.src)</code></td></tr><tr><td><code>id_src2</code></td><td><code>(&decoding.src2)</code></td></tr><tr><td><code>id_dest</code></td><td><code>(&decoding.dest)</code></td></tr><tr><td><code>operand_write(Operand *, rtlreg_t *)</code></td><td>根据第一个参数中记录的类型的不同进行相应的写操作，包括写寄存器和写内存</td></tr><tr><td><code>load_addr(vaddr_t *, ModR_M *, Operand *)</code></td><td></td></tr><tr><td><code>read_ModR_M(vaddr_t *, Operand *, bool, Operand *, bool)</code></td><td></td></tr></tbody></table><blockquote><p>译码内容存储在变量 <code>decoding</code> 中。</p></blockquote><h4 id=结构体-modr_m>结构体 ModR_M</h4><p>指令中的 ModR/M。</p><h4 id=结构体-sib>结构体 SIB</h4><p>指令中的 SIB。</p><h4 id=枚举-1>枚举</h4><p>定义了操作数的类型 <code>OP_TYPE_REG</code>，<code>OP_TYPE_MEM</code>，<code>OP_TYPE_IMM</code>，分别为寄存器，内存，立即数。</p><h4 id=宏-make_dhelper-与函数族-decode_name>宏 make_DHelper 与函数族 decode_name</h4><p>由宏 <code>make_DHelper</code> 定义了一族函数（参数相同），用于指令译码，并定义了这些函数的指针类型 <code>DHelper</code>。</p><ul><li>设计目的：由于大量指令的操作数模式相似，将这一点提取出来，实现解耦。</li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define make_DHelper(name) void concat(decode_, name) (vaddr_t *eip)
</span><span class=cp></span><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=n>DHelper</span><span class=p>)</span> <span class=p>(</span><span class=n>vaddr_t</span> <span class=o>*</span><span class=p>);</span>
</code></pre></div><p>函数族中部分函数命名规则（<strong>不全</strong>）：</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code>I</code></td><td>立即数</td></tr><tr><td><code>SI</code></td><td>有符号立即数</td></tr><tr><td><code>E</code></td><td>内存或寄存器（对应指令描述中的 r/m）</td></tr><tr><td><code>G</code></td><td>通用寄存器</td></tr><tr><td><code>r</code></td><td>单一寄存器</td></tr><tr><td><code>a</code></td><td>指定寄存器为 <code>eax,ax,al</code></td></tr><tr><td><code>I2G</code></td><td>立即数到通用寄存器</td></tr><tr><td><code>I_E2G</code></td><td>立即数与内存或寄存器到通用寄存器</td></tr><tr><td><code>O</code></td><td>未知</td></tr></tbody></table><ul><li><code>r</code> 一般用于寄存器信息存储在 <code>opcode</code> 中的情况</li><li>还有一些专用于特定指令的译码函数</li></ul><blockquote><p>建议结合 i386 手册附录 C 理解。</p></blockquote><p>函数族中特殊函数：</p><ul><li><code>J</code> 跳转指令解码。单操作数，存储到 <code>jmp_eip</code> 中。</li></ul><h3 id=exech>exec.h</h3><p>定义了一些用于调试的指令打印宏：</p><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td><code>print_asm</code></td><td>打印指令</td></tr><tr><td><code>suffix_char</code></td><td>根据宽度获取指令宽度后缀</td></tr><tr><td><code>print_asm_template1</code></td><td>单操作数指令</td></tr><tr><td><code>print_asm_template2</code></td><td>双操作数指令</td></tr><tr><td><code>print_asm_template3</code></td><td>三操作数指令</td></tr></tbody></table><h4 id=函数-instr_fetch>函数 instr_fetch</h4><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>uint32_t</span> <span class=n>instr_fetch</span><span class=p>(</span><span class=n>vaddr_t</span> <span class=o>*</span><span class=n>eip</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>)</span>
</code></pre></div><p>从 <code>eip</code> 开始，读取 <code>len</code> 个字节，返回值，并自动增加 <code>eip</code>。</p><ul><li>设计目的：与机器的大端小端解耦。</li></ul><h4 id=宏-make_ehelper-与-函数族-exec_name>宏 make_EHelper 与 函数族 exec_name</h4><p>用于定义一族函数（参数相同），用于指令执行，并定义了这些函数的指针类型 <code>EHelper</code>。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define make_EHelper(name) void concat(exec_, name) (vaddr_t *eip)
</span><span class=cp></span><span class=k>typedef</span> <span class=nf>void</span> <span class=p>(</span><span class=o>*</span><span class=n>EHelper</span><span class=p>)</span> <span class=p>(</span><span class=n>vaddr_t</span> <span class=o>*</span><span class=p>);</span>
</code></pre></div><h3 id=reloph>relop.h</h3><p>定义了形如 <code>RELOP_NAME</code> 的枚举，标识不同类型的关系运算。对应了 <code>setcc,jcc</code> 命令的相应编码。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>enum</span> <span class=p>{</span>
  <span class=c1>//            +-- unsign
</span><span class=c1></span>  <span class=c1>//            |   +-- sign
</span><span class=c1></span>  <span class=c1>//            |   |   +-- equal
</span><span class=c1></span>  <span class=c1>//            |   |   |   +-- invert
</span><span class=c1></span>  <span class=c1>//            |   |   |   |
</span><span class=c1></span>  <span class=n>RELOP_FALSE</span> <span class=o>=</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>0</span><span class=p>,</span>
  <span class=n>RELOP_TRUE</span>  <span class=o>=</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>1</span><span class=p>,</span>
  <span class=n>RELOP_EQ</span>    <span class=o>=</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>2</span> <span class=o>|</span> <span class=mi>0</span><span class=p>,</span>
  <span class=n>RELOP_NE</span>    <span class=o>=</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>2</span> <span class=o>|</span> <span class=mi>1</span><span class=p>,</span>

  <span class=n>RELOP_LT</span>    <span class=o>=</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>4</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>0</span><span class=p>,</span>
  <span class=n>RELOP_LE</span>    <span class=o>=</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>4</span> <span class=o>|</span> <span class=mi>2</span> <span class=o>|</span> <span class=mi>0</span><span class=p>,</span>
  <span class=n>RELOP_GT</span>    <span class=o>=</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>4</span> <span class=o>|</span> <span class=mi>2</span> <span class=o>|</span> <span class=mi>1</span><span class=p>,</span>
  <span class=n>RELOP_GE</span>    <span class=o>=</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>4</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>1</span><span class=p>,</span>

  <span class=n>RELOP_LTU</span>   <span class=o>=</span> <span class=mi>8</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>0</span><span class=p>,</span>
  <span class=n>RELOP_LEU</span>   <span class=o>=</span> <span class=mi>8</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>2</span> <span class=o>|</span> <span class=mi>0</span><span class=p>,</span>
  <span class=n>RELOP_GTU</span>   <span class=o>=</span> <span class=mi>8</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>2</span> <span class=o>|</span> <span class=mi>1</span><span class=p>,</span>
  <span class=n>RELOP_GEU</span>   <span class=o>=</span> <span class=mi>8</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>0</span> <span class=o>|</span> <span class=mi>1</span><span class=p>,</span>
<span class=p>};</span>
</code></pre></div><h3 id=cch>cc.h</h3><p>定义了函数 <code>get_cc_name</code> 根据编码获取指定关系运算字符串。</p><p>定义了 RTL 基本指令 <code>rtl_setcc</code> 用于根据当前关系运算和 eflags 寄存器标志位设置 dest。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>rtl_setcc</span><span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span><span class=p>,</span> <span class=n>uint8_t</span><span class=p>);</span>
</code></pre></div><h3 id=rtlh>rtl.h</h3><p>定义和实现了一些 RTL 指令，用于提供对指令执行的底层建模。可使用这些操作将复杂指令分解成更简单的操作。</p><p>NEMU 中的 RTL 寄存器：</p><ul><li>x86的八个通用寄存器(在 <code>include/cpu/reg.h</code> 中定义)</li><li><code>id_src</code>, <code>id_src2</code> 和 <code>id_dest</code> 中的访存地址 <code>addr</code> 和操作数内容 <code>val</code> (在 <code>include/cpu/decode.h</code> 中定义). 从概念上看, 它们分别与MAR和 MDR有异曲同工之妙</li><li>临时寄存器 <code>t0~t3</code> 和 <code>at</code> (在 <code>src/cpu/decode/decode.c</code> 中定义)</li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>extern</span> <span class=n>rtlreg_t</span> <span class=n>t0</span><span class=p>,</span> <span class=n>t1</span><span class=p>,</span> <span class=n>t2</span><span class=p>,</span> <span class=n>t3</span><span class=p>,</span> <span class=n>at</span><span class=p>;</span>
</code></pre></div><ul><li>宏 <code>make_rtl_arith_logic</code> 根据算术运算符名创建对应 RTL 基本指令和 RTL 指令，使用了 <code>include/util/c_op.h</code> 中的运算。<ul><li>32位寄存器-寄存器类型的算术/逻辑运算</li><li>32位寄存器-立即数类型的算术/逻辑运算</li></ul></li><li>定义函数 <code>decoding_set_jmp(bool is_jmp)</code> ：将 当前指令标记为跳转（标记 <code>decoing.is_jmp</code>）</li><li>定义函数 <code>interpret_relop</code> ：实现两个值的关系运算，返回结果（实现在 <code>src/cpu/exec/relop.c</code></li></ul><h4 id=rtl-基本指令>RTL 基本指令</h4><p>特点：不需要使用临时寄存器, 可以看做是最基本的x86指令中的最基本的操作。
实现时添加了 <code>interpret_</code> 前缀，但在 <code>include/cpu/rtl-wrapper.h</code> 作用下，其它代码中使用到这些RTL基本指令时会自动添加 <code>interpret_</code> 前缀。</p><ul><li>立即数读入 <code>rtl_li</code></li><li>寄存器传输 <code>rtl_mv</code></li><li>32位寄存器-寄存器类型的算术/逻辑运算, 包括 <code>rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])</code> , 这些运算的定义用到 <code>include/util/c_op.h</code> 中的C语言运算</li><li>被除数为64位的除法运算 <code>rtl_i?div64_[q|r]</code></li><li>guest内存访问 <code>rtl_lm</code> 和 <code>rtl_sm</code></li><li>host内存访问 <code>rtl_host_lm</code> 和 <code>rtl_host_sm</code></li><li>关系运算 <code>rtl_setrelop</code>, 具体可参考 <code>src/cpu/exec/relop.c</code></li><li>跳转, 包括直接跳转 <code>rtl_j</code> , 间接跳转 <code>rtl_jr</code> 和条件跳转 <code>rtl_jrelop</code></li><li>终止程序 <code>rtl_exit</code></li></ul><p>具体声明：</p><ul><li>未标明则函数修饰符均为 <code>static inline</code>。</li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=c1>// 立即数读入
</span><span class=c1></span><span class=kt>void</span> <span class=nf>interpret_rtl_li</span><span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>,</span> <span class=n>uint32_t</span> <span class=n>imm</span><span class=p>);</span>

<span class=c1>// 寄存器传输
</span><span class=c1></span><span class=kt>void</span> <span class=nf>interpret_rtl_mv</span><span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span> <span class=o>*</span><span class=n>src1</span><span class=p>);</span>

<span class=c1>// 32位寄存器-寄存器类型的算术/逻辑运算
</span><span class=c1></span><span class=kt>void</span> <span class=nf>interpret_rtl_add</span> <span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src1</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src2</span><span class=p>);</span>

<span class=c1>// 被除数为64位的除法运算
</span><span class=c1></span><span class=kt>void</span> <span class=nf>interpret_rtl_div64_q</span><span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>,</span>
    <span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src1_hi</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src1_lo</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src2</span><span class=p>);</span>

<span class=c1>// guest内存访问
</span><span class=c1></span><span class=kt>void</span> <span class=nf>interpret_rtl_lm</span><span class=p>(</span><span class=n>rtlreg_t</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>addr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>interpret_rtl_sm</span><span class=p>(</span><span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>addr</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>

<span class=c1>// host内存访问
</span><span class=c1></span><span class=kt>void</span> <span class=nf>interpret_rtl_host_lm</span><span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>,</span> <span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>interpret_rtl_host_sm</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span> <span class=o>*</span><span class=n>src1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>

<span class=c1>// 关系运算
</span><span class=c1></span><span class=kt>void</span> <span class=nf>interpret_rtl_setrelop</span><span class=p>(</span><span class=n>uint32_t</span> <span class=n>relop</span><span class=p>,</span> <span class=n>rtlreg_t</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span> <span class=o>*</span><span class=n>src1</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span> <span class=o>*</span><span class=n>src2</span><span class=p>);</span>

<span class=c1>// 跳转
</span><span class=c1></span><span class=kt>void</span> <span class=nf>interpret_rtl_j</span><span class=p>(</span><span class=n>vaddr_t</span> <span class=n>target</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>interpret_rtl_jr</span><span class=p>(</span><span class=n>rtlreg_t</span> <span class=o>*</span><span class=n>target</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>interpret_rtl_jrelop</span><span class=p>(</span><span class=n>uint32_t</span> <span class=n>relop</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span> <span class=o>*</span><span class=n>src1</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span> <span class=o>*</span><span class=n>src2</span><span class=p>,</span> <span class=n>vaddr_t</span> <span class=n>target</span><span class=p>);</span>

<span class=c1>// 终止程序
</span><span class=c1></span><span class=kt>void</span> <span class=nf>interpret_rtl_exit</span><span class=p>(</span><span class=kt>int</span> <span class=n>state</span><span class=p>);</span>
</code></pre></div><h4 id=rtl-伪指令>RTL 伪指令</h4><p>通过RTL基本指令或者已经实现的RTL伪指令来实现。</p><ul><li>32位寄存器-立即数类型的算术/逻辑运算, 包括 <code>rtl_(add|sub|and|or|xor|shl|shr|sar|i?mul_[lo|hi]|i?div_[q|r])_i</code></li><li>通用寄存器访问 <code>rtl_lr</code> 和 <code>rtl_sr</code></li><li>EFLAGS标志位的读写 <code>rtl_set_(CF|OF|ZF|SF)</code> 和 <code>rtl_get_(CF|OF|ZF|SF)</code></li><li>其它常用功能, 如按位取反 <code>rtl_not</code> ，符号扩展 <code>rtl_sext</code> 等</li></ul><p>具体声明：</p><ul><li>未标明则函数修饰符均为 <code>static inline</code>。</li><li>宏 <code>make_rtl_setget_eflags</code> 声明了需要实现的 EFLAGS标志位的读写 指令<ul><li><code>rtl_set_name</code></li><li><code>rtl_get_name</code></li></ul></li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=c1>// 32位寄存器-立即数类型的算术/逻辑运算
</span><span class=c1></span><span class=kt>void</span> <span class=nf>rtl_addi</span> <span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>imm</span><span class=p>)</span>

<span class=c1>// 通用寄存器访问
</span><span class=c1></span><span class=kt>void</span> <span class=n>rtl_lr</span><span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>rtl_sr</span><span class=p>(</span><span class=kt>int</span> <span class=n>r</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>

<span class=c1>// EFLAGS标志位的读写
</span><span class=c1></span><span class=kt>void</span> <span class=nf>rtl_set_CF</span> <span class=p>(</span><span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>rtl_get_CF</span> <span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>rtl_set_OF</span> <span class=p>(</span><span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>rtl_get_OF</span> <span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>rtl_set_ZF</span> <span class=p>(</span><span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>rtl_get_ZF</span> <span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>rtl_set_SF</span> <span class=p>(</span><span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>rtl_get_SF</span> <span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>);</span>

<span class=c1>// 根据运算结构更新 ZF, SF 标志位
</span><span class=c1></span><span class=kt>void</span> <span class=nf>rtl_update_ZF</span><span class=p>(</span><span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>result</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>rtl_update_SF</span><span class=p>(</span><span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>result</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>
<span class=kt>void</span> <span class=nf>rtl_update_ZFSF</span><span class=p>(</span><span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>result</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>

<span class=c1>// 按位取反
</span><span class=c1></span><span class=kt>void</span> <span class=nf>rtl_not</span><span class=p>(</span><span class=n>rtlreg_t</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src1</span><span class=p>);</span>

<span class=c1>// 符号扩展
</span><span class=c1></span><span class=kt>void</span> <span class=nf>rtl_sext</span><span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>

<span class=c1>// 压栈
</span><span class=c1></span><span class=kt>void</span> <span class=nf>rtl_push</span><span class=p>(</span><span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src1</span><span class=p>);</span>

<span class=c1>// 弹栈
</span><span class=c1></span><span class=kt>void</span> <span class=nf>rtl_pop</span><span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>);</span>

<span class=c1>// 32位寄存器-立即数类型 关系运算
</span><span class=c1></span><span class=kt>void</span> <span class=nf>rtl_setrelopi</span><span class=p>(</span><span class=n>uint32_t</span> <span class=n>relop</span><span class=p>,</span> <span class=n>rtlreg_t</span> <span class=o>*</span><span class=n>dest</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span> <span class=o>*</span><span class=n>src1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>imm</span><span class=p>);</span>

<span class=c1>// 取符号位（最高位）
</span><span class=c1></span><span class=kt>void</span> <span class=nf>rtl_msb</span><span class=p>(</span><span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>dest</span><span class=p>,</span> <span class=k>const</span> <span class=n>rtlreg_t</span><span class=o>*</span> <span class=n>src1</span><span class=p>,</span> <span class=kt>int</span> <span class=n>width</span><span class=p>);</span>
</code></pre></div><p>我们定义RTL基本指令的时候, 约定了RTL基本指令不需要使用RTL临时寄存器. 但某些RTL伪指令需要使用临时寄存器存放中间结果, 才能实现其完整功能. 这样可能会带来寄存器覆盖的问题, 例如如下RTL指令序列:</p><pre><code>(1) rtl_mv(&amp;t0, &amp;t1);
(2) rtl_sext(&amp;t1, &amp;t2, 1);  // use t0 temporarily
(3) rtl_add(&amp;t2, &amp;t0, &amp;t1);
</code></pre><p>如果实现(2)的时候恰好使用到了t0作为临时寄存器, 在(3)中使用的t0就不再是(1)的结果了, 从而产生非预期的结果.</p><p>为了尽可能避免上述问题, 我们有两条约定:</p><ul><li>实现RTL伪指令的时候, 尽可能不使用 <code>dest</code> 之外的寄存器存放中间结果. 由于 <code>dest</code> 最后会被写入新值, 其旧值肯定要被覆盖, 自然也可以安全地作为RTL伪指令的临时寄存器.</li><li>实在需要使用临时寄存器的时候, 使用 <code>at</code> . <code>at</code> 全称是assembly temporary, 是MIPS ABI中定义的一个特殊寄存器: 编译器并不会使用它, 它可以在编写汇编代码的时候安全地作为可使用的临时寄存器. 在这里， 我们借鉴它的功能来作如下约定: 不要在RTL伪指令的内部实现之外使用 <code>at</code> . 这样， <code>at</code> 就可以安全地作为RTL伪指令的临时寄存器了.</li></ul><h3 id=rtl-wrapperh>rtl-wrapper.h</h3><p>为 rtl.h 中定义的 RTL 基本指令的调用省去 <code>interpret_</code> 前缀。</p><h2 id=memory>memory/</h2><h3 id=memoryh>memory.h</h3><p>定义了访问内存的函数。使用数组 <code>pmem</code> 模拟内存。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>extern</span> <span class=n>uint8_t</span> <span class=n>pmem</span><span class=p>[];</span>
</code></pre></div><table><thead><tr><th>函数/宏</th><th>描述</th></tr></thead><tbody><tr><td><code>uint32_t vaddr_read(vaddr_t, int)</code></td><td>从虚拟内存指定位置读取指定数目个字节</td></tr><tr><td><code>void vaddr_write(vaddr_t, uint32_t, int)</code></td><td>向虚拟内存指定位置写入指定数目个字节</td></tr><tr><td><code>uint32_t paddr_read(paddr_t, int)</code></td><td>从物理内存指定位置读取指定数目个字节</td></tr><tr><td><code>void paddr_write(paddr_t, uint32_t, int)</code></td><td>向物理内存指定位置写入指定数目个字节</td></tr><tr><td><code>guest_to_host(p)</code></td><td><code>((void *)(pmem + (unsigned)p))</code></td></tr><tr><td><code>host_to_guest(p)</code></td><td><code>((paddr_t)((void *)p - (void *)pmem))</code></td></tr></tbody></table><h3 id=mmuh>mmu.h</h3><p>(TODO)</p><h4 id=结构体-gatedesc>结构体 GateDesc</h4><p>指示中断操作的门描述符(Gate Descriptor)类型。门描述符是一个8字节的结构体, 里面包含着不少细节的信息, 在NEMU中简化了门描述符的结构, 只保留存在位P和偏移量OFFSET。</p><pre><code>   31                23                15                7                0
  +-----------------+-----------------+---+-------------------------------+
  |           OFFSET 31..16           | P |          Don't care           |4
  +-----------------------------------+---+-------------------------------+
  |             Don't care            |           OFFSET 15..0            |0
  +-----------------+-----------------+-----------------+-----------------+
</code></pre><p>在 <code>raise_intr</code>（定义在 <code>intr.c</code> 中）中使用。</p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td><code>offset_15_0</code></td><td>Offset 低位部分</td></tr><tr><td><code>offset_31_16</code></td><td>Offset 高位部分</td></tr><tr><td><code>present</code></td><td>标识是否有效</td></tr></tbody></table><ul><li>为方便从内存中读取，使用 union 结构以及 <code>val0 val1</code> 域简化读写。</li><li>此结构体与 AM 中定义的 <code>GateDesc</code> （在 <code>arch/x86-nemu/include/x86.h</code> 中）结构相同。</li></ul><h2 id=device>device/</h2><h3 id=mmioh>mmio.h</h3><p>对内存映射 I/O 编址方式的支持。注意，内存映射 I/O 的读写并不是面向 CPU 的。</p><blockquote><p>端口映射I/O把端口号作为I/O指令的一部分, 这种方法很简单, 但同时也是它最大的缺点. 指令集为了兼容已经开发的程序, 是只能添加但不能修改的. 这意味着, 端口映射I/O所能访问的I/O地址空间的大小, 在设计I/O指令的那一刻就已经决定下来了. 所谓I/O地址空间, 其实就是所有能访问的设备的地址的集合. 随着设备越来越多, 功能也越来越复杂, I/O地址空间有限的端口映射I/O已经逐渐不能满足需求了. 有的设备需要让CPU访问一段较大的连续存储空间, 如VGA的显存, 24色加上Alpha通道的1024x768分辨率的显存就需要3MB的编址范围. 于是内存映射I/O(memory-mapped I/O)应运而生.
内存映射I/O这种编址方式非常巧妙, 它是通过不同的物理内存地址给设备编址的. 这种编址方式将一部分物理内存"重定向"到I/O地址空间中, CPU尝试访问这部分物理内存的时候, 实际上最终是访问了相应的I/O设备, CPU却浑然不知. 这样以后, CPU就可以通过普通的访存指令来访问设备. 这也是内存映射I/O得天独厚的好处: 物理内存的地址空间和CPU的位宽都会不断增长, 内存映射I/O从来不需要担心I/O地址空间耗尽的问题. 从原理上来说, 内存映射I/O唯一的缺点就是, CPU无法通过正常渠道直接访问那些被映射到I/O地址空间的物理内存了. 但随着计算机的发展, 内存映射I/O的唯一缺点已经越来越不明显了: 现代计算机都已经是64位计算机, 物理地址线都有48根, 这意味着物理地址空间有256TB这么大, 从里面划出3MB的地址空间给显存, 根本就是不痛不痒. 正因为如此, 内存映射I/O成为了现代计算机主流的I/O编址方式: RISC架构只提供内存映射I/O的编址方式, 而PCI-e, 网卡, x86的APIC等主流设备, 都支持通过内存映射I/O来访问.</p></blockquote><blockquote><p>在 NEMU 中， video memory是唯一使用内存映射 I/O 方式访问的 I/O 空间。</p></blockquote><p>定义了类型 <code>mmio_callback_t</code> ，设备定义的回调函数，用以更新设备状态。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=nf>void</span><span class=p>(</span><span class=o>*</span><span class=n>mmio_callback_t</span><span class=p>)(</span><span class=n>paddr_t</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>bool</span><span class=p>);</span>
</code></pre></div><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>void* add_mmio_map(paddr_t, int, mmio_callback_t)</code></td><td>注册一个内存映射 I/O 映射关系，返回该映射关系的 I/O 空间首地址</td></tr><tr><td><code>int is_mmio(paddr_t)</code></td><td>判断一个物理地址是否被映射到 I/O 空间，如果是，返回映射号, 否则返回 -1</td></tr><tr><td><code>uint32_t mmio_read(paddr_t, int, int)</code></td><td>根据端口号和地址读取</td></tr><tr><td><code>void mmio_write(paddr_t, int, uint32_t, int)</code></td><td>根据端口号和地址写入</td></tr></tbody></table><h3 id=port-ioh>port-io.h</h3><p>对端口映射 I/O 编址方式的支持。端口映射I/O(port-mapped I/O)， CPU使用专门的I/O指令对设备进行访问， 并把设备的地址称作端口号。 有了端口号以后， 在I/O指令中给出端口号， 就知道要访问哪一个设备寄存器了。</p><p>定义了类型 <code>pio_callback_t</code> ，设备定义的回调函数，用以更新设备状态。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>typedef</span> <span class=nf>void</span><span class=p>(</span><span class=o>*</span><span class=n>pio_callback_t</span><span class=p>)(</span><span class=n>ioaddr_t</span><span class=p>,</span> <span class=kt>int</span><span class=p>,</span> <span class=kt>bool</span><span class=p>);</span>
</code></pre></div><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>void* add_pio_map(paddr_t, int, mmio_callback_t)</code></td><td>注册一个端口映射 I/O 映射关系，返回该映射关系的 I/O 空间首地址</td></tr><tr><td><code>uint32_t pio_read_[l,w,b](ioaddr_t)</code></td><td>面向 CPU 的端口 I/O 读接口</td></tr><tr><td><code>void pio_write_[l,w,b](ioaddr_t, uint32_t)</code></td><td>面向 CPU 的端口 I/O 写接口</td></tr></tbody></table><h2 id=monitor>monitor/</h2><p>监视器部分（也包含 NEMU 执行主循环）。</p><h3 id=exprh>expr.h</h3><p>定义了计算表达式的值的函数 <code>expr</code>。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>uint32_t</span> <span class=nf>expr</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=p>,</span> <span class=kt>bool</span> <span class=o>*</span><span class=p>);</span>
</code></pre></div><h3 id=monitorh>monitor.h</h3><p>定义了 NEMU 状态 变量 <code>nemu_state</code>，和枚举值 <code>NEMU_STOP, NEMU_RUNNING, NEMU_END, NEMU_ABORT</code>。
定义了 应用程序入口点 <code>ENTRY_START</code> ：</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define ENTRY_START 0x100000
</span></code></pre></div><h3 id=watchpointh>watchpoint.h</h3><h4 id=结构体-wp>结构体 WP</h4><p>监视点结构。采用链表结构存储。</p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td><code>NO</code></td><td>序号</td></tr><tr><td><code>next</code></td><td>下一监视点指针</td></tr><tr><td><code>expr</code></td><td>监视的表达式</td></tr><tr><td><code>lastVal</code></td><td>表达式最近一次的值</td></tr></tbody></table><h2 id=util>util/</h2><h3 id=c_oph>c_op.h</h3><p>定义了一些形如 <code>c_opname_type</code> 的宏，用于表示基础 C 运算。在 RTL基本指令中的寄存器运算指令中使用。</p><h1 id=src>src/</h1><h2 id=mainc>main.c</h2><p>NEMU 主程序。</p><p>调用 <code>init_monitor</code> （实现在 <code>/src/monitor/monitor.c</code>）初始化监视器，并获取当前是否为批处理模式。
调用 <code>ui_mainloop</code> （实现在 <code>/src/monitor/debug/ui.c</code>）进行指令执行模拟。</p><h2 id=cpu-1>cpu/</h2><h3 id=regc>reg.c</h3><p>实现了 <code>include/cpu/reg.h</code> 中的 <code>regsl,regsw,regsb</code>，同时实现寄存器实际定义：变量 <code>cpu</code>。</p><ul><li>函数 <code>reg_test</code>：测试寄存器结构定义（<code>CPU_state</code>）是否正确。</li></ul><h3 id=intrc>intr.c</h3><p>函数 <code>void raise_intr(uint8_t NO, vaddr_t ret_addr)</code> 为 <code>int</code> 指令（在 <code>system.c</code> 中实现）的内部实现。
实现了触发中断或异常后的硬件处理：</p><ol><li>依次将EFLAGS, CS(代码段寄存器), EIP寄存器（返回地址）的值压入堆栈</li><li>根据中断码，从IDTR中读出IDT的首地址</li><li>根据异常号在IDT中进行索引, 找到一个门描述符</li><li>将门描述符中的offset域组合成目标地址</li><li>跳转到目标地址</li></ol><h3 id=decode>decode/</h3><p>指令译码相关。</p><h4 id=decodec>decode.c</h4><p>实现了 <code>include/cpu/decode.h</code> 中的译码函数族，函数 <code>operand_write</code> 以及译码信息变量 <code>decoding</code>。
实现了 <code>include/cpu/rtl.h</code> 中的临时寄存器 <code>t0,t1,t2,t3,at</code> 和函数 <code>decoding_set_jmp</code>。</p><h5 id=宏-make_dophelper-与函数族-decode_op_name>宏 make_DopHelper 与函数族 decode_op_name</h5><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define make_DopHelper(name) void concat(decode_op_, name) (vaddr_t *eip, Operand *op, bool load_val)
</span></code></pre></div><p>译码函数会进一步分解成各种不同操作数的译码的组合，以实现操作数译码的解耦. 操作数译码函数统一通过宏 <code>make_DopHelper</code> 来定义 （<code>decode_op_rm</code> 除外）。
操作数译码函数会把操作数的信息记录在结构体 <code>op</code> 中, 如果操作数在指令中， 就会通过 <code>instr_fetch()</code> 将它们从 <code>eip</code> 所指向的内存位置取出. 为了使操作数译码函数更易于复用， 函数中的 <code>load_val</code> 参数会控制 是否需要将该操作数读出到全局译码信息 <code>decoding</code> 供后续使用. 例如如果一个内存操作数是源操作数, 就需要将这个操作数从内存中读出来供后续执行阶段来使用； 如果它仅仅是一个目的操作数， 就不需要从内存读出它的值了，因为执行这条指令并不需要这个值， 而是将新数据写入相应的内存位置.</p><p><code>decode_op_name</code> 函数族命名规则可参见 <code>decode_name</code> 函数族命名规则。</p><ul><li><code>decode_op_a</code> 是一个特例，其用于将操作数标记为寄存器 <code>ax</code> 或 <code>eax</code></li></ul><h4 id=modrmc>modrm.c</h4><p>实现了 <code>include/cpu/decode.h</code> 中的函数 <code>load_addr</code> 和 <code>read_ModR_M</code>。</p><h3 id=exec>exec/</h3><p>指令执行相关。</p><h4 id=ccc>cc.c</h4><p>实现了 <code>include/cpu/cc.h</code> 中的函数 <code>rtl_setcc</code>。根据指定关系运算以及条件标志位设置 dest。</p><h4 id=relopc>relop.c</h4><p>实现了 <code>include/cpu/relop.h</code> 中的函数 <code>interpret_relop</code>，使用 C语言关系运算符实现关系运算。</p><h4 id=all-instrh>all-instr.h</h4><p>定义了已经实现的指令执行函数（在 <code>exec.c</code> 中使用）。</p><h4 id=arithc>arith.c</h4><p>算术运算指令执行函数实现。</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>add</code></td><td></td></tr><tr><td><code>sub</code></td><td></td></tr><tr><td><code>cmp</code></td><td></td></tr><tr><td><code>inc</code></td><td></td></tr><tr><td><code>dec</code></td><td></td></tr><tr><td><code>neg</code></td><td></td></tr><tr><td><code>adc</code></td><td></td></tr><tr><td><code>sbb</code></td><td></td></tr><tr><td><code>mul</code></td><td></td></tr><tr><td><code>imul1</code></td><td>imul 单操作数</td></tr><tr><td><code>imul2</code></td><td>imul 双操作数</td></tr><tr><td><code>imul3</code></td><td>imul 三操作数</td></tr><tr><td><code>div</code></td><td></td></tr><tr><td><code>idiv</code></td><td></td></tr></tbody></table><h4 id=controlc>control.c</h4><p>控制指令执行函数实现。</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>jmp</code></td><td>直接跳转</td></tr><tr><td><code>jmp_rm</code></td><td>间接跳转</td></tr><tr><td><code>jcc</code></td><td>条件跳转</td></tr><tr><td><code>call</code></td><td>直接调用</td></tr><tr><td><code>call_rm</code></td><td>间接调用</td></tr><tr><td><code>ret</code></td><td></td></tr></tbody></table><h4 id=data-movc>data-mov.c</h4><p>数据移动指令执行函数实现。</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>mov</code></td><td></td></tr><tr><td><code>movsx</code></td><td></td></tr><tr><td><code>movzx</code></td><td></td></tr><tr><td><code>lea</code></td><td></td></tr><tr><td><code>push</code></td><td></td></tr><tr><td><code>pop</code></td><td></td></tr><tr><td><code>pusha</code></td><td></td></tr><tr><td><code>popa</code></td><td></td></tr><tr><td><code>leave</code></td><td></td></tr><tr><td><code>cltd</code></td><td></td></tr><tr><td><code>cwtl</code></td><td></td></tr></tbody></table><h4 id=logicc>logic.c</h4><p>逻辑运算指令执行函数实现。</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>test</code></td><td></td></tr><tr><td><code>and</code></td><td></td></tr><tr><td><code>xor</code></td><td></td></tr><tr><td><code>or</code></td><td></td></tr><tr><td><code>sar</code></td><td></td></tr><tr><td><code>shl</code></td><td></td></tr><tr><td><code>shr</code></td><td></td></tr><tr><td><code>setcc</code></td><td></td></tr><tr><td><code>not</code></td><td></td></tr><tr><td><code>rol</code></td><td></td></tr><tr><td><code>ror</code></td><td></td></tr></tbody></table><h4 id=specialc>special.c</h4><p>特殊指令执行函数实现。</p><p>实现了 <code>include/cpu/rtl.h</code> 中的函数 <code>interpret_rtl_exit</code>。</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>nop</code></td><td></td></tr><tr><td><code>inv</code></td><td>非法指令</td></tr><tr><td><code>nemu_trap</code></td><td>结束执行</td></tr></tbody></table><h4 id=prefixc>prefix.c</h4><p>定义了执行函数 <code>exec_real</code>。
定义并实现了执行函数 <code>exec_operand_size</code>。</p><ul><li><code>exec_operand_size</code> 以 16 位操作数执行指令（标记 <code>decoding.is_operand_size_16</code>）</li></ul><h4 id=systemc>system.c</h4><p>系统相关指令实现。</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td><code>lidt</code></td><td>设置 IDTR 寄存器</td></tr><tr><td><code>mov_r2cr</code></td><td></td></tr><tr><td><code>mov_cr2r</code></td><td></td></tr><tr><td><code>int</code></td><td>根据中断码进行中断跳转</td></tr><tr><td><code>iret</code></td><td>从中断跳转返回</td></tr><tr><td><code>in</code></td><td>读取端口映射 I/O</td></tr><tr><td><code>out</code></td><td>写入端口映射 I/O</td></tr></tbody></table><ul><li>x86 提供了 in 和 out 指令用于访问设备，其中 in 指令用于将设备寄存器中的数据传输到 CPU 寄存器中，out 指令用于将 CPU 寄存器中的数据传送到设备寄存器中</li></ul><h4 id=execc>exec.c</h4><p>指令执行过程核心实现。</p><h5 id=结构体-opcode_entry>结构体 opcode_entry</h5><p>译码查找表中元素。</p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td><code>DHelper decode</code></td><td>译码函数指针</td></tr><tr><td><code>EHelper execute</code></td><td>执行函数指针</td></tr><tr><td><code>width</code></td><td>指令宽度</td></tr></tbody></table><h5 id=数组-opcode_table>数组 opcode_table</h5><p>译码表。按指令第一个字节索引存放。分两段：单字节指令码和双字节指令码。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>opcode_entry</span> <span class=n>opcode_table</span> <span class=p>[</span><span class=mi>512</span><span class=p>]</span> <span class=o>=</span> <span class=p>{</span>
  <span class=cm>/* 0x00 */</span>	<span class=n>EMPTY</span><span class=p>,</span> <span class=n>EMPTY</span><span class=p>,</span> <span class=n>EMPTY</span><span class=p>,</span> <span class=n>EMPTY</span><span class=p>,</span>
  <span class=cm>/* 0x04 */</span>	<span class=n>EMPTY</span><span class=p>,</span> <span class=n>EMPTY</span><span class=p>,</span> <span class=n>EMPTY</span><span class=p>,</span> <span class=n>EMPTY</span><span class=p>,</span>
  <span class=cm>/* 0x08 */</span>	<span class=n>EMPTY</span><span class=p>,</span> <span class=n>EMPTY</span><span class=p>,</span> <span class=n>EMPTY</span><span class=p>,</span> <span class=n>EMPTY</span><span class=p>,</span>
  <span class=p>...</span>
<span class=p>};</span>
</code></pre></div><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td><code>IDEXW(id, ex, w)</code></td><td>根据译码函数名，执行函数名，宽度生成 <code>opcode_entry</code></td></tr><tr><td><code>IDEX(id, ex)</code></td><td>根据译码函数名，执行函数名，以宽度 0 生成 <code>opcode_entry</code></td></tr><tr><td><code>EXW(ex, w)</code></td><td>根据执行函数名，宽度，生成无译码函数的 <code>opcode_entry</code></td></tr><tr><td><code>EX(ex)</code></td><td>根据执行函数名，生成宽度为 0 且无译码函数的 <code>opcode_entry</code></td></tr><tr><td><code>EMPTY</code></td><td>未实现的命令，使用 <code>exec_inv</code>（定义在 <code>special.c</code> 中） 构造 <code>opcode_entry</code></td></tr><tr><td><code>make_group(name, item0, item1, item2, item3, item4, item5, item6, item7)</code></td><td>用于实现 <code>sub /5</code> 这种根据第二个指令码 <code>/5</code> 区分不同指令的情况。会自动生成一个 <code>exec_name</code> 的统一执行函数，并根据 <code>decoding.ext_opcode</code> 分配到指定执行函数。</td></tr></tbody></table><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define IDEXW(id, ex, w)   {concat(decode_, id), concat(exec_, ex), w}
</span><span class=cp>#define IDEX(id, ex)       IDEXW(id, ex, 0)
</span><span class=cp>#define EXW(ex, w)         {NULL, concat(exec_, ex), w}
</span><span class=cp>#define EX(ex)             EXW(ex, 0)
</span><span class=cp>#define EMPTY              EX(inv)
</span><span class=cp></span>
<span class=cp>#define make_group(name, item0, item1, item2, item3, item4, item5, item6, item7) \
</span><span class=cp>  static opcode_entry concat(opcode_table_, name) [8] = { \
</span><span class=cp>    </span><span class=cm>/* 0x00 */</span><span class=cp>	item0, item1, item2, item3, \
</span><span class=cp>    </span><span class=cm>/* 0x04 */</span><span class=cp>	item4, item5, item6, item7  \
</span><span class=cp>  }; \
</span><span class=cp>static make_EHelper(name) { \
</span><span class=cp>  idex(eip, &amp;concat(opcode_table_, name)[decoding.ext_opcode]); \
</span><span class=cp>}
</span></code></pre></div><p>使用 <code>make_group</code> 宏定义了一些组 <code>gp1</code> - <code>gp7</code>。对应于 80386 手册附录中组的划分。</p><h5 id=函数-exec_wrapper>函数 exec_wrapper</h5><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>exec_wrapper</span><span class=p>(</span><span class=kt>bool</span> <span class=n>print_flag</span><span class=p>);</span>
</code></pre></div><p>执行下一条指令。</p><ul><li>首先将当前的 <code>%eip</code> 保存到全局译码信息 <code>decoding</code> 的成员 <code>seq_eip</code> 中</li><li>然后将其地址被作为参数送进 <code>exec_real()</code> 函数中<ul><li><code>seq</code> 代表顺序的意思, 当代码从 <code>exec_real()</code> 返回时，<code>decoding.seq_eip</code> 将会指向下一条指令的地址.</li></ul></li><li>调用 <code>update_eip</code> 更新 <code>%eip</code></li><li>调试模式下<ul><li>记录日志（指令内容以及相关信息）</li><li>若 <code>print_flag</code> 为真，则显示 <code>decoding.asm_buf</code></li></ul></li></ul><h5 id=函数-exec_real>函数 exec_real</h5><ul><li>首先通过 <code>instr_fetch()</code> 函数(在 <code>include/cpu/exec.h</code> 中定义)进行取指， 得到指令的第一个字节, 将其解释成 <code>opcode</code> 并记录在全局译码信息 <code>decoding</code> 中.</li><li>根据 <code>opcode</code> 查阅译码查找表，得到操作数的宽度信息，并通过调用 <code>set_width()</code> 函数将其记录在全局译码信息 <code>decoding</code> 中</li><li>调用 <code>idex()</code> 对指令进行进一步的译码和执行</li></ul><h5 id=函数-set_width>函数 set_width</h5><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>set_width</span><span class=p>(</span><span class=kt>int</span> <span class=n>width</span><span class=p>);</span>
</code></pre></div><p>根据指令定义宽度（<code>opcode_entry.width</code>）指定所有操作数宽度（<code>decoding.src.width</code>）。</p><ul><li>如果定义宽度为 0，则采用译码结果（<code>decoding.is_operand_size_16</code>）</li></ul><h5 id=函数-idex>函数 idex</h5><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cm>/* Instruction Decode and EXecute */</span>
<span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>idex</span><span class=p>(</span><span class=n>vaddr_t</span> <span class=o>*</span><span class=n>eip</span><span class=p>,</span> <span class=n>opcode_entry</span> <span class=o>*</span><span class=n>e</span><span class=p>);</span>
</code></pre></div><p>调用译码查找表中的相应的译码函数（若存在）进行操作数的译码，译码过程结束之后, 会调用译码查找表中的相应的执行函数来进行真正的执行操作。</p><h5 id=函数-update_eip>函数 update_eip</h5><p>根据当前指令是否为跳转指令，更新 <code>%eip</code>。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kr>inline</span> <span class=kt>void</span> <span class=nf>update_eip</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>decoding</span><span class=p>.</span><span class=n>is_jmp</span><span class=p>)</span> <span class=p>{</span> <span class=n>decoding</span><span class=p>.</span><span class=n>is_jmp</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=p>}</span>
    <span class=k>else</span> <span class=p>{</span> <span class=n>cpu</span><span class=p>.</span><span class=n>eip</span> <span class=o>=</span> <span class=n>decoding</span><span class=p>.</span><span class=n>seq_eip</span><span class=p>;</span> <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><h2 id=memory-1>memory/</h2><h3 id=memoryc>memory.c</h3><p>定义了宏 <code>PMEM_SIZE</code> 指定物理内存大小。
实现了 <code>include/memory/memory.h</code> 中的函数 <code>paddr_read</code>，<code>paddr_write</code>，<code>vaddr_read</code>，<code>vaddr_write</code>。</p><ul><li><code>vaddr_read, vaddr_write</code> 的实现调用了 <code>paddr_read</code> 和 <code>paddr_write</code>。</li><li>为支持内存映射 I/O，<code>paddr_read, paddr_write</code> 的实现加入了对内存映射 I/O 的判断。</li></ul><h2 id=device-1>device/</h2><h3 id=io>io/</h3><h4 id=mmioc>mmio.c</h4><p>定义了宏 <code>MMIO_SPACE_MAX</code> 指定内存映射空间大小。
定义了结构体 <code>MMIO_t</code> 保存 MMIO 信息。</p><p>实现了 <code>include/device/mmio.h</code> 中的函数。</p><ul><li>在 <code>mmio_read</code> 和 <code>mmio_write</code> 中，调用了回调函数。</li></ul><h4 id=port-ioc>port-io.c</h4><p>定义了宏 <code>PORT_IO_SPACE_MAX</code> 指定内存映射空间大小。
定义了结构体 <code>PIO_t</code> 保存 MMIO 信息。</p><p>实现了 <code>include/device/port-io.h</code> 中的函数。</p><ul><li>在 <code>pio_read_common</code> 和 <code>pio_write_common</code> 中，调用了回调函数。</li><li>基于 <code>pio_read_common</code> 和 <code>pio_write_common</code> 实现了不同的端口读写函数</li></ul><h3 id=devicec>device.c</h3><p>提供初始化和控制设备的一些函数。含有和SDL库相关的代码，NEMU使用SDL库来实现设备的模拟。</p><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td><code>TIMER_HZ</code></td><td>时钟频率</td></tr><tr><td><code>VGA_HZ</code></td><td>VGA 刷新频率</td></tr></tbody></table><h4 id=函数-init_device>函数 init_device</h4><p>用于初始化设备：串口， 时钟， 键盘， VGA四种设备。
其中在初始化 VGA 时还会进行一些和SDL相关的初始化工作， 包括创建窗口， 设置显示模式等. 最后还会注册一个100Hz的定时器， 每隔0.01秒就会调用一次 <code>device_update()</code> 函数。</p><h4 id=函数-device_update>函数 device_update</h4><p>主要进行一些设备的模拟操作, 包括以50Hz的频率刷新屏幕, 以及检测是否有按键按下/释放.</p><p>需要说明的是， 代码中注册的定时器是虚拟定时器， 它只会在 NEMU 处于用户态的时候进行计时： 如果 NEMU 在 <code>ui_mainloop()</code> 中等待用户输入， 定时器将不会计时; 如果 NEMU 进行大量的输出， 定时器的计时将会变得缓慢. 因此除非你在进行调试， 否则尽量避免大量输出的情况， 从而影响定时器的工作。</p><h3 id=serialc>serial.c</h3><p>串口设备。
模拟了串口的功能。 其大部分功能也被简化，只保留了数据寄存器和状态寄存器。串口初始化时会分别注册 <code>0x3F8</code> 和 <code>0x3FC</code> 处长度为1个字节的端口，分别作为数据寄存器和状态寄存器。由于NEMU串行模拟计算机系统的工作，串口的状态寄存器可以一直处于空闲状态; 每当CPU往数据寄存器中写入数据时，串口会将数据传送到主机的标准输出。</p><table><thead><tr><th>函数/宏</th><th>描述</th></tr></thead><tbody><tr><td><code>init_serial()</code></td><td>初始化设备</td></tr><tr><td><code>SERIAL_PORT=0x3F8</code></td><td>端口 I/O 地址</td></tr></tbody></table><h3 id=timerc>timer.c</h3><p>时钟设备。
模拟了i8253计时器的功能. 计时器的大部分功能都被简化, 只保留了"发起时钟中断"的功能. 同时添加了一个自定义的RTC(Real Time Clock), 初始化时将会注册0x48处的端口作为RTC寄存器, CPU可以通过I/O指令访问这一寄存器, 获得当前时间(单位是ms).</p><table><thead><tr><th>函数/宏</th><th>描述</th></tr></thead><tbody><tr><td><code>init_timer()</code></td><td>初始化设备</td></tr><tr><td><code>RTC_PORT=0x48</code></td><td>端口 I/O 地址</td></tr></tbody></table><h3 id=keyboardc>keyboard.c</h3><p>键盘设备。
模拟了i8042通用设备接口芯片的功能. 其大部分功能也被简化, 只保留了键盘接口. i8042初始化时会注册 <code>0x60</code> 处的端口（长度为 4）作为数据寄存器. 每当用户敲下/释放按键时, 将会把相应的键盘码放入数据寄存器, CPU可以通过端口I/O访问数据寄存器, 获得键盘码; 当无按键可获取时, 将会返回 <code>_KEY_NONE</code> . 在AM中, 我们约定通码的值为 <code>断码 | KEYDOWN_MASK</code>.</p><table><thead><tr><th>函数/宏</th><th>描述</th></tr></thead><tbody><tr><td><code>init_i8042()</code></td><td>初始化设备</td></tr><tr><td><code>I8042_DATA_PORT=0x60</code></td><td>端口 I/O 地址</td></tr><tr><td><code>KEYDOWN_MASK=0x8000</code></td><td>通码 MASK</td></tr><tr><td><code>KEY_QUEUE_LEN</code></td><td>键队列长度</td></tr></tbody></table><h3 id=vgac>vga.c</h3><p>VGA 设备。
模拟了VGA的功能. VGA初始化时注册了从 <code>0x40000</code> 开始的一段用于映射到video memory的物理内存. 在NEMU中, video memory是唯一使用内存映射I/O方式访问的I/O空间. 代码只模拟了400x300x32的图形模式, 一个像素占32个bit的存储空间, R(red), G(green), B(blue), A(alpha)各占8 bit, 其中VGA不使用alpha的信息。VGA 设备同时注册了位于 <code>0x100</code> 的长度为 4 的端口存储屏幕大小信息。</p><table><thead><tr><th>函数/宏</th><th>描述</th></tr></thead><tbody><tr><td><code>init_vga()</code></td><td>初始化设备</td></tr><tr><td><code>SCREEN_PORT=0x100</code></td><td>端口 I/O 地址</td></tr><tr><td><code>VMEM=0x40000</code></td><td>内存映射 I/O 地址</td></tr><tr><td><code>SCREEN_H</code></td><td>屏幕高度</td></tr><tr><td><code>SCREEN_W</code></td><td>屏幕宽度</td></tr></tbody></table><h2 id=monitor-1>monitor/</h2><p>监视器部分实现（也包含 NEMU 执行主循环）。</p><h3 id=monitorc>monitor.c</h3><h4 id=函数-init_monitor>函数 init_monitor</h4><p>初始化监视器并启动（用于 <code>main.c/main</code> 中）。</p><ul><li>解析并处理命令行参数</li><li>初始化日志文件</li><li>寄存器测试（调用 <code>reg_test()</code>，实现在 <code>src/cpu/reg.c</code>）</li><li>加载程序镜像（根据命令行参数，如果为空，则调用 <code>load_default_img()</code> 加载默认镜像）</li><li>启动环境（调用 <code>restart()</code>，初始化应用程序入口点，寄存器值）</li><li>编译正则表达式（调用 <code>init_regex()</code>，实现在 <code>src/monitor/debug/expr.c</code>）</li><li>初始化监视点池（调用 <code>init_wp_pool()</code>，实现在 <code>src/monitor/debug/watchpoint.c</code>）</li><li>初始化设备（调用 <code>init_device()</code>，实现在 <code>src/device/device.c</code>）</li><li>初始化差异测试（调用 <code>init_difftest()</code>，实现在 <code>src/monitor/diff-test.c</code>）</li><li>显示欢迎界面</li><li>返回是否为批处理模式（根据命令行参数）</li></ul><p>注：</p><ul><li>命令行参数<ul><li><code>[img_file]</code> 指定应用程序镜像文件</li><li><code>-b</code> 批处理模式</li><li><code>-l log_file</code> 指定日志文件</li><li><code>-d</code> 指定 Diff-Test 镜像文件</li></ul></li></ul><h3 id=cpu-execc>cpu-exec.c</h3><h4 id=函数-cpu_exec>函数 cpu_exec</h4><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>cpu_exec</span><span class=p>(</span><span class=n>uint64_t</span> <span class=n>n</span><span class=p>);</span>
</code></pre></div><p>模拟 CPU 工作。</p><ul><li>判断 NEMU 状态（查看 <code>nemu_state</code>，定义在 <code>include/monitor/monitor.h</code>）</li><li>若指令数 <code>n</code> 小于 <code>MAX_INSTR_TO_PRINT</code> （默认为 10），则打印每条指令。</li><li>开始执行指令<ul><li>调用 <code>exec_wrapper</code> 执行下一条指令（传入是否打印指令标记）</li><li>检查监视点状态是否有更新</li><li>更新设备信息</li><li>判断 NEMU 状态（查看 <code>nemu_state</code>），决定是否退出</li></ul></li><li>执行完 <code>n</code> 条指令后，将 NEMU 状态置为结束（<code>NEMU_END</code>）</li></ul><p>注：</p><ul><li>执行某条命令后<ul><li>若 NEMU 状态为结束（<code>NEMU_END</code>），则检查程序返回值（<code>cpu.eax</code>）是否为 0（是否正常退出）。并输出 <code>HIT GOOD TRAP</code>（正常退出） 或 <code>HIT BAD TRAP</code>（非正常退出）。</li></ul></li></ul><h3 id=debug>debug/</h3><h4 id=watchpointc>watchpoint.c</h4><p>定义了监视点内存池及其相关的函数。</p><ul><li><code>wp_pool</code> 监视点池</li><li><code>head</code> 使用中的监视点链表头指针</li><li><code>free_</code> 监视点池中未使用的监视点链表头指针</li></ul><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>init_wp_pool()</code></td><td>初始化监视点内存池</td></tr><tr><td><code>clearWP(wp)</code></td><td>清空某监视点的下一项指针</td></tr><tr><td><code>WP *getHeadWP()</code></td><td>获取 <code>head</code></td></tr><tr><td><code>WP *createWP()</code></td><td>申请使用一个新监视点（内部调用 <code>new_wp()</code> 并更新链表信息）</td></tr><tr><td><code>removeWP(no)</code></td><td>删除指定编号的监视点</td></tr><tr><td><code>WP *new_wp()</code></td><td>（私有）从内存池中获取下一个能使用的监视点，并作一定预处理</td></tr><tr><td><code>free_wp(wp)</code></td><td>（私有）释放一个监视点</td></tr></tbody></table><h4 id=exprc>expr.c</h4><p>实现了 <code>expr.h/expr</code> 函数，实现表达式解析和求值。</p><h5 id=常量>常量</h5><ul><li><code>PRI_NEG</code> 取负运算优先级</li><li><code>PRI_POINT</code> 解引用运算优先级</li><li>形如 <code>TK_TYPE</code> 的 Token 类型枚举</li></ul><h5 id=数组-rules>数组 rules</h5><p>规定了使用正则表达式解析 Token 的规则。</p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td><code>regex</code></td><td>正则表达式字符串</td></tr><tr><td><code>token_type</code></td><td>对应 Token 类型，可用 <code>TK_TYPE</code> 枚举或字符（如 <code>+</code>）表示</td></tr><tr><td><code>opPri</code></td><td>运算符 Token 的优先级</td></tr></tbody></table><h5 id=数组-re>数组 re</h5><p>根据 <code>rules</code> 编译后的正则表达式。</p><h5 id=函数-init_regex>函数 <code>init_regex</code></h5><p>根据 <code>rules</code> 编译到 <code>re</code></p><h5 id=结构体-token>结构体 Token</h5><p>识别后的 Token.</p><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td><code>type</code></td><td>Token 类型，可用 <code>TK_TYPE</code> 枚举或字符（如 <code>+</code>）表示</td></tr><tr><td><code>isOp</code></td><td>标记此 Token 是否是运算符</td></tr><tr><td><code>isValue</code></td><td>标记此 Token 是否是值</td></tr><tr><td><code>str</code></td><td>Token 的原始字符串</td></tr><tr><td><code>data</code></td><td>值类型的实际数据</td></tr><tr><td><code>priority</code></td><td>运算符的优先级</td></tr></tbody></table><ul><li><code>isOp</code> 和 <code>isValue</code> 多用于区分特殊单目运算符，如解引用和取负</li><li><code>data</code> 多存储经过预处理的数据，如转换后的整数</li></ul><blockquote><p>解析后的 Token 列表存储在数组 <code>tokens</code> 中。
<code>nr_token</code> 指示 <code>token</code> 有效长度。</p></blockquote><h5 id=函数-make_token>函数 make_token</h5><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=kt>bool</span> <span class=n>make_token</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>e</span><span class=p>)</span>
</code></pre></div><p>根据字符串解析 Token 列表，返回是否解析成功。</p><p>实现思路：使用 <code>re</code> 依次尝试每一种匹配，直到遇到第一个成功匹配，根据其规则的 <code>token_type</code> 生成 Token，存入 <code>token</code>。</p><ul><li>函数 <code>toInteger</code> ：以指定进制完成字符串到数的转换，用于 十进制，二进制，八进制，十六进制 数的解析。</li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>static</span> <span class=n>uint32_t</span> <span class=n>toInteger</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>s</span><span class=p>,</span> <span class=n>uint32_t</span> <span class=n>base</span><span class=p>)</span>
</code></pre></div><h5 id=函数-evalwithtoken>函数 evalWithToken</h5><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=n>uint32_t</span> <span class=n>evalWithToken</span><span class=p>(</span><span class=kt>int</span> <span class=n>l</span><span class=p>,</span> <span class=kt>int</span> <span class=n>r</span><span class=p>,</span> <span class=kt>bool</span> <span class=o>*</span> <span class=n>success</span><span class=p>)</span>
</code></pre></div><p>求解 <code>tokens[l..r]</code> 中的表达式的值。</p><p>实现思路：单 Token 特殊处理，然后处理外围括号情况，然后确定最后计算的运算符，分割成 <code>left</code> 和 <code>right</code> 两部分，然后递归解决，最后合并，</p><ul><li>函数 <code>checkExtraP</code> 判断 <code>tokens[l..r]</code> 是否外围为括号且括号匹配正常。</li><li>函数 <code>getReg</code> 根据寄存器名获取寄存器值，使用了 <code>regMap</code></li><li>数组 <code>regMap</code> 标识寄存器名与对应的偏移量（<code>cpu.gpr</code>）</li></ul><h5 id=函数-expr>函数 expr</h5><p>对 <code>expr.h/expr</code> 的实现，调用了 <code>make_token</code> 和 <code>evalWithToken</code>。</p><h4 id=uic>ui.c</h4><p>监视器 CUI 部分。</p><h5 id=函数族-fc2color>函数族 fc2color</h5><p>控制台字体颜色控制。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>fc2red</code></td><td>前景色设为红色</td></tr><tr><td><code>fc2green</code></td><td>前景色设为绿色</td></tr><tr><td><code>fc2yellow</code></td><td>前景色设为黄色</td></tr><tr><td><code>fc2blue</code></td><td>前景色设为蓝色</td></tr><tr><td><code>fc2purple</code></td><td>前景色设为紫色</td></tr><tr><td><code>csClear</code></td><td>清除所有控制台设置</td></tr></tbody></table><h5 id=函数族-cmd_item>函数族 cmd_item</h5><p>不同命令的实现。</p><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td><code>cmd_help</code></td><td>获取帮助</td></tr><tr><td><code>cmd_q</code></td><td>退出</td></tr><tr><td><code>cmd_c</code></td><td>继续执行（调用 <code>cpu_exec(-1)</code>，实现在 <code>src/monitor/cpu-exec.c</code>）</td></tr><tr><td><code>cmd_si</code></td><td>执行单步指令</td></tr><tr><td><code>cmd_info name</code></td><td>查看信息</td></tr><tr><td><code>cmd_x N expr</code></td><td>显示地址从 <code>expr</code> 的值开始的 <code>N</code> 个字节值</td></tr><tr><td><code>cmd_p expr</code></td><td>计算表达式的值</td></tr><tr><td><code>cmd_w expr</code></td><td>新建监视点，监视表达式为 <code>expr</code></td></tr><tr><td><code>cmd_d no</code></td><td>删除指定编号的监视点</td></tr></tbody></table><ul><li><code>cmd_info</code><ul><li><code>r</code> 打印所有寄存器信息</li><li><code>w</code> 打印所有监视点信息</li></ul></li></ul><h5 id=数组-cmd_table>数组 cmd_table</h5><table><thead><tr><th>成员</th><th>描述</th></tr></thead><tbody><tr><td><code>name</code></td><td>命令名（用于识别命令）</td></tr><tr><td><code>description</code></td><td>命令描述（用于帮助列表）</td></tr><tr><td><code>handler</code></td><td>命令实现函数指针</td></tr></tbody></table><h5 id=函数-ui_mainloop>函数 ui_mainloop</h5><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>ui_mainloop</span><span class=p>(</span><span class=kt>int</span> <span class=n>is_batch_mode</span><span class=p>);</span>
</code></pre></div><p>NEMU 以及其 CUI 主循环，不断读取命令，并执行。</p><ul><li>如果是批处理模式（<code>is_batch_mode</code> 为真），则直接执行应用程序，不监听用户命令。</li></ul><h3 id=diff-test>diff-test/</h3><p>差异测试实现。</p><blockquote><p>如果有一种方法能够表达指令的正确行为, 我们就可以基于这种方法来进行类似assert()的检查了。那么, 究竟什么地方表达了指令的正确行为呢? 最直接的, 当然就是i386手册了, 但是我们恰恰就是根据i386手册中的指令行为来在NEMU中实现指令的, 同一套方法不能既用于实现也用于检查. 如果有一个i386手册的参考实现就好了. 嘿! 我们用的真机不就是根据i386手册实现出来的吗? 我们让在NEMU中执行的每条指令也在真机中执行一次, 然后对比NEMU和真机的状态, 如果NEMU和真机的状态不一致, 我们就捕捉到error了!
这实际上是一种非常奏效的测试方法, 在软件测试领域称为differential testing(后续简称DiffTest). 我们刚才提到了"状态", 那"状态"具体指的是什么呢? 我们在PA1中已经认识到, 计算机就是一个数字电路. 那么, &ldquo;计算机的状态"就恰恰是那些时序逻辑部件的状态, 也就是寄存器和内存的值. 其实仔细思考一下, 计算机执行指令, 就是修改这些时序逻辑部件的状态的过程. 要检查指令的实现是否正确, 只要检查这些时序逻辑部件中的值是否一致就可以了! DiffTest可以非常及时地捕捉到error, 第一次发现NEMU的寄存器或内存的值与真机不一样的时候, 就是因为当时执行的指令实现有误导致的. 这时候其实离error非常接近, 防止了error进一步传播的同时, 要回溯找到fault也容易得多.
多么美妙的功能啊! 背后还蕴含着计算机本质的深刻原理! 但很遗憾, 不要忘记了, 真机上是运行了操作系统GNU/Linux的, 而NEMU中的测试程序是运行在x86-nemu上的, 我们无法在native中运行编译到x86-nemu的AM程序. 所以, 我们需要的不仅是一个i386手册的正确实现, 而且需要在上面能正确运行x86-nemu的AM程序.
事实上, QEMU就是一个不错的参考实现. 它是一个虚拟出来的完整的x86计算机系统, 而NEMU的目标只是虚拟出x86的一个子集, 能在NEMU上运行的程序, 自然也能在QEMU上运行. 因此, 为了通过DiffTest的方法测试NEMU实现的正确性, 我们让NEMU和QEMU逐条指令地执行同一个客户程序. 双方每执行完一条指令, 就检查各自的寄存器和内存的状态, 如果发现状态不一致, 就马上报告错误, 停止客户程序的执行.</p></blockquote><h4 id=diff-testh>diff-test.h</h4><p>定义了宏 <code>DIFFTEST_REG_SIZE</code> 规定访问的寄存器大小。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define DIFFTEST_REG_SIZE (sizeof(uint32_t) * 9) </span><span class=c1>// GRPs + EIP
</span></code></pre></div><h4 id=refc>ref.c</h4><p>在 DUT(Design Under Test, 测试对象)和 REF(Reference, 参考实现) 之间定义了一组 API。</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=c1>// 从DUT host memory的 src 处拷贝 n 字节到REF guest memory的 dest 处
</span><span class=c1></span><span class=kt>void</span> <span class=nf>difftest_memcpy_from_dut</span><span class=p>(</span><span class=n>paddr_t</span> <span class=n>dest</span><span class=p>,</span> <span class=kt>void</span> <span class=o>*</span><span class=n>src</span><span class=p>,</span> <span class=n>size_t</span> <span class=n>n</span><span class=p>);</span>
<span class=c1>// 获取REF的寄存器状态到 r 
</span><span class=c1></span><span class=kt>void</span> <span class=nf>difftest_getregs</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>r</span><span class=p>);</span>
<span class=c1>// 设置REF的寄存器状态为 r 
</span><span class=c1></span><span class=kt>void</span> <span class=nf>difftest_setregs</span><span class=p>(</span><span class=k>const</span> <span class=kt>void</span> <span class=o>*</span><span class=n>r</span><span class=p>);</span>
<span class=c1>// 让REF执行 n 条指令
</span><span class=c1></span><span class=kt>void</span> <span class=nf>difftest_exec</span><span class=p>(</span><span class=n>uint64_t</span> <span class=n>n</span><span class=p>);</span>
<span class=c1>// 初始化REF的DiffTest功能
</span><span class=c1></span><span class=kt>void</span> <span class=nf>difftest_init</span><span class=p>();</span>
</code></pre></div><ul><li>其中寄存器状态 <code>r</code> 要求寄存器的值按照某种顺序排列，若未按要求顺序排列， <code>difftest_getregs()</code> 和 <code>difftest_setregs()</code> 的行为是未定义的. REF 需要实现这些 API，DUT会使用这些 API 来进行 DiffTest 。</li></ul><h4 id=diff-testc>diff-test.c</h4><p>定义了变量 <code>is_skip_ref</code>，<code>is_skip_dut</code> 用于标记忽视一些指令处的比对。（可结合 <code>difftest_step</code> 实现）
定义了函数 <code>difftest_skip_ref</code>，<code>difftest_skip_dut</code> 标记上述变量。</p><h5 id=函数-init_difftest>函数 init_difftest</h5><p>初始化 Diff-Test。</p><ul><li>打开动态库文件 <code>ref_so_file</code></li><li>从动态库中分别读取上述 API 的符号</li><li>对 REF 的 DIffTest功能进行初始化，此时会启动 REF，代码还会对 REF 的状态进行一些初始化工作，REF 运行在后台，因此将看不到 REF 的任何输出</li><li>将 DUT 的 guest memory 拷贝到 REF 中</li><li>将 DUT 的寄存器状态拷贝到 REF 中</li></ul><h5 id=函数-difftest_step>函数 difftest_step</h5><p>用于逐条指令执行后的状态对比。它会在 <code>exec_wrapper()</code> 的最后被调用。在这里读取 REF 的寄存器并与 NEMU 寄存器状态比对。</p><h2 id=misc>misc/</h2><h3 id=logoc>logo.c</h3><p>定义了字符数组 <code>logo</code> 存储 i386 Manual Logo。用于 <code>inv</code> 指令（位于 <code>special.c</code> 中）。</p><h1 id=tools>tools/</h1><h2 id=gen-exprc>gen-expr.c</h2><p>生成 C 表达式，用于测试表达式求值功能。</p><h2 id=qemu-diff>qemu-diff</h2><p>QEMU 实现，用于 Diff-Test。编译成动态库 <code>qemu-so</code>，传入 nemu 的 <code>-d</code> 参数中。</p><h1 id=引用资料>引用资料</h1><ul><li><a class=link href=https://legacy.gitbook.com/book/nju-ics/ics2018-programming-assignment/details target=_blank rel=noopener>ICS2018 PA 讲义</a></li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/nju/>NJU</a></section><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{renderMathInElement(document.querySelector(`.article-content`),{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}]})})</script></article><div id=remark42></div><script>var remark_config={host:"https://comments.stardustdl.top",site_id:'blog',components:['embed'],url:"https://stardustdl.github.io/posts/learning/nju-icspa-analytics-nemu/",max_shown_comments:15,theme:document.body.dataset.scheme,page_title:'NJU ICS Programming Assignment 代码分析 - NEMU',locale:'en',show_email_subscription:!0};(function(d){for(var a=0,b,c;a<d.length;a++)b=document,c=b.createElement('script'),c.src=remark_config.host+'/web/'+d[a]+'.js',c.defer=!0,(b.head||b.body).appendChild(c)})(remark_config.components||['embed']),window.addEventListener('onColorSchemeChange',a=>{window.REMARK42.changeTheme(a.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2021 StardustDL's Blog</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=2.2.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css integrity="sha256-c0uckgykQ9v5k+IqViZOZKc47Jn7KQil4/MP3ySA3F8=" crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE=" crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous defer></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const a=document.createElement('link');a.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",a.type="text/css",a.rel="stylesheet",document.head.appendChild(a)})()</script></body></html>